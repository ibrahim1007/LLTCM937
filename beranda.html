<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Risk & Reward Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- Pustaka untuk Excel (xlsx) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Pustaka untuk PDF (jsPDF & html2canvas) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- BARU: Tambahkan plugin jsPDF-AutoTable untuk membuat tabel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.2.1/chartjs-plugin-annotation.min.js"></script>
    <style>

      /* --- TAMBAHAN CSS UNTUK AUTO SCROLL --- */
@keyframes scroll-left {
  0% {
    transform: translateX(0);
  }
  100% {
    /* Bergerak ke kiri sejauh satu blok konten */
    transform: translateX(-100%);
  }
}

.animate-scroll-left {
  /* Durasi default (mobile): 15s (lebih cepat) */
  animation: scroll-left 15s linear infinite;
}

/* Media query untuk layar 'sm' (640px) ke atas */
@media (min-width: 640px) {
  .animate-scroll-left {
    /* Durasi desktop: 25s (seperti sebelumnya) */
    animation: scroll-left 25s linear infinite;
  }
}

/* --- AKHIR TAMBAHAN CSS --- */

      /* Custom styles based on user's provided CSS */
      body {
        font-family: "Inter", sans-serif;
        background-color: #fcfcfc;
        color: #333;
        font-size: 0.8125rem;
        padding: 1;
      }
      .container-wrapper {
        background-color: #ffffff;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
        border-radius: 12px;
        border: 1px solid #eeeeee;
        padding: 1.5rem;
        margin-top: 6rem; /* Increased margin to accommodate larger header */
        margin-left: auto;
        margin-right: auto;
        width: 100%;
        max-width: 1536px;
      }
      .header-global {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 1rem 1.5rem; /* Adjusted padding for better mobile view */
        background-color: rgba(255, 255, 255, 0.8); /* White and transparent */
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 50;
        color: #333; /* Black text */
        
      }

      .mobile-nav-link {
  font-size: 1.0rem;
  line-height:1.rem; /* PERBAIKAN: Disesuaikan agar rapi */
}
      .header-section {
        background-color: rgba(247, 247, 247, 0.8);
        border-bottom: 1px solid #e8e8e8;
        padding: 1.rem 1.5rem;
        margin-left: -1.5rem;
        margin-right: -1.5rem;
      }
      .text-primary {
        color: #2a2a2a;
      }
      .input-label {
        color: #5a5a5a;
        font-weight: 500;
        font-size: 0.75rem;
      }
      .input-field,
      .select-field {
        border: 1px solid #e0e0e0;
        background-color: #ffffff;
        color: #333;
        border-radius: 6px;
        padding: 0.55rem 0.8rem;
        transition: border-color 0.2s, box-shadow 0.2s;
        font-size: 0.75rem;
      }
      .input-field:focus,
      .select-field:focus {
        border-color: #bbbbbb;
        outline: none;
        box-shadow: 0 0 0 2px rgba(187, 187, 187, 0.2);
      }
      .input-group-percent span {
        background-color: #f0f0f0;
        border: 1px solid #e0e0e0;
        border-left: none;
        border-radius: 0 6px 6px 0;
        color: #5a5a5a;
        padding: 0.55rem 0.8rem;
        font-size: 0.75rem;
      }
      .buy-button,
      .sell-button {
        border: 1px solid #e0e0e0;
        background-color: #f9f9f9;
        color: #5a5a5a;
        border-radius: 6px;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        font-size: 0.75rem;
        padding: 0.55rem 0.8rem;
      }
      .buy-button.active {
        background-color: #eafaea;
        color: #28a745;
        border-color: #c9ecc9;
        font-weight: 600;
      }
      .sell-button.active {
        background-color: #faeaea;
        color: #dc3545;
        border-color: #ecc9c9;
        font-weight: 600;
      }

      /* --- Perubahan untuk Tombol Aksi (Add, Calculate) --- */
      .action-button {
        background-color: #222222;
        color: #ffffff;
        border: 1px solid #111111;
        border-radius: 6px;
        font-weight: 600;
        padding: 0.6rem 1.1rem;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        font-size: 0.8125rem;
      }
      .action-button:hover {
        background-color: #3a3a3a;
        border-color: #222222;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
      .action-button:active {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      /* --- End Perubahan Tombol Aksi --- */

      /* New style for the "Tambah Foto" button */
      .light-action-button {
        background-color: #e0e0e0;
        color: #222222;
        border: 1px solid #cccccc;
        border-radius: 6px;
        font-weight: 300;
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 1px 3px (0, 0, 0, 0.08);
      }
      .light-action-button:hover {
        background-color: #d0d0d0;
        border-color: #bbbbbb;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .light-action-button:active {
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.05);
      }

      /* New style for the "Hapus Data" button */
      .delete-data-button {
        background-color: transparent;
        color: #dc3545;
        border: none;
        font-weight: 300;
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        transition: color 0.2s;
      }
      .delete-data-button:hover {
        color: #c82333;
      }

      /* New style for the "Unggah Data" and "Unduh Excel" buttons */
      .upload-data-button {
        background-color: #e0e0e0;
        color: #222222;
        border: 1px solid #cccccc;
        border-radius: 6px;
        font-weight: 300;
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .upload-data-button:hover {
        background-color: #d0d0d0;
        border-color: #bbbbbb;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .upload-data-button:active {
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.05);
      }

      .delete-row-btn {
        color: #999;
        transition: color 0.2s;
      }
      .delete-row-btn:hover {
        color: #f44336;
      }
      .results-table {
        border-collapse: collapse;
        width: 100%;
      }
      .results-table th,
      .results-table td {
        padding: 6px 8px;
        text-align: center;
        border-bottom: 1px solid #f2f2f2;
        font-size: 0.6rem;
        font-weight: 300;
        white-space: nowrap;
      }
      .results-table th {
        background-color: #e0e0e0;
        color: #333;
        font-weight: 300;
        text-transform: uppercase;
        font-size: 0.6rem;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .results-table td:nth-child(1),
      .results-table td:nth-child(2) {
        text-align: left;
      }
      .results-table th:nth-child(1),
      .results-table th:nth-child(2) {
        text-align: left;
      }
      .results-table td:nth-child(14) {
        text-align: center;
        font-weight: 300;
        color: #222;
        font-size: 0.6rem;
      }
      .results-table tbody tr:last-child td {
        border-bottom: none;
      }
      .results-table tbody tr:hover {
        background-color: #fdfdfd;
      }
      .positive-value {
        color: #28a745;
        font-weight: 500;
      }
      .negative-value {
        color: #dc3545;
        font-weight: 500;
      }
      .neutral-value {
        color: #333;
      }
      .detail-section {
        background-color: #ffffff;
        border: 1px solid #e0e0e0;
        border-radius: 10px;
        padding: 1.2rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        font-size: 0.75rem;
      }
      .detail-section.active {
        opacity: 1;
        transform: translateY(0);
      }
      .detail-label {
        font-weight: 600;
        color: #2a2a2a;
        margin-right: 0.5rem;
      }
      .detail-value {
        color: #555;
      }
      .error-message {
        background-color: #fdeaea;
        color: #dc3545;
        border: 1px solid #f5c6cb;
        border-radius: 6px;
        padding: 8px;
        font-size: 0.75rem;
        margin-top: 1rem;
      }
      /* Custom scrollbar for input rows container */
      #inputRowsContainer {
        max-height: 400px;
        overflow-y: auto;
        padding-right: 8px;
        margin-bottom: 1.5rem;
      }
      #inputRowsContainer::-webkit-scrollbar {
        width: 8px;
      }
      #inputRowsContainer::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      #inputRowsContainer::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      #inputRowsContainer::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }
      /* Styles for the table cell containing action buttons in active plans */
      .action-buttons-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.4rem;
      }
      /* Styles for the new action buttons in active plans */
      .action-button-small {
        background-color: #222222;
        color: white;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        font-weight: 500;
        font-size: 0.6rem;
        transition: background-color 0.2s, opacity 0.2s;
        white-space: nowrap;
        border: 1px solid #111111;
      }
      .action-button-small:hover {
        opacity: 0.8;
      }

      /* Specific font size for main titles */
      h1.text-3xl {
        font-size: 1.25rem;
        font-weight: 200;
      }
      /* Adjusted font size for h2 titles in statistics sections */
      h2.text-lg {
        font-size: 0.8rem;
        font-weight: 300;
      }
      /* New style for modal title */
      #photoUploadModal h3 {
        font-size: 0.9rem;
        font-weight: 600;
        color: #2a2a2a;
      }
      p.text-sm {
        font-size: 0.7rem;
        font-weight: 200;
      }

      /* Responsive adjustments for smaller screens */
      @media (max-width: 768px) {
        .container-wrapper {
          padding: 1rem;
          margin-top: 5rem;
        }
        .header-global {
          padding: 1rem 1.5rem;
        }
        .header-global span,
        .header-global a {
          font-size: 0.75rem;
        }
        #currentDateHeader,
        #currentTimeHeader,
        #mobileMenuDateTime {
          font-size: 0.65rem;
        }
        .header-section {
          padding: 1.5rem 1rem;
          margin-left: -1rem;
          margin-right: -1rem;
        }
        h1.text-3xl {
          font-size: 1.1rem;
        }
        h2.text-lg {
          font-size: 0.8rem;
        }
        .input-row {
          padding: 1rem;
        }
        .input-label,
        .input-field,
        .select-field,
        .input-group-percent span,
        .buy-button,
        .sell-button,
        .action-button,
        .results-table th,
        .results-table td {
          font-size: 0.75rem;
        }
        .action-button {
          padding: 0.5rem 0.8rem;
        }
        .action-button-small {
          padding: 0.2rem 0.4rem;
          font-size: 0.6rem;
        }
        .grid-cols-1.sm:grid-cols-2.md:grid-cols-3.lg:grid-cols-6 {
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        .top-left-photo-section {
          flex-direction: column;
          align-items: center;
          gap: 0.5rem;
          padding-left: 0;
          padding-top: 0;
        }
        #executedTradingPlansSection > div.flex {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.75rem;
        }
        #executedTradingPlansSection > div.flex > h2 {
          margin-bottom: 0;
        }
        #executedTradingPlansSection > div.flex > div.flex {
          flex-direction: row;
          width: 100%;
          justify-content: flex-start;
        }
        .photo-gallery-container {
          width: 100%;
          max-width: none;
        }
        .photo-carousel {
          width: 100%;
          height: auto;
          aspect-ratio: 1 / 1;
        }
        .photo-slides img {
          width: 100%;
          height: 100%;
          object-fit: cover;
        }
        #dailyLineChartContainer,
        #monthlyBarChartContainer,
        #overallPercentageCumulativeChartContainer,
        #overallBalanceCumulativeChartContainer,
        #overallPipsCumulativeChartContainer,
        #tradeFrequencyChartContainer {
          padding: 1rem;
          min-height: 220px;
        }
        #pieChartContainer {
          padding: 1rem;
          min-height: 280px;
        }

        /* --- GANTI SELURUH BLOK INI --- */
        /* --- PERBAIKAN POP UP DIMULAI DI SINI --- */
        .modal-content {
          padding: 1rem; /* Padding atas, bawah, kiri, kanan diperkecil */
          width: 95%;
          max-width: 380px; /* Batas lebar maks agar tidak terlalu lebar di mode landscape HP */
        }

        /* Perkecil judul & jaraknya */
        .modal-content h3 {
          font-size: 0.9rem; /* Ukuran font judul diperkecil */
          margin-bottom: 0.75rem; /* Jarak bawah judul dikurangi */
        }

        .modal-body-scrollable {
          max-height: 55vh; /* Tinggi maksimal area scroll dikurangi */
          overflow-y: auto;
          padding-right: 0.5rem;
          margin-right: -0.5rem;
          margin-bottom: 1rem; /* Jarak bawah konten sebelum tombol dikurangi */
        }
        .modal-body-scrollable::-webkit-scrollbar {
          width: 6px;
        }
        .modal-body-scrollable::-webkit-scrollbar-track {
          background: #f0f0f0;
          border-radius: 10px;
        }
        .modal-body-scrollable::-webkit-scrollbar-thumb {
          background: #c0c0c0;
          border-radius: 10px;
        }
        .modal-body-scrollable::-webkit-scrollbar-thumb:hover {
          background: #a0a0a0;
        }
        /* --- AKHIR DARI PERBAIKAN POP UP --- */
        /* --- HINGGA DI SINI --- */
      }

      @media (min-width: 769px) {
        .header-global {
          padding: 2rem 2.5rem;
        }
      }

      /* Tambahkan ini di dalam tag <style> */
.intervened-cell {
    border: 2px solid #fca5a5 !important; /* List Merah */
    background-color: #fef2f2 !important; /* Background Merah Muda sangat tipis */
    border-radius: 4px;
}

      /* Ensure tables are horizontally scrollable on small screens */
      .overflow-x-auto {
        overflow-x: auto;
      }
      /* Styles for download buttons */
      .download-buttons {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        justify-content: flex-end;
        display: none;
      }
      .download-button {
        background-color: #222222;
        color: #ffffff;
        padding: 0.4rem 0.8rem;
        border-radius: 6px;
        font-weight: 500;
        font-size: 0.75rem;
        cursor: pointer;
        border: none;
      }
      .download-button.pdf {
        background-color: #222222;
      }
      .download-button:hover {
        opacity: 0.9;
      }
      .download-button:active {
        transform: translateY(0);
      }

      /* Styles for photo gallery container */
      .photo-gallery-container {
        position: relative;
        display: block;
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
      }
      .photo-carousel {
        width: 100%;
        aspect-ratio: 1 / 1;
        height: auto;
        border-radius: 8px;
        border: 1px solid #cccccc;
        object-fit: cover;
        margin: 0 auto;
        cursor: pointer;
        overflow: hidden;
      }
      .photo-slides {
        display: flex;
        transition: transform 0.3s ease-in-out;
        height: 100%;
      }
      .photo-slides img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        flex-shrink: 0;
      }

      /* New styles for the top-left photo and button container */
      .top-left-photo-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 1.5rem;
      }

      @media (min-width: 769px) {
        .top-left-photo-section {
          flex-direction: row;
          justify-content: center;
        }
        .photo-gallery-container {
          max-width: 400px;
        }
        #executedTradingPlansSection > div.flex {
          flex-direction: row;
          justify-content: space-between;
        }
        #executedTradingPlansPlansSection > div.flex > div.flex {
          width: auto;
        }
      }

      /* Added style for executed plans table container to enable vertical scrolling */
      #executedPlansTableContainer {
        max-height: 300px;
        overflow-y: auto;
        border-radius: 0.5rem;
        border: 1px solid #e0e0e0;
      }
      #executedPlansTableContainer::-webkit-scrollbar {
        width: 8px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      /* --- PERBAIKAN: Style baru untuk kontainer tabel ringkasan dengan scroll vertikal --- */
      .summary-table-container {
        border-radius: 0.5rem;
        border: 1px solid #e0e0e0;
      }
      .summary-table-container::-webkit-scrollbar {
        width: 8px;
      }
      .summary-table-container::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      .summary-table-container::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      .summary-table-container::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }
      /* --- AKHIR PERBAIKAN --- */

      /* --- Animasi Scroll (Fade-in-up) --- */
      .scroll-animate-section {
        opacity: 0;
        transform: translateY(50px);
        transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      }
      .scroll-animate-section.scrolled-into-view {
        opacity: 1;
        transform: translateY(0);
      }

      /* Adjusted Pie Chart Container for a balanced size */
      #pieChartContainer {
        min-height: 220px;
        max-width: 350px;
        margin: 0 auto;
      }

      /* Ensure canvas itself is responsive within its container */
      #assetSuccessPieChart {
        width: 100% !important;
        height: auto !important;
      }

      /* Styling for the new informational text section */
      .info-section {
        background-color: #ffffff;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        padding: 2rem;
        margin-top: 2rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
      }
      .info-section h2 {
        font-size: 1.25rem;
        font-weight: 500;
        color: #2a2a2a;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e8e8e8;
        padding-bottom: 0.5rem;
      }
      .info-section h3 {
        font-size: 1rem;
        font-weight: 600;
        color: #333;
        margin-top: 1.5rem;
        margin-bottom: 0.75rem;
      }
      .info-section p {
        font-size: 0.875rem;
        font-weight: 300;
        color: #555;
        line-height: 1.6;
        margin-bottom: 1rem;
      }
      .info-section ul {
        list-style-type: disc;
        margin-left: 1.5rem;
        margin-bottom: 1rem;
      }
      .info-section ul li {
        font-size: 0.875rem;
        font-weight: 300;
        color: #555;
        margin-bottom: 0.5rem;
      }
      .info-section strong {
        font-weight: 500;
        color: #333;
      }
      .info-section .list-circle {
        list-style-type: circle;
      }

      /* PERBAIKAN: Aturan warna yang disederhanakan dan konsisten */
      .positive-value {
        color: #2a2a2a; /* Warna hitam untuk nilai positif */
      }
      .negative-value {
        color: #dc3545; /* Warna merah untuk nilai negatif */
      }

      #overallSummaryStatisticsSection p.text-base,
      #riskRewardStatisticsSection p.text-base,
      #riskRewardStatisticsSection p.text-lg {
        font-weight: 300; /* Atur font-weight saja, warna akan diatur oleh JS */
      }

      /* Modal specific styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal.show {
        opacity: 1;
        visibility: visible;
      }
      .modal-content {
        background-color: #ffffff;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        position: relative;
        transform: translateY(-20px);
        transition: transform 0.3s ease;
      }
      .modal.show .modal-content {
        transform: translateY(0);
      }
      .modal-close-button {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #999;
      }
      .modal-close-button:hover {
        color: #333;
      }

      #photoUploadModal .flex.justify-center.items-center {
        width: 100%;
        max-width: 400px;
        aspect-ratio: 1 / 1;
        margin: 1rem auto;
      }
      #imageCanvas {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 8px;
      }

      /* --- NEW: Styles for Monthly Summary Table --- */
      .monthly-summary-table th,
      .monthly-summary-table td {
        font-size: 0.55rem;
        padding: 4px 6px;
      }
      .monthly-summary-table th {
        font-weight: 400;
        text-align: center;
      }
      .info-section .list-circle {
        list-style-type: circle;
      }

      /* --- LETAKKAN KODE BARU DI SINI --- */
      .aspect-16-4 {
        aspect-ratio: 16 / 4;
      }
      .sharp-corners {
        border-radius: 0;
      }

      /* --- PERBAIKAN: Menghilangkan Bingkai di Semua Kontainer Grafik --- */
      #dailyLineChartContainer,
        #monthlyBarChartContainer,
        #overallPercentageCumulativeChartContainer,
        #overallBalanceCumulativeChartContainer,
        #overallPipsCumulativeChartContainer,
        #combinedSummaryBarChartContainer,
        #balanceFrequencyChartContainer,
        #percentageFrequencyChartContainer,
        #pipsFrequencyChartContainer,
        #executionFrequencyChartContainer,
        #assetExecutionCountChartContainer,
        #tradeFrequencyChartContainer,
        #pieChartContainer,
        /* Selector ini menargetkan div pembungkus grafik di bagian "Statistik Persentase Kumulatif Keseluruhan" */
        #overallPercentageCumulativeStatisticsSection > .bg-white {
        border: none !important; /* Menghapus garis bingkai */
        box-shadow: none !important; /* Menghapus bayangan (shadow) */
      }
      /* --- AKHIR DARI KODE PERBAIKAN --- */

      /* --- LETAKKAN KODE BARU DI SINI (di dalam tag <style>) --- */
      .calendar-date {
        font-size: 0.8rem;
        padding: 0.5rem 0;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: auto;
      }
      .calendar-date:hover:not(.today) {
        background-color: #f0f0f0;
      }
      .prev-month,
      .next-month {
        color: #b0b0b0;
      }
      .today {
        background-color: #2a2a2a;
        color: #ffffff;
        font-weight: 600;
      }
      /* OPSI: Style untuk indikator hari libur (titik kecil) */
      .holiday-indicator::after {
        content: '';
        position: absolute;
        bottom: 4px; /* Sesuaikan posisi vertikal */
        left: 50%;
        transform: translateX(-50%);
        width: 4px; /* Ukuran titik */
        height: 4px; /* Ukuran titik */
        background-color: #007bff; /* Warna titik (misal: biru) */
        border-radius: 50%;

        // ... (dalam chartSections)
        
        // ▼▼▼ TAMBAHKAN INI DI DALAM OBJEK chartSections ▼▼▼
        ghostEquityStatisticsSection: {
          render: fetchAndRenderGhostEquityChart,
          chartInstance: () => ghostEquityChart,
          setInstance: (chart) => (ghostEquityChart = chart),
          canvasId: "ghostEquityChart",
          loadingId: "ghostEquityChartLoading",
          errorId: "ghostEquityChartError",
          noDataId: "ghostEquityChartNoData",
          hasRendered: false,
        },
        sqnStatisticsSection: {
          render: calculateAndRenderSQN,
          chartInstance: () => null, // Bukan chart canvas, jadi null
          setInstance: () => {},
          canvasId: null,
          loadingId: null,
          errorId: null,
          noDataId: null,
          hasRendered: false,
        },
        // ▲▲▲ AKHIR TAMBAHAN ▲▲▲
        
        // ... (lanjutkan section dailyRisk, dll)
      }
    </style>
  </head>
  <body class="flex items-center justify-center min-h-screen">
    <!-- Global Header for the entire page (fixed at top) -->
    <div class="header-global">
      <div class="flex items-center gap-5">
        <span class="text-sm font-light">Beranda Utama</span>
        <span id="desktopUserAccount" class="hidden md:block text-sm font-semibold text-gray-700 ml-4">
          <!-- Nama akun akan diisi oleh JavaScript -->
        </span>
      </div>
      <div class="text-center absolute left-1/2 -translate-x-1/2">
        <span id="currentDateHeader" class="text-sm"></span>
        <span id="currentTimeHeader" class="text-sm"></span>
      </div>

      <!-- Desktop Navigation -->
      <nav class="hidden md:flex items-center space-x-6 font-light">
            <a href="index.html" class="hover:text-blue-600 transition-colors">Home</a>
            <a href="about_new.html" class="hover:text-blue-600 transition-colors">About</a>
            <a href="services.html" class="hover:text-blue-600 transition-colors">Services</a>
            <a href="contact.html" class="hover:text-blue-600 transition-colors">Contact</a>
            <a href="beranda.html" class="hover:text-blue-600 transition-colorsfont-medium text-blue-600">Beranda</a>
            <a href="investasi.html" class="hover:text-blue-600 transition-colors">Investasi</a>
            <a href="backtest.html" class="hover:text-blue-600 transition-colors ">Backtest</a>
        </nav>


      <!-- Hamburger Menu Button for Mobile -->
      <div class="md:hidden">
        <button id="hamburgerBtn" class="focus:outline-none">
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 6h16M4 12h16m-7 6h7"
            ></path>
          </svg>
        </button>
      </div>
    </div>

    <!-- ▼▼▼ GANTI SELURUH BLOK MOBILE MENU LAMA (BARIS 538-601) DENGAN INI ▼▼▼ -->
<!-- Mobile Menu (Full Screen Overlay) -->
<div
  id="mobileMenu"
  class="hidden fixed inset-0 bg-white/80 backdrop-blur-lg z-50 transition-transform duration-300 ease-in-out"
>
  <!-- Tombol Close (X) di Pojok Kanan Atas (DIPERKECIL) -->
  <button
    id="closeMenuBtn"
    class="fixed top-6 right-6 z-50 text-black focus:outline-none"
  >
    <svg
      class="w-6 h-6"
      fill="none"
      stroke="currentColor"
      stroke-width="1.5"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M6 18L18 6M6 6l12 12"
      ></path>
    </svg>
  </button>

  <!-- Konten Menu (Vertikal di Tengah) -->
  <div class="flex flex-col items-center justify-center h-full w-full p-6">
    <!-- Search Bar (Style Disesuaikan & Diperbaiki) -->
    

    <!-- Navigasi (MENGGUNAKAN KELAS BARU .mobile-nav-link) -->
    <nav class="flex flex-col items-center space-y-5">
      <a
        href="index.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >Home</a
      >
      <a
        href="about_new.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >About</a
      >
      <a
        href="services.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >Services</a
      >
      <a
        href="contact.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >Contact</a
      >
      <a
        href="beranda.html"
        class="mobile-nav-link font-light text-blue-600 hover:text-blue-600"
        >Beranda</a
      >
      <a
        href="investasi.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >Investasi</a
      >
      <a
        href="backtest.html"
        class="mobile-nav-link font-light text-black hover:text-blue-700"
        >Backtest</a
      >
    </nav>

    <!-- ▼▼▼ KODE BARU: Info Akun & Waktu Login ▼▼▼ -->
    <div class="absolute bottom-10 left-0 right-0 px-6 text-center mt-12">
      <p id="mobileUserName" class="text-sm font-semibold text-gray-800">
        <!-- Nama akun akan diisi oleh JavaScript -->
      </p>
      <p id="mobileLoginTime" class="text-xs text-gray-500 font-mono">
        <!-- Waktu login akan diisi oleh JavaScript -->
      </p>
    </div>
  </div>
</div>

<!-- ▲▲▲ AKHIR DARI BLOK PENGGANTIAN ▲▲▲ -->

    <div class="container-wrapper rounded-xl shadow-lg">
      <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
      saat market sedang bulan rangging  sama dengan ketika naik motor saat hujan harus selalu waspada.

    </h2>
      <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
      lawan arah di market sama dengan ketika di jalan kita menyalip sambil melawan arah saat naik motor

    </h2>
      <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
      account funding sama dengan mengendarai motor kinan harus lebih hati-hati.

    </h2>

      <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
      trading sama dengan kita mengendarai motor harus hati hati belajar dari pengalaman.

    </h2>
    <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
     hasil keuntungan yang di dapat pada bulan sebelumnya di compounded roi di bulan selanjutnya.
      <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    
        <!-- ▼▼▼ BLOK CATATAN TEKS 1:1 ▼▼▼ -->
<div class="w-full max-w-sm mx-auto mb-4">
  <div
    class="overflow-hidden rounded-lg border border-gray-200 bg-gray-100"
    style="aspect-ratio: 1 / 1.2"
  >
    <div class="p-6 sm:p-8 h-full flex flex-col justify-center items-start text-gray-700 text-xs sm:text-sm leading-relaxed font-light">
      <!-- Blok Teks 1 -->
      
      <div class="mb-4">
        <p>ANALISIS</p>
      </div>
      <div class="mb-4">
        <p>LOGIC CANDLE/POLA</p>
      </div>
      <div class="mb-4">
        <p>PERHATIKAN RESIKO HARIAN DAN BULANAN</p>
      </div>
      <div class="mb-4">
        <p>JURNALING</p>
      </div>
      <div class="mb-4">
        <p>EKSEKUSI</p>
      </div>
      <div class="mb-4">
        <p>HATI-HATI.</p>
      </div>
      <div class="mb-4">
        <p>___________________________</p>
      </div>
      <div class="mb-4">
        <p>Note : HATI-HATI, PELAN-PELAN, PERHATIKAN RESIKO DAN RASIONAL.</p>
      </div>
      <div class="mb-4">
        <p>Note : KONSISTENT, JALANIN AJA, TETAP ON TRACK.</p>
      </div>
      <div class="mb-4">
        <p>Note : SELALU MENCARI AREA ENTRY DAN SL YANG PALING AMAN BERDASARKAN SNR TERDEKAT SELALU BERFIKIR SKENARIO TERBURUK YANG AKAN TERJADI.</p>
      </div>
    </div>
  </div>
</div>

<!-- ▼▼▼ AWAL DARI BAGIAN AUTO SCROLL BARU ▼▼▼ -->
<section
  class="w-full bg-white py-4 border-b border-gray-200 shadow-sm"
  style="margin-top: 6rem"
>
  <!-- Judul yang Anda minta (text-2xl -> text-xl sm:text-2xl) -->
<h2 class="text-center text-xl sm:text-2xl font-light text-black mb-6">
    Character
  </h2>

  <!-- Wrapper untuk scroll -->
  <div class="w-full overflow-hidden">
    <!-- Kontainer yang akan bergerak (ditambahkan space-x-12) -->
    <div class="flex animate-scroll-left space-x-12">
      <!-- Daftar Karakter (Blok 1) (dihapus px-6) -->
      <div class="flex-shrink-0 flex items-center space-x-12">
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Disiplin</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Kontrol Emosi</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Manajemen Risiko</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Coumpounding ROI 3%/bulan</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Visi Strategis</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Tegas & Bertanggung Jawab</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Analitis & Kritis</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Sabar</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Ahli Negosiasi</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Membangun Jaringan (Networking)</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Loyalitas</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Berani Ambil Keputusan</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Coumpounding ROI 3%/bulan</span
        >
      </div>

      <!-- Daftar Karakter (Blok 2 - Duplikat untuk loop) (dihapus px-6) -->
      <div
        class="flex-shrink-0 flex items-center space-x-9"
        aria-hidden="true"
      >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Disiplin</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Kontrol Emosi</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Manajemen Risiko</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Visi Strategis</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Tegas & Bertanggung Jawab</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Analitis & Kritis</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Sabar</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Ahli Negosiasi</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Membangun Jaringan (Networking)</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Loyalitas</span
        >
        <span
          class="text-base sm:text-lg font-light text-black whitespace-nowrap"
          >Berani Ambil Keputusan</span
        >
      </div>
    </div>
  </div>
</section>
<!-- ▲▲▲ AKHIR DARI BAGIAN AUTO SCROLL BARU ▲▲▲ -->


      <!-- ▲▲▲ HINGGA DI SINI ▲▲▲ -->

<header
        class="header-section text-center mb-8 rounded-t-xl scroll-animate-section"
      >
        <h1 class="text-lg font-extralight text-primary mb-2">
          Risk & Reward Calculator
        </h1>
        <p class="text-gray-600 text-sm font-extralight">
          <span id="currentDate"></span>, <span id="currentTime"></span>
        </p>
      </header>

      <section id="calculatorInputs" class="mb-8 scroll-animate-section">
        <div id="inputRowsContainer" class="space-y-6">
          <!-- Input rows will be dynamically added here -->
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mt-6">
          <button id="addInputRowBtn" class="w-full sm:flex-1 action-button">
            Tambah Baris Input
          </button>
          <button id="calculateAllBtn" class="w-full sm:flex-1 action-button">
            Hitung Semua
          </button>
        </div>
      </section>

      <!-- Bagian Rencana Trading Baru -->
<section id="newTradingPlansSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Rencana Trading Baru
  </h2>
  <div class="overflow-x-auto rounded-lg border border-gray-200">
    <table class="results-table">
      <thead>
        <tr>
          <!-- ▼▼▼ TAMBAHKAN TH INI ▼▼▼ -->
          <th class="rounded-tl-lg text-center">No.</th>
          <th class="text-center">Aset</th>
          <!-- ▲▲▲ AKHIR TAMBAHAN ▲▲▲ -->
          <th>Trade</th>
          <th>Balance Akun</th>
          <th>Waktu Masuk</th>
          <th>Price Now</th>
          <th>Open Price</th>
          <th>SL Price</th>
          <th>TP Price</th>
          <th>Pending Pips/Points</th>
          <th>SL Pips/Points</th>
          <th>TP Pips/Points</th>
          <th>R:R Pips</th>
          <th>R:R %</th>
          <th>Lot/Units</th>
          <th>Nett SL</th>
          <th>Nett TP</th>
          <th>Catatan</th>
          <th class="text-center">Foto</th>
          <th>Hasil</th>
          <th class="rounded-tr-lg"></th>
        </tr>
      </thead>
      <tbody id="calculatedPlansBody">
        <tr>
          <!-- ▼▼▼ GANTI colspan="18" MENJADI colspan="19" ▼▼▼ -->
          <td colspan="19" class="py-4 text-center text-gray-500">
          <!-- ▲▲▲ AKHIR PERUBAHAN ▲▲▲ -->
            Belum ada rencana trading baru.
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</section>

<!-- Bagian Rencana Trading Aktif -->
<section id="runningTradingPlansSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Rencana Trading Aktif
  </h2>
  <div class="overflow-x-auto rounded-lg border border-gray-200">
    <table class="results-table">
      <thead>
        <tr>
          <!-- ▼▼▼ TAMBAHKAN TH INI ▼▼▼ -->
          <th class="rounded-tl-lg text-center">No.</th>
          <th class="text-center">Aset</th>
          <!-- ▲▲▲ AKHIR TAMBAHAN ▲▲▲ -->
          <th>Trade</th>
          <th>Balance Akun</th>
          <th>Waktu Masuk</th>
          <th>Price Now</th>
          <th>Open Price</th>
          <th>SL Price</th>
          <th>TP Price</th>
          <th>Pending Pips/Points</th>
          <th>SL Pips/Points</th>
          <th>TP Pips/Points</th>
          <th>R:R Pips</th>
          <th>R:R %</th>
          <th>Lot/Units</th>
          <th>Nett SL</th>
          <th>Nett TP</th>
          <th>Catatan</th>
          <th class="text-center">Lihat</th>
          <th>Hasil</th>
          <th class="rounded-tr-lg"></th>
        </tr>
      </thead>
      <tbody id="runningPlansBody">
        <tr>
          <!-- ▼▼▼ GANTI colspan="18" MENJADI colspan="19" ▼▼▼ -->
          <td colspan="19" class="py-4 text-center text-gray-500">
          <!-- ▲▲▲ AKHIR PERUBAHAN ▲▲▲ -->
            Belum ada rencana trading aktif.
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <!-- ... (div #activePlansSummary tetap sama) ... -->
</section>

<div id="activePlansSummary" class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-4 text-center hidden">
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL SL PIPS</p>
      <p id="summaryTotalSlPips" class="text-sm font-semibold mt-1 negative-value">0</p>
    </div>
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL TP PIPS</p>
      <p id="summaryTotalTpPips" class="text-sm font-semibold mt-1 positive-value">0</p>
    </div>
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL RISIKO (%)</p>
      <p id="summaryTotalRiskPercentage" class="text-sm font-semibold mt-1 negative-value">0.00%</p>
    </div>
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL NETT SL ($)</p>
      <p id="summaryTotalNettSL" class="text-sm font-semibold mt-1 negative-value">$0.00</p>
    </div>
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL NETT TP ($)</p>
      <p id="summaryTotalNettTP" class="text-sm font-semibold mt-1 positive-value">$0.00</p>
    </div>
    <div>
      <p class="text-gray-600 text-xs font-light">TOTAL LOT</p>
      <p id="summaryTotalLot" class="text-sm font-semibold mt-1 neutral-value">0.00</p>
    </div>
  </div>
<!-- ▼▼▼ GANTI SELURUH BLOK SECTION executedTradingPlansSection LAMA DENGAN INI ▼▼▼ -->
<!-- Bagian Rencana Trading Selesai -->
<section id="executedTradingPlansSection" class="mt-8 scroll-animate-section">
  
  

  <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 pb-2 border-b border-gray-200">

  <!-- Judul -->
  <h2 class="text-lg font-extralight text-primary mb-2 sm:mb-0">
    Rencana Trading Selesai
  </h2>

  <!-- Tombol Aksi Tabel Ini -->
  <div class="flex gap-2 items-center">
    <!-- Tombol Hapus Baru -->
    <button id="deleteExecutedOnlyBtn" class="upload-data-button text-xs bg-red-100 text-red-700 border-red-300 hover:bg-red-200">
      Hapus Data Tabel Ini
    </button>
    <!-- Tombol Unduh yang Sudah Ada -->
    <button id="downloadExecutedOnlyBtn" class="upload-data-button text-xs">
      Unduh Excel (Tabel Ini)
    </button>
  </div>
</div>
  <!-- AKHIR PERBAIKAN JUDUL DAN TOMBOL -->

  <!-- Kontainer Tabel (struktur ini tetap sama) -->
  <div id="executedPlansTableContainer">
    <div class="overflow-x-auto">
      <table class="results-table" id="executedPlansTable">
        <thead>
          <tr>
            <th class="rounded-tl-lg text-center">No.</th>
            <th class="text-center">Aset</th>
            <th>Trade</th>
            <th>Balance Akun</th>
            <th>Waktu Masuk</th>
            <th>Price Now</th>
            <th>Open Price</th>
            <th>SL Price</th>
            <th>TP Price</th>
            <th>Pending Pips/Points</th>
            <th>SL Pips/Points</th>
            <th>TP Pips/Points</th>
            <th>R:R Pips</th>
            <th>R:R %</th>
            <th>Lot/Units</th>
            <th>Nett SL</th>
<th>Nett TP</th>
<!-- Kolom Intervensi dulu -->
<th class="text-center bg-yellow-50 text-yellow-800">Result Intervensi ($)</th>
<th class="text-center bg-blue-50 text-blue-800">Result Tidak Intervensi ($)</th>
<th>Catatan</th>
<!-- Kolom Lihat dipindah ke sini (setelah Catatan) -->
<th class="text-center">Lihat</th>
            <th>Hasil</th>
            <th class="text-center">REVISI</th>
            <th class="rounded-tr-lg">Waktu Keluar</th>
          </tr>
        </thead>
        <tbody id="executedPlansBody">
          <tr>
            <td colspan="23" class="py-4 text-center text-gray-500">
              Belum ada rencana trading yang selesai.
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</section>

<div id="interventionSummaryContainer" class="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
      <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200 text-center">
          <h3 class="text-xs font-bold text-yellow-800 uppercase tracking-wider mb-1">Total Result Intervensi ( Nilai Dolar Saat Ini )</h3>
          <p id="totalInterventionValue" class="text-lg font-bold text-gray-700">$0.00</p>
          <p class="text-[10px] text-yellow-600 mt-1">(Total P/L dari trade yang diedit manual)</p>
      </div>
      <div class="bg-blue-50 p-4 rounded-lg border border-blue-200 text-center">
          <h3 class="text-xs font-bold text-blue-800 uppercase tracking-wider mb-1">Total Result Tidak Intervensi</h3>
          <p id="totalNonInterventionValue" class="text-lg font-bold text-gray-700">$0.00</p>
          <p class="text-[10px] text-blue-600 mt-1">(Total P/L murni strategi sesuai SL/TP awal)</p>
      </div>
  </div>

</section>

<!-- ▼▼▼ FITUR BARU: GHOST EQUITY CHART ▼▼▼ -->
<section id="ghostEquityStatisticsSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Ghost Equity: Intervensi vs Murni
  </h2>
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex flex-col items-center justify-center min-h-[300px]">
    <div class="w-full h-full relative" style="min-height: 300px;">
        <canvas id="ghostEquityChart"></canvas>
        <div id="ghostEquityChartLoading" class="hidden absolute inset-0 flex items-center justify-center bg-white/80 text-gray-500">
          Memuat data...
        </div>
        <div id="ghostEquityChartError" class="hidden absolute inset-0 flex items-center justify-center bg-white/80 error-message"></div>
        <div id="ghostEquityChartNoData" class="hidden absolute inset-0 flex items-center justify-center bg-white/80 text-gray-500">
          Belum ada data untuk perbandingan.
        </div>
    </div>
    <p class="text-xs text-gray-400 mt-2 text-center italic">
      "Garis <strong>Murni</strong> menunjukkan hasil jika Anda tidak pernah mengubah SL/TP awal.<br>
      Jika Garis <strong>Murni</strong> di atas <strong>Aktual</strong>, berarti intervensi Anda merugikan."
    </p>
  </div>
</section>

<!-- ▼▼▼ FITUR BARU: SQN SCORE ▼▼▼ -->
<section id="sqnStatisticsSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    System Quality Number (SQN) Score
  </h2>
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 md:grid-cols-3 gap-6 text-center items-center">
      
      <!-- Skor Utama -->
      <div class="md:col-span-1 border-r border-gray-100 pr-4">
          <p class="text-gray-500 text-xs font-light uppercase tracking-wider mb-1">Skor SQN Anda</p>
          <p id="sqnScoreValue" class="text-4xl font-bold text-gray-800">0.00</p>
          <p id="sqnScoreLabel" class="text-sm font-medium mt-2 px-3 py-1 rounded-full bg-gray-100 text-gray-500 inline-block">Tidak Ada Data</p>
      </div>

      <!-- Detail Metrik -->
      <div class="md:col-span-2 grid grid-cols-2 gap-4 text-left pl-4">
          <div>
              <p class="text-gray-400 text-[10px] uppercase">Rata-rata Profit ($)</p>
              <p id="sqnAvgProfit" class="text-sm font-mono font-semibold text-gray-700">$0.00</p>
          </div>
          <div>
              <p class="text-gray-400 text-[10px] uppercase">Standar Deviasi ($)</p>
              <p id="sqnStdDev" class="text-sm font-mono font-semibold text-gray-700">$0.00</p>
          </div>
          <div class="col-span-2 mt-2">
              <p class="text-[10px] text-gray-400 italic">
                  *SQN mengukur kemudahan sistem menghasilkan profit. Skor > 2.0 dianggap Bagus, > 3.0 Sangat Bagus.
              </p>
          </div>
      </div>
  </div>
</section>

<!-- ▼▼▼ FITUR BARU: B-BOOK PROFILER (BANDAR ANALYTICS) ▼▼▼ -->
<section id="bBookProfilerSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    The "B-Book" Profiler (Klasifikasi Mangsa vs. Predator)
  </h2>
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm text-center">
    <div class="flex justify-between items-end mb-2">
        <p class="text-xs text-gray-500 uppercase tracking-wider">Status Akun Anda Di Mata Bandar</p>
        <span class="text-[10px] text-gray-400 bg-gray-100 px-2 py-1 rounded">Algo v1.0</span>
    </div>
    
    <!-- Status Box -->
    <div id="bBookStatusContainer" class="p-6 rounded-lg bg-gray-50 border border-gray-200 mb-6 transition-all duration-500">
        <div class="mb-2">
            <span id="bBookIcon" class="text-4xl">📊</span>
        </div>
        <h3 id="bBookStatusTitle" class="text-2xl font-bold text-gray-400 tracking-tight">Data Belum Cukup</h3>
        <p id="bBookStatusDesc" class="text-sm text-gray-600 mt-2 font-light leading-relaxed">
            Sistem membutuhkan minimal 5 data trade yang selesai untuk mulai memprofilkan psikologi dan probabilitas kebangkrutan Anda.
        </p>
    </div>
    
    <!-- Detail Metrics -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-left">
        <div class="p-3 bg-gray-50 rounded border border-gray-100">
            <span class="block text-gray-400 mb-1 uppercase tracking-wide font-semibold text-[10px]">Skor Martingale</span>
            <span id="bBookMartingaleScore" class="font-mono text-lg font-bold text-gray-700">0%</span>
            <p class="text-[9px] text-gray-400 mt-1">Frekuensi lot naik setelah loss.</p>
        </div>
        <div class="p-3 bg-gray-50 rounded border border-gray-100">
            <span class="block text-gray-400 mb-1 uppercase tracking-wide font-semibold text-[10px]">Korelasi Lot vs Winrate</span>
            <span id="bBookCorrelation" class="font-mono text-lg font-bold text-gray-700">N/A</span>
            <p class="text-[9px] text-gray-400 mt-1">Positif = Sehat, Negatif = Bahaya.</p>
        </div>
        <div class="p-3 bg-gray-50 rounded border border-gray-100">
            <span class="block text-gray-400 mb-1 uppercase tracking-wide font-semibold text-[10px]">Probabilitas MC (3 Bln)</span>
            <span id="bBookMcProbability" class="font-mono text-lg font-bold text-gray-700">N/A</span>
            <p class="text-[9px] text-gray-400 mt-1">Estimasi risiko kebangkrutan.</p>
        </div>
    </div>
    
    <div class="mt-4 pt-3 border-t border-gray-100 text-left">
        <p class="text-[10px] text-gray-400 italic">
          <strong class="text-gray-500">Logika Bandar:</strong> Jika Anda terdeteksi <strong>B-Book</strong>, broker akan menahan order Anda karena statistik menunjukkan Anda akan rugi sendiri (Profit mereka). Jika <strong>A-Book</strong>, order dilempar ke pasar karena Anda ancaman.
        </p>
    </div>
  </div>
</section>
<!-- ▲▲▲ AKHIR FITUR BARU ▲▲▲ -->

<!-- ▼▼▼ FITUR BARU: KUIS LOGIKA HARIAN & PSIKOLOGI ▼▼▼ -->
<section id="dailyLogicQuizSection" class="mt-8 scroll-animate-section">
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Latihan Logika & Psikologi Harian
  </h2>
  
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm">
    <!-- Header: Skor & Pesan -->
    <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
      <div class="text-center md:text-left">
        <p class="text-xs text-gray-500 uppercase tracking-wider">Skor Konsistensi</p>
        <div class="flex items-center justify-center md:justify-start gap-2">
           <span id="consistencyScoreDisplay" class="text-3xl font-bold text-blue-600">0</span>
           <span class="text-sm text-gray-400">Hari</span>
        </div>
      </div>
      <div class="flex-grow text-center px-4">
        <div id="dailyQuoteContainer" class="bg-blue-50 p-3 rounded-lg border border-blue-100 text-sm text-blue-800 italic font-medium">
          "Memuat pesan harian..."
        </div>
      </div>
      <div class="text-center md:text-right">
        <p class="text-xs text-gray-500 uppercase tracking-wider">Status Hari Ini</p>
        <span id="dailyQuizStatus" class="inline-block mt-1 px-3 py-1 rounded-full text-xs font-bold bg-gray-100 text-gray-500">
          Belum Dikerjakan
        </span>
      </div>
    </div>

    <!-- Area Kuis (Sembunyi jika belum mulai) -->
    <div id="dailyQuizContainer" class="hidden border-t border-gray-100 pt-6">
      <h3 class="text-center font-semibold text-gray-700 mb-4">Kuis Logika Harian (20 Soal)</h3>
      <div id="dailyQuizQuestions" class="space-y-4 max-h-[400px] overflow-y-auto pr-2">
        <!-- Soal akan di-render di sini -->
      </div>
      <div class="mt-6 text-center">
        <button id="submitDailyQuizBtn" class="action-button w-full md:w-auto">Kirim Jawaban</button>
      </div>
    </div>

    <!-- Tombol Mulai (Jika belum) -->
    <div id="startDailyQuizContainer" class="text-center mt-4">
      <button id="startDailyQuizBtn" class="action-button bg-blue-600 hover:bg-blue-700 w-full md:w-1/3">
        Mulai Latihan Otak
      </button>
    </div>
  </div>
</section>

<!-- MODAL KHUSUS: LOCKOUT QUIZ (Pop Up Hukuman Disiplin) -->
<div id="lockoutQuizModal" class="modal" style="z-index: 9999;"> <!-- Z-index sangat tinggi -->
  <div class="modal-content w-full max-w-4xl h-[90vh] flex flex-col bg-red-50 border-2 border-red-200">
    <div class="text-center mb-4 border-b border-red-200 pb-2">
      <h3 class="text-xl font-bold text-red-700 uppercase">⚠️ Peringatan Risiko Tercapai</h3>
      <p class="text-sm text-red-600 mt-1">Anda mencapai batas risiko. Untuk menutup ini, selesaikan pendinginan psikologis di bawah.</p>
    </div>
    
    <div class="flex-grow overflow-y-auto p-4 space-y-6" id="lockoutQuizBody">
      <!-- 10 Soal Logika -->
      <div class="bg-white p-4 rounded shadow-sm">
        <h4 class="font-bold text-gray-700 mb-3 border-b pb-1">BAGIAN 1: Tes Logika (Fokus Kembali)</h4>
        <div id="lockoutLogicQuestions" class="space-y-4"></div>
      </div>

      <!-- 10 Soal Introspeksi -->
      <div class="bg-white p-4 rounded shadow-sm">
        <h4 class="font-bold text-gray-700 mb-3 border-b pb-1">BAGIAN 2: Introspeksi Diri (Jujurlah)</h4>
        <div id="lockoutIntrospectionQuestions" class="space-y-4"></div>
      </div>
    </div>

    <div class="mt-4 pt-3 border-t border-red-200 text-center">
      <div id="lockoutScoreResult" class="hidden mb-2 font-bold text-lg"></div>
      <button id="submitLockoutQuizBtn" class="action-button bg-red-600 hover:bg-red-700 text-white w-full py-3 text-lg">
        Saya Sudah Tenang & Mengerti
      </button>
      <button id="closeLockoutModalBtn" class="hidden mt-2 text-sm text-gray-500 hover:text-gray-700 underline">
        Tutup & Kembali
      </button>
    </div>
  </div>
</div>
<!-- ▲▲▲ AKHIR FITUR BARU ▲▲▲ -->
<!-- ▲▲▲ AKHIR FITUR BARU ▲▲▲ -->

<!-- ▼▼▼ TAMBAHKAN SELURUH BLOK SECTION BARU INI ▼▼▼ -->
<section id="dailyRiskSection" class="mt-8 scroll-animate-section">
  <!-- Judul Bagian -->
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Resiko Harian
  </h2>

  <!-- Kontainer Grid untuk Statistik -->
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center">

    <div>
      <p class="text-gray-600 text-sm font-light">presentase belum terjadi</p>
      <p id="dailyRiskPercentageNow" class="text-base font-semibold mt-1 positive-value">0.00%</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>
    
    <div>
      <p class="text-gray-600 text-sm font-light">presentase yang akan terjadi</p>
      <!-- ID baru untuk nilai Presentase -->
      <p id="dailyRiskPercentage" class="text-base font-semibold mt-1 negative-value">0.00%</p>
      <!-- ID baru untuk Sisa Presentase -->
      <p id="dailyRiskPercentageRemaining" class="text-xs text-gray-500 mt-1">Sisa: 3.50%</p>
    </div>

    <div>
      <p class="text-gray-600 text-sm font-light">pips sebelum terjadi</p>
      <p id="dailyRiskPipsNow" class="text-base font-semibold mt-1 positive-value">0</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>

    <!-- Metrik 2: Pips Harian -->
    <div>
      <p class="text-gray-600 text-sm font-light">pips yang akan terjadi</p>
      <!-- ID baru untuk nilai Pips -->
      <p id="dailyRiskPips" class="text-base font-semibold mt-1 negative-value">0</p>
      <!-- ID baru untuk Sisa Pips -->
      <p id="dailyRiskPipsRemaining" class="text-xs text-gray-500 mt-1">Sisa: 5.000</p>
    </div>

    <!-- Metrik 3: Dolar Harian -->
    <div>
      <p class="text-gray-600 text-sm font-light">Dolar Harian (Nett SL)</p>
      <!-- ID baru untuk nilai Dolar -->
      <p id="dailyRiskDolar" class="text-base font-semibold mt-1 negative-value">$0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

    <!-- Metrik 4: Lot Harian -->
    <div>
      <p class="text-gray-600 text-sm font-light">Lot Total Harian</p>
      <!-- ID baru untuk nilai Lot -->
      <p id="dailyRiskLot" class="text-base font-semibold mt-1 positive-value">0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

  </div>
  <div class="mt-4 text-xs text-gray-500 font-light">
      <p>
        <strong>Note:</strong> Batas maksimal risiko (SL) presentase harian adalah 3.5%.
      </p>
      <p>
        <strong>Note:</strong> Batas maksimal risiko (SL) pips harian adalah 5000 pips.
      </p>
    </div>
</section>

<!-- ▼▼▼ TAMBAHKAN SELURUH BLOK SECTION BARU INI (RESIKO BULANAN) ▼▼▼ -->
<section id="monthlyRiskSection" class="mt-8 scroll-animate-section">
  <!-- Judul Bagian -->
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Resiko Bulanan
  </h2>

  <!-- Kontainer Grid untuk Statistik -->
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center">
    <div>
      <p class="text-gray-600 text-sm font-light">presentase belum terjadi</p>
      <p id="monthlyRiskPercentageNow" class="text-base font-semibold mt-1 positive-value">0.00%</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>
    
    <!-- Metrik 1: Presentase Bulanan -->
    <div>
      <p class="text-gray-600 text-sm font-light">presentase yang akan terjadi</p>
      <!-- ID baru untuk nilai Presentase -->
      <p id="monthlyRiskPercentage" class="text-base font-semibold mt-1 negative-value">0.00%</p>
      <!-- ID baru untuk Sisa Presentase -->
      <p id="monthlyRiskPercentageRemaining" class="text-xs text-gray-500 mt-1">Sisa: 6.00%</p>
    </div>

    <div>
      <p class="text-gray-600 text-sm font-light">pips sebelum terjadi</p>
      <p id="monthlyRiskPipsNow" class="text-base font-semibold mt-1 positive-value">0</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>

    <!-- Metrik 2: Pips Bulanan -->
    <div>
      <p class="text-gray-600 text-sm font-light">pips yang akan terjadi</p>
      <!-- ID baru untuk nilai Pips -->
      <p id="monthlyRiskPips" class="text-base font-semibold mt-1 negative-value">0</p>
      <!-- ID baru untuk Sisa Pips -->
      <p id="monthlyRiskPipsRemaining" class="text-xs text-gray-500 mt-1">Sisa: 1,200</p>
    </div>

    <!-- Metrik 3: Dolar Bulanan -->
    <div>
      <p class="text-gray-600 text-sm font-light">Dolar Bulanan (Nett SL)</p>
      <!-- ID baru untuk nilai Dolar -->
      <p id="monthlyRiskDolar" class="text-base font-semibold mt-1 negative-value">$0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

    <!-- Metrik 4: Lot Bulanan -->
    <div>
      <p class="text-gray-600 text-sm font-light">Lot Total Bulanan</p>
      <!-- ID baru untuk nilai Lot -->
      <p id="monthlyRiskLot" class="text-base font-semibold mt-1 positive-value">0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

  </div>
  <!-- Note Baru untuk Resiko Bulanan -->
  <div class="mt-4 text-xs text-gray-500 font-light">
    <p>
      <strong>Note:</strong> Batas maksimal risiko (SL) presentase bulanan adalah 5%.
    </p>
    <p>
      <strong>Note:</strong> Batas maksimal risiko (SL) pips bulanan adalah 8.000 pips.
    </p>
  </div>
</section>
<!-- ▲▲▲ AKHIR DARI BLOK SECTION BARU ▲▲▲ -->
<!-- ▼▼▼ TAMBAHKAN SELURUH BLOK SECTION BARU INI (MAKSIMAL DRAWDOWN) ▼▼▼ -->
<section id="maxDrawdownRiskSection" class="mt-8 scroll-animate-section">
  <!-- Judul Bagian -->
  <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
    Resiko Maksimal Drawdown
  </h2>

  <!-- Kontainer Grid untuk Statistik (ID BARU) -->
  <div class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center">
    
    <!-- Presentase Selesai -->
    <div>
      <p class="text-gray-600 text-sm font-light">presentase belum terjadi</p>
      <p id="maxDrawdownRiskPercentageNow" class="text-base font-semibold mt-1 positive-value">0.00%</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>
    
    <!-- Presentase Akumulasi -->
    <div>
      <p class="text-gray-600 text-sm font-light">presentase yang akan terjadi</p>
      <p id="maxDrawdownRiskPercentage" class="text-base font-semibold mt-1 negative-value">0.00%</p>
      <!-- PERBAIKAN: Ubah Sisa menjadi 7.00% -->
      <p id="maxDrawdownRiskPercentageRemaining" class="text-xs text-gray-500 mt-1">Sisa: 7.00%</p>
    </div>

    <!-- Pips Selesai -->
    <div>
      <p class="text-gray-600 text-sm font-light">pips belum terjadi</p>
      <p id="maxDrawdownRiskPipsNow" class="text-base font-semibold mt-1 positive-value">0</p>
      <p class="text-xs text-gray-500 mt-1">Selesai</p>
    </div>

    <!-- Pips Akumulasi -->
    <div>
      <p class="text-gray-600 text-sm font-light">pips yang akan terjadi</p>
      <p id="maxDrawdownRiskPips" class="text-base font-semibold mt-1 negative-value">0</p>
      <p id="maxDrawdownRiskPipsRemaining" class="text-xs text-gray-500 mt-1">Sisa: 1,500</p>
    </div>

    <!-- Dolar Akumulasi -->
    <div>
      <p class="text-gray-600 text-sm font-light">Dolar Bulanan (Nett SL)</p>
      <p id="maxDrawdownRiskDolar" class="text-base font-semibold mt-1 negative-value">$0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

    <!-- Lot Akumulasi -->
    <div>
      <p class="text-gray-600 text-sm font-light">Lot Total Bulanan</p>
      <p id="maxDrawdownRiskLot" class="text-base font-semibold mt-1 positive-value">0.00</p>
      <p class="text-xs text-gray-500 mt-1"></p>
    </div>

  </div>
  <!-- Note Baru untuk Resiko Maksimal Drawdown -->
  <div class="mt-4 text-xs text-gray-500 font-light">
    <p>
      <!-- PERBAIKAN: Ubah Note menjadi 7% -->
      <strong>Note:</strong> Batas maksimal risiko (SL) presentase bulanan adalah 7%.
    </p>
    <p>
      <strong>Note:</strong> Batas maksimal risiko (SL) pips bulanan adalah 10.000 pips.
    </p>
  </div>
</section>
  

</section>


<!-- ▲▲▲ AKHIR DARI BLOK PENGGANTIAN ▲▲▲ -->
      <!-- NEW: Compounding Simulator Section -->
      <section
        id="compoundingSimulatorSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Simulator Compounding
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 md:grid-cols-4 gap-6"
        >
          <div>
            <label for="simBalance" class="block text-sm input-label mb-1"
              >Balance Awal ($)</label
            >
            <input
              type="number"
              id="simBalance"
              placeholder="Cth: 5000"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simRiskPerTrade" class="block text-sm input-label mb-1"
              >Risk per Trade (%)</label
            >
            <input
              type="number"
              id="simRiskPerTrade"
              placeholder="Cth: 0.5"
              step="0.01"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simMonthlyTarget" class="block text-sm input-label mb-1"
              >Target Bulanan (%)</label
            >
            <input
              type="number"
              id="simMonthlyTarget"
              placeholder="Cth: 5"
              step="0.1"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simPeriod" class="block text-sm input-label mb-1"
              >Periode Simulasi (Bulan)</label
            >
            <input
              type="number"
              id="simPeriod"
              placeholder="Cth: 12"
              class="mt-1 block w-full input-field"
            />
          </div>
        </div>
      </section>

      <!-- New section for Overall Summary Statistics -->
      <section
        id="overallSummaryStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Ringkasan Keseluruhan
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center"
        >
          <!-- Baris 1 -->
          <div>
            <p class="text-gray-600 text-sm font-light">Total Trade Selesai</p>
            <p id="totalSettledTradesSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Probabilitas</p>
            <p
              id="probabilitySummary"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Total Pips/Points</p>
            <p id="totalPipsSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata % per Trade
            </p>
            <p id="avgPercentagePerTradeSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Harian</p>
            <p id="dailyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Bulanan</p>
            <p id="monthlyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <!-- Baris 2 -->
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Tahunan</p>
            <p id="yearlyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Persentase Keseluruhan
            </p>
            <p id="overallPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Saldo Akun Akhir</p>
            <p id="finalBalanceSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Waktu Bergabung</p>
            <p
              id="joinTimeSummary"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Drawdown Saldo</p>
            <p id="balanceDrawdownSummary" class="text-base mt-1">N/A</p>
            <p
              id="balanceDrawdownSummaryPeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Maksimum Drawdown %</p>
            <p id="overallMaxDrawdownPercentage" class="text-base mt-1">N/A</p>
            <p
              id="overallMaxDrawdownPercentagePeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
        </div>
      </section>

      <!-- New section for Risk and Reward Statistics -->
      <section
        id="riskRewardStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Risiko dan Imbalan
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 text-center"
        >
          <div
            class="sm:col-span-2 md:col-span-4 flex flex-col sm:flex-row justify-center items-center p-2 rounded-md bg-gray-100"
          >
            <p class="text-gray-600 text-sm font-light mr-2">
              Rata-rata Risiko dan Imbalan
            </p>
            <p id="avgRiskReward" class="text-lg font-light text-black">
              1 : N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Sinyal Diselesaikan/Minggu
            </p>
            <p
              id="avgSignalSettledWeek"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Sinyal Diselesaikan/Bulan
            </p>
            <p
              id="avgSignalSettledMonth"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Periode Penahanan
            </p>
            <p
              id="avgHoldingPeriod"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Periode Penahanan Maks
            </p>
            <p
              id="maxHoldingPeriod"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata Pips</p>
            <p id="averagePips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata TP Pips</p>
            <p id="avgTpPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Max TP Pips</p>
            <p id="maxTpPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata SL Pips</p>
            <p id="avgSlPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Max SL Pips</p>
            <p id="maxSlPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Keuntungan Beruntun</p>
            <p
              id="consecutiveProfit"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="consecutiveProfitPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Kerugian Beruntun</p>
            <p
              id="consecutiveLoss"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="consecutiveLossPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Laba Kotor (Total TP)
            </p>
            <p id="grossProfit" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Laba Kotor (Total SL)
            </p>
            <p id="grossLoss" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Laba Bersih</p>
            <p id="netProfit" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Balance Drawdown Maximal
            </p>
            <p
              id="maxBalanceDrawdown"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="maxBalanceDrawdownPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Balance Drawdown Monthly
            </p>
            <p
              id="monthlyBalanceDrawdown"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p
              id="monthlyBalanceDrawdownPeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Maksimum Drawdown Bulanan %
            </p>
            <p
              id="monthlyMaxDrawdownPercentage"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p
              id="monthlyMaxDrawdownPercentagePeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
        </div>
      </section>

      <!-- INI KODE BARU UNTUK SELURUH BAGIAN RINGKASAN P/L BULANAN -->
      <section id="monthlyPLSummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan P/L Bulanan
        </h2>
        <!-- Wrapper baru untuk scroll vertikal -->
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Bulan</th>
                <th>Presentase Akumulasi</th>
                <th>Total Eksekusi</th>
                <th>TP / SL</th>
                <!-- Header baru ditambahkan di sini -->
                <th>Total Eksekusi Bersih</th>
                <th>TP Bersih ($)</th>
                <th>Akumulasi Nett ($)</th>
                <th class="rounded-tr-lg">Total Saldo ($)</th>
              </tr>
            </thead>
            <tbody id="monthlyPLSummaryBody">
              <!-- Data akan diisi oleh JavaScript -->
              <tr>
                <td colspan="8" class="py-4 text-center text-gray-500">
                  Menghitung data...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- Tombol unduh baru ditambahkan di sini -->
        <div class="flex justify-end mt-4">
          <button id="downloadMonthlyPLSummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <!-- PERBAIKAN: Bagian Ringkasan Harian, Mingguan, Bulanan, dan Tahunan -->

      <section id="newDailySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Harian Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Tanggal</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newDailySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewDailySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newWeeklySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Mingguan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Minggu</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newWeeklySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewWeeklySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newMonthlySummarySection" class="mt-8">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Bulanan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Bulan</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newMonthlySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewMonthlySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newYearlySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Tahunan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Tahun</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newYearlySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewYearlySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <!-- ▼▼▼ GANTI SELURUH BLOK SECTION calendarSection LAMA DENGAN INI ▼▼▼ -->
      <section id="calendarSection" class="mt-8 scroll-animate-section">
        <!-- Judul Bagian -->
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Kalender & Performa Bulanan
        </h2>

        <!-- Kontainer Utama dengan Grid Responsif -->
        <!-- Default: 1 kolom (grafik di atas kalender) -->
        <!-- Medium screen (md) ke atas: 2 kolom (grafik kiri, kalender kanan) -->
        <div
          class="calendar-container-grid grid grid-cols-1 md:grid-cols-2 gap-6 bg-white p-4 rounded-lg border border-gray-200 shadow-sm"
        >
          <!-- Item Grid 1: Grafik Persentase Bulanan -->
          <div
            id="monthlyPercentageChartContainer"
            class="w-full min-h-[300px] flex flex-col"
          >
            <h3
              id="monthlyChartTitle"
              class="text-sm font-semibold text-gray-700 mb-2 text-center"
            >
              Pertumbuhan Persentase Bulanan (%)
            </h3>
            <!-- Kontainer relatif untuk chart dan pesan loading/error -->
            <div
              class="relative flex-grow flex items-center justify-center p-2 border border-gray-100 rounded-md"
            >
              <!-- Kanvas untuk grafik -->
              <canvas id="monthlyPercentageLineChart"></canvas>
              <!-- Pesan Loading -->
              <div
                id="monthlyPercentageLineChartLoading"
                class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 text-center text-gray-500 hidden"
              >
                Memuat data grafik bulanan...
              </div>
              <!-- Pesan Error -->
              <div
                id="monthlyPercentageLineChartError"
                class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 error-message text-center hidden"
              ></div>
              <!-- Pesan Tidak Ada Data -->
              <div
                id="monthlyPercentageLineChartNoData"
                class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 text-center text-gray-500 hidden"
              >
                Belum ada data eksekusi untuk bulan ini.
              </div>
            </div>
          </div>

          <!-- Item Grid 2: Kalender Grid -->
          <div class="calendar-grid-container w-full">
            <!-- Header Kalender (Tombol Navigasi & Nama Bulan) -->
            <div class="calendar-header flex justify-between items-center mb-4">
              <button
                id="prevMonthBtn"
                class="calendar-nav-btn p-2 rounded-full hover:bg-gray-100 transition-colors"
                aria-label="Bulan Sebelumnya" 
              >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
              </button>
              <h3
                id="monthYearDisplay"
                class="text-base font-semibold text-gray-700"
                aria-live="polite" <!-- Aksesibilitas: umumkan perubahan bulan/tahun -->
              >
                <!-- Nama Bulan dan Tahun akan diisi oleh JavaScript -->
              </h3>
              <button
                id="nextMonthBtn"
                class="calendar-nav-btn p-2 rounded-full hover:bg-gray-100 transition-colors"
                aria-label="Bulan Berikutnya" 
              >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
              </button>
            </div>
            <!-- Nama Hari -->
            <div class="calendar-grid grid grid-cols-7 gap-1 text-center mb-2">
              <div class="calendar-day-name text-xs font-bold text-red-500">Min</div>
              <div class="calendar-day-name text-xs font-bold text-gray-400">Sen</div>
              <div class="calendar-day-name text-xs font-bold text-gray-400">Sel</div>
              <div class="calendar-day-name text-xs font-bold text-gray-400">Rab</div>
              <div class="calendar-day-name text-xs font-bold text-gray-400">Kam</div>
              <div class="calendar-day-name text-xs font-bold text-gray-400">Jum</div>
              <div class="calendar-day-name text-xs font-bold text-red-500">Sab</div>
            </div>
            <!-- Body Kalender (Tanggal) -->
            <div
              id="calendarBody"
              class="calendar-grid grid grid-cols-7 gap-1 mt-1 text-center"
            >
              <!-- Tanggal akan diisi oleh JavaScript -->
            </div>
          </div>
        </div>
      </section>
      <!-- ▲▲▲ AKHIR DARI BLOK SECTION calendarSection ▲▲▲ -->

      <!-- ▼▼▼ LETAKKAN SELURUH BLOK KODE BARU DI BAWAH INI ▼▼▼ -->
      <section
        id="outcomeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          id="outcomeChartTitle"
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Hasil Eksekusi (Total: 0)
        </h2>
        <div
          id="outcomeRadarChartContainer"
          class="bg-white p-6 rounded-lg flex items-center justify-center min-h-[300px]"
        >
          <canvas id="outcomeRadarChart"></canvas>
          <div id="outcomeRadarChartLoading" class="hidden text-gray-500">
            Memuat data hasil eksekusi...
          </div>
          <div id="outcomeRadarChartError" class="hidden error-message"></div>
          <div id="outcomeRadarChartNoData" class="hidden text-gray-500">
            Belum ada data hasil eksekusi.
          </div>
        </div>
      </section>

      <section
        id="assetSuccessStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Keberhasilan Aset
        </h2>
        <div
          id="pieChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center"
        >
          <canvas id="assetSuccessPieChart"></canvas>
          <div id="pieChartLoading" class="hidden text-gray-500">
            Memuat data keberhasilan aset...
          </div>
          <div id="pieChartError" class="hidden error-message"></div>
          <div id="pieChartNoData" class="hidden text-gray-500">
            Tidak ada data keberhasilan aset yang tersedia.
          </div>
        </div>
      </section>

      <section
        id="dailyLineStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Persentase Harian
          <span
            id="dailyChartDateTime"
            class="text-gray-600 text-sm font-light"
          ></span>
        </h2>
        <div
          id="dailyLineChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="dailyLineChart"></canvas>
          <div id="dailyLineChartLoading" class="hidden text-gray-500">
            Memuat data statistik...
          </div>
          <div id="dailyLineChartError" class="hidden error-message"></div>
          <div id="dailyLineChartNoData" class="hidden text-gray-500">
            Tidak ada data statistik harian.
          </div>
        </div>
      </section>

      <section
        id="monthlyBarStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Persentase Bulanan (Diagram Batang)
        </h2>
        <div
          id="monthlyBarChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="monthlyBarChart"></canvas>
          <div id="monthlyBarChartLoading" class="hidden text-gray-500">
            Memuat data statistik...
          </div>
          <div id="monthlyBarChartError" class="hidden error-message"></div>
          <div id="monthlyBarChartNoData" class="hidden text-gray-500">
            Tidak ada data statistik bulanan.
          </div>
        </div>
      </section>

      <section
        id="overallPercentageCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Persentase Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Percentage" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Percentage"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              0.00%
            </p>
          </div>
        </div>
        <div
          id="overallPercentageCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallPercentageCumulativeChart"></canvas>
          <div
            id="overallPercentageCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallPercentageCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallPercentageCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p
            id="assetList_Percentage"
            class="text-xs text-gray-500 leading-tight"
          >
            N/A
          </p>
        </div>
        <!-- ▼▼▼ LETAKKAN KODE BARU DI SINI ▼▼▼ -->
        <div class="flex justify-end mt-2">
          <button
            id="showPercentageDetailsBtn"
            class="text-xs text-blue-600 hover:underline font-light focus:outline-none"
          >
            Data Selengkapnya
          </button>
        </div>
        <!-- ▲▲▲ AKHIR DARI BLOK KODE BARU ▲▲▲ -->
      </section>

      <section
        id="overallBalanceCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Saldo Akun Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Balance" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Balance"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              $0.00
            </p>
          </div>
        </div>
        <div
          id="overallBalanceCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallBalanceCumulativeChart"></canvas>
          <div
            id="overallBalanceCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallBalanceCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallBalanceCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik saldo kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p id="assetList_Balance" class="text-xs text-gray-500 leading-tight">
            N/A
          </p>
        </div>
      </section>

      <section
        id="overallPipsCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Pips/Points Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Pips" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Pips"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              0
            </p>
          </div>
        </div>
        <div
          id="overallPipsCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallPipsCumulativeChart"></canvas>
          <div
            id="overallPipsCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallPipsCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallPipsCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik pips/points kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p id="assetList_Pips" class="text-xs text-gray-500 leading-tight">
            N/A
          </p>
        </div>
      </section>

      <!-- ▼▼▼ LETAKKAN SELURUH BLOK KODE BARU DI BAWAH INI ▼▼▼ -->
      <section
        id="combinedCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Gabungan Kumulatif
        </h2>
        <div
          id="combinedCumulativeChartContainer"
          class="bg-white p-6 rounded-lg flex items-center justify-center min-h-[300px]"
        >
          <canvas id="combinedCumulativeChart"></canvas>
          <div id="combinedCumulativeChartLoading" class="hidden text-gray-500">
            Memuat data gabungan...
          </div>
          <div
            id="combinedCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div id="combinedCumulativeChartNoData" class="hidden text-gray-500">
            Belum ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Combined Summary Bar Chart Section -->
      <section
        id="combinedSummaryBarStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Akumulasi Gabungan (Diagram Batang)
        </h2>
        <div
          id="combinedSummaryBarChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="combinedSummaryBarChart"></canvas>
          <div id="combinedSummaryBarChartLoading" class="hidden text-gray-500">
            Memuat data ringkasan...
          </div>
          <div
            id="combinedSummaryBarChartError"
            class="hidden error-message"
          ></div>
          <div id="combinedSummaryBarChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Balance Frequency Chart Section -->
      <section
        id="balanceFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Balance per Aset
        </h2>
        <div
          id="balanceFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="balanceFrequencyChart"></canvas>
          <div id="balanceFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi balance...
          </div>
          <div
            id="balanceFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="balanceFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Percentage Frequency Chart Section -->
      <section
        id="percentageFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Persentase per Aset
        </h2>
        <div
          id="percentageFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="percentageFrequencyChart"></canvas>
          <div
            id="percentageFrequencyChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data frekuensi persentase...
          </div>
          <div
            id="percentageFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="percentageFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Pips Frequency Chart Section -->
      <section
        id="pipsFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Pips/Points per Aset
        </h2>
        <div
          id="pipsFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="pipsFrequencyChart"></canvas>
          <div id="pipsFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi pips...
          </div>
          <div id="pipsFrequencyChartError" class="hidden error-message"></div>
          <div id="pipsFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Execution Frequency Chart Section -->
      <section
        id="executionFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Eksekusi per Aset (BUY vs SELL)
        </h2>
        <div
          id="executionFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="executionFrequencyChart"></canvas>
          <div id="executionFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi eksekusi...
          </div>
          <div
            id="executionFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="executionFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Asset Execution Count Chart Section -->
      <section
        id="assetExecutionCountStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Aset Selesai Dieksekusi
        </h2>
        <div
          id="assetExecutionCountChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="assetExecutionCountChart"></canvas>
          <div
            id="assetExecutionCountChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data frekuensi aset...
          </div>
          <div
            id="assetExecutionCountChartError"
            class="hidden error-message"
          ></div>
          <div id="assetExecutionCountChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- New section for Trade Frequency Chart -->
      <section
        id="tradeFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Eksekusi Trade per Aset
        </h2>
        <div
          id="tradeFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="tradeFrequencyChart"></canvas>
          <div id="tradeFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi trade...
          </div>
          <div id="tradeFrequencyChartError" class="hidden error-message"></div>
          <div id="tradeFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data frekuensi trade.
          </div>
        </div>
      </section>

      <!-- NEW GUIDE SECTION -->
      <section class="info-section mt-8 scroll-animate-section">
        <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
          Panduan Lengkap: Menggunakan Kalkulator Risk & Reward
        </h2>
        <p>
          Selamat datang di Kalkulator Risk & Reward! Alat ini dirancang untuk
          menjadi asisten pribadi Anda dalam merencanakan, menghitung, dan
          menganalisis setiap perdagangan. Dengan memahami potensi risiko dan
          imbalan sebelum masuk pasar, Anda dapat membuat keputusan yang lebih
          cerdas dan disiplin.
        </p>

        <h3>Langkah-langkah Penggunaan</h3>
        <ol class="list-decimal list-inside space-y-4">
          <li>
            <strong>Membuat Rencana (Input Data)</strong>
            <p class="mt-2">
              Klik tombol <strong>"Tambah Baris Input"</strong> untuk memulai.
              Sebuah formulir akan muncul. Isi setiap kolom dengan cermat:
            </p>
            <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
              <li>
                <strong>Aset:</strong> Pilih instrumen yang akan Anda
                perdagangkan dari daftar.
              </li>
              <li>
                <strong>Tipe Trade:</strong> Tentukan posisi Anda dengan memilih
                <strong>BUY</strong> atau <strong>SELL</strong>.
              </li>
              <li>
                <strong>Balance Akun ($):</strong> Masukkan total saldo akun
                trading Anda saat ini.
              </li>
              <li>
                <strong>Risiko (%):</strong> Tentukan berapa persen dari saldo
                akun yang Anda relakan sebagai risiko untuk trade ini (misal:
                0.5% atau 1%).
              </li>
              <li>
                <strong>Price Now:</strong> Harga pasar saat ini. Kolom ini
                digunakan untuk menghitung 'Pending Pips' dan tidak memengaruhi
                kalkulasi inti.
              </li>
              <li>
                <strong>Open Price:</strong> Harga di mana Anda berencana untuk
                membuka posisi.
              </li>
              <li>
                <strong>SL Price (Stop Loss):</strong> Harga di mana posisi akan
                ditutup otomatis untuk membatasi kerugian.
              </li>
              <li>
                <strong>TP Price (Take Profit):</strong> Harga di mana posisi
                akan ditutup otomatis untuk mengamankan keuntungan.
              </li>
              <li>
                <strong>Catatan (Opsional):</strong> Tulis catatan singkat
                mengenai strategi atau alasan Anda membuka posisi ini.
              </li>
            </ul>
          </li>
          <li>
            <strong>Menghitung & Memindahkan Rencana</strong>
            <p class="mt-2">
              Setelah semua data terisi, klik <strong>"Hitung Semua"</strong>.
              Hasil perhitungan akan muncul di tabel
              <strong>"Rencana Trading Baru"</strong>. Dari sini, alur kerjanya
              adalah:
            </p>
            <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
              <li>
                <strong>Set Running:</strong> Jika Anda memutuskan untuk
                melanjutkan rencana ini (sebagai pending atau market order),
                klik tombol ini. Rencana akan pindah ke tabel
                <strong>"Rencana Trading Aktif"</strong>.
              </li>
              <li>
                <strong>Menyelesaikan Trade:</strong> Di tabel "Rencana Trading
                Aktif", setelah posisi Anda ditutup, klik
                <strong>"TAKE PROFIT"</strong> atau
                <strong>"STOP LOSS"</strong> sesuai hasil akhirnya. Rencana akan
                pindah ke tabel <strong>"Rencana Trading Selesai"</strong> dan
                semua data statistik akan diperbarui secara otomatis.
              </li>
              <li>
                <strong>Opsi Lain:</strong> Gunakan tombol
                <strong>"BATAL"</strong> atau <strong>"TES"</strong> untuk
                membatalkan rencana aktif tanpa perhitungan statistik, atau
                <strong>"EDIT"</strong> untuk memindahkan kembali rencana ke
                formulir input jika ada perubahan.
              </li>
            </ul>
          </li>
        </ol>

        <h3>Memahami Hasil Kalkulasi</h3>
        <p>Berikut penjelasan untuk setiap kolom di tabel hasil:</p>
        <ul>
          <li>
            <strong>Pending Pips/Points:</strong> Jarak antara
            <strong>Price Now</strong> dan <strong>Open Price</strong> Anda.
          </li>
          <li>
            <strong>SL Pips/Points:</strong> Jarak (risiko) dari
            <strong>Open Price</strong> ke <strong>SL Price</strong>.
          </li>
          <li>
            <strong>TP Pips/Points:</strong> Jarak (potensi imbalan) dari
            <strong>Open Price</strong> ke <strong>TP Price</strong>.
          </li>
          <li>
            <strong>R:R Pips:</strong> Rasio sederhana antara TP Pips dan SL
            Pips. Contoh: 1:2.5 berarti potensi imbalan 2.5 kali lebih besar
            dari risikonya.
          </li>
          <li>
            <strong>R:R %:</strong> Rasio antara persentase potensi profit dan
            persentase risiko dari total balance.
          </li>
          <li>
            <strong>Lot/Units:</strong> Ukuran volume trading yang dihitung
            secara otomatis berdasarkan persentase risiko yang Anda tentukan,
            memastikan Anda tidak merisikokan lebih dari yang direncanakan.
          </li>
          <li>
            <strong>Nett SL:</strong> Total potensi kerugian dalam mata uang
            Dolar jika harga menyentuh Stop Loss.
          </li>
          <li>
            <strong>Nett TP:</strong> Total potensi keuntungan dalam mata uang
            Dolar jika harga menyentuh Take Profit.
          </li>
        </ul>

        <h3>Manajemen Foto & Analisis Data</h3>
        <ul class="list-disc list-inside space-y-2">
          <li>
            <strong>Galeri Foto:</strong> Anda bisa menambahkan hingga 5
            screenshot analisis (misal: dari TradingView) dengan mengklik area
            foto. Untuk menghapus foto, tekan dan tahan (long press) pada gambar
            yang ingin dihapus.
          </li>
          <li>
            <strong>Statistik & Grafik:</strong> Semua bagian di bawah tabel
            "Rencana Trading Selesai" adalah rekapitulasi performa Anda. Gunakan
            grafik ini untuk menganalisis aset mana yang paling menguntungkan,
            bagaimana pertumbuhan akun Anda, dan kapan Anda paling sering profit
            atau loss.
          </li>
          <li>
            <strong>Penting:</strong> Kalkulator ini adalah alat bantu jurnal
            dan analisis. Keputusan trading dan segala risikonya tetap menjadi
            tanggung jawab Anda sepenuhnya.
          </li>
        </ul>
      </section>

      <!-- New section for the provided text content -->
      <section class="info-section mt-8 scroll-animate-section">
        <h2 class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200">
          Bagaimana Kasino Vegas Membuat Pemain Rugi & Mirip dengan Broker
          Curang
        </h2>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Baik kasino di Las Vegas maupun beberapa broker "nakal" memiliki
          strategi tersembunyi untuk memastikan keuntungan mereka, seringkali
          dengan mengorbankan pemain atau trader yang menguntungkan. Meskipun
          metode mereka berbeda, prinsip dasarnya sama: memanipulasi
          probabilitas dan informasi untuk keuntungan mereka.
        </p>
        <h3 class="text-lg font-semibold text-gray-800 mb-3">
          Alur Kasino Vegas Membuat Pemain Rugi
        </h3>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Kasino tidak perlu "curang" secara terang-terangan untuk menang; model
          bisnis mereka dibangun di atas keunggulan statistik yang disebut
          "house edge". Ini adalah persentase keuntungan jangka panjang yang
          dimiliki kasino atas pemain. Berikut adalah alurnya:
        </p>
        <ul class="list-disc list-inside mb-4">
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Matematika yang Tidak Menguntungkan Pemain (House Edge):</strong
            >
            Setiap permainan kasino dirancang agar kasino selalu memiliki
            sedikit keuntungan matematis dalam jangka panjang. Misalnya, di
            rolet, ada angka 0 (dan kadang 00), yang berarti peluang Anda untuk
            memenangkan taruhan merah/hitam sedikit kurang dari 50%. Meskipun
            Anda mungkin menang beberapa putaran, secara statistik, kasino akan
            selalu di atas angin seiring waktu.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Variasi dan Keberuntungan Jangka Pendek:</strong> Kasino
            mengandalkan fakta bahwa dalam jangka pendek, keberuntungan bisa
            berpihak pada pemain. Ini menciptakan ilusi bahwa pemain bisa menang
            besar, mendorong mereka untuk terus bermain. Kemenangan sesekali ini
            memicu dopamin dan membuat pemain merasa "beruntung," mendorong
            mereka untuk terus bertaruh.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Psikologi dan Lingkungan yang Memikat:</strong>
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Desain Tanpa Jendela dan Jam: Kasino dirancang untuk membuat
                pemain lupa waktu, mendorong mereka untuk bermain lebih lama.
              </li>
              <li class="text-base font-light text-gray-700">
                Atmosfer Glamor dan Hiburan: Suasana yang mewah, musik, dan
                minuman gratis menciptakan lingkungan yang nyaman dan mendorong
                pengeluaran.
              </li>
              <li class="text-base font-light text-gray-700">
                Kompensasi dan Hadiah (Comp): Kasino memberikan hadiah kecil
                (makanan gratis, kamar murah) kepada pemain yang kalah dalam
                jumlah besar atau bermain untuk waktu yang lama, membuat mereka
                merasa dihargai dan mendorong kunjungan kembali.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Kontrol Informasi dan Aturan Main:</strong> Kasino
            sepenuhnya mengontrol aturan main, pembayaran, dan informasi yang
            diberikan kepada pemain. Pemain seringkali tidak menyadari house
            edge yang sebenarnya atau bagaimana probabilitas bekerja melawan
            mereka.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Pengelolaan Keuangan Pemain:</strong> Kasino mendorong
            pemain untuk mengambil lebih banyak uang tunai, menyediakan ATM di
            lokasi, dan menawarkan fasilitas kredit, semuanya dirancang untuk
            membuat pemain terus berjudi bahkan setelah mereka kehabisan uang
            tunai yang mereka bawa.
          </li>
        </ul>

        <h3 class="text-lg font-semibold text-gray-800 mb-3">
          Koneksi dengan Broker Curang yang Mencurangi Trader Profitabel
        </h3>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Meskipun ranahnya berbeda, modus operasi broker nakal yang mencurangi
          trader profitabel memiliki kemiripan filosofis dengan cara kasino
          beroperasi. Perbedaannya adalah broker tersebut melakukan tindakan
          yang lebih eksplisit dan seringkali ilegal.
        </p>
        <ul class="list-disc list-inside mb-4">
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Manipulasi Data dan Eksekusi (House Edge Tersembunyi):</strong
            >
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Slippage yang Tidak Adil: Broker sengaja menerapkan slippage
                negatif yang besar pada pesanan trader yang profitabel, atau
                bahkan pada semua pesanan. Ini berarti harga eksekusi jauh lebih
                buruk dari harga yang diharapkan trader, mengikis keuntungan.
              </li>
              <li class="text-base font-light text-gray-700">
                Requotes dan Penolakan Pesanan: Pesanan trader yang profitabel,
                terutama pada saat volatilitas tinggi, seringkali ditolak atau
                di-requote dengan harga yang kurang menguntungkan. Ini
                mengganggu strategi trading dan menyebabkan frustrasi.
              </li>
              <li class="text-base font-light text-gray-700">
                Pemblokiran Penarikan Dana: Ini adalah bentuk kecurangan yang
                paling ekstrem. Ketika trader berhasil mengumpulkan keuntungan
                yang signifikan, broker membuat berbagai alasan (masalah
                verifikasi, masalah sistem) untuk menunda atau menolak penarikan
                dana.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Intervensi pada Order Flow (Memprediksi Gerakan Pemain):</strong
            >
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Dealing Desk (DD) vs. Non-Dealing Desk (NDD): Broker DD
                seringkali mengambil posisi berlawanan dengan trader mereka.
                Jika seorang trader sangat profitabel, broker DD mungkin akan
                menempatkan "stop-loss hunting" (memicu stop-loss trader secara
                artifisial) atau menahan harga yang menguntungkan.
              </li>
              <li class="text-base font-light text-gray-700">
                Manipulasi Harga: Broker dapat memanipulasi feed harga mereka
                sendiri, terutama saat ada berita penting, untuk memicu
                stop-loss atau menunda take-profit trader.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Psikologi dan Lingkungan yang Menjebak:</strong>
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Bonus dan Promosi Palsu: Banyak broker nakal menawarkan bonus
                deposit yang sangat besar, tetapi dengan syarat dan ketentuan
                penarikan yang hampir mustahil untuk dipenuhi. Ini mengunci dana
                trader dan mendorong mereka untuk terus trading.
              </li>
              <li class="text-base font-light text-gray-700">
                Edukasi yang Menyesatkan: Beberapa broker menyediakan "edukasi"
                yang pada dasarnya mendorong gaya trading yang tidak sehat atau
                terlalu agresif, yang pada akhirnya menguntungkan broker karena
                trader akan lebih sering kalah.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Kurangnya Transparansi dan Regulasi yang Lemah:</strong>
            Broker nakal sering beroperasi di yurisdiksi dengan regulasi yang
            longgar atau sama sekali tanpa regulasi. Ini memungkinkan mereka
            untuk melakukan praktik tidak etis tanpa takut dihukum. Mereka tidak
            memberikan laporan transparan tentang eksekusi order atau aliran
            dana.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Memanfaatkan Emosi Trader:</strong> Sama seperti kasino,
            broker nakal memanfaatkan emosi seperti keserakahan dan ketakutan.
            Mereka tahu bahwa trader yang emosional cenderung membuat keputusan
            impulsif yang menguntungkan broker.
          </li>
        </ul>
        <p class="text-base font-light text-gray-700 leading-relaxed">
          Secara ringkas, baik kasino maupun broker curang bertujuan untuk
          mendapatkan keuntungan jangka panjang. Kasino melakukannya melalui
          keunggulan matematis yang inheren dalam permainan mereka dan
          manipulasi lingkungan psikologis. Broker curang, di sisi lain, secara
          aktif memanipulasi kondisi trading, data, dan terkadang bahkan menahan
          dana untuk memastikan mereka "menang" melawan trader yang
          menguntungkan. Kedua entitas ini mengandalkan fakta bahwa mayoritas
          "pemain" akan kalah dalam jangka panjang, entah karena matematika atau
          karena manipulasi sistem.
        </p>
      </section>

      <!-- NEW: Download All Data Button -->
      <section class="mt-8 text-center scroll-animate-section">
        <button id="downloadAllExcelBtn" class="action-button">
          Unduh Semua Data (Excel)
        </button>
        <button id="downloadAllPdfBtn" class="action-button">
          Unduh Semua Data (PDF)
        </button>
      </section>

      <!-- ▼▼▼ TAMBAHKAN SECTION BARU INI ▼▼▼ -->
      <section id="dataManagementSection" class="mt-8 text-center scroll-animate-section">
        <button id="deleteAllDataBtn" class="action-button bg-red-600 hover:bg-red-700 border-red-700 hover:border-red-800">
          Hapus Semua Data
        </button>
        <p id="deleteCountdownInfo" class="text-xs text-gray-500 mt-2 hidden">
          Data akan dihapus otomatis. Klik tombol di atas untuk membatalkan.
        </p>
      </section>

      <!-- Footer Section -->
      <footer
        class="w-full py-4 text-center text-gray-700 text-sm font-light mt-8"
      >
        Leodra Sint | Think like a dealer, not like a player.
      </footer>
    </div>

    <!-- Photo Upload Modal -->
    <div id="photoUploadModal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-semibold text-primary mb-4">
          Unggah & Pangkas Foto (1:1)
        </h3>
        <!-- This input is now visually hidden but triggered by the label -->
        <input
          type="file"
          id="imageInput"
          accept="image/*"
          class="hidden"
          multiple
        />
        <div
          class="flex justify-center items-center bg-gray-100 rounded-md overflow-hidden"
        >
          <canvas id="imageCanvas"></canvas>
        </div>
        <div class="flex justify-end gap-3 mt-4">
          <button
            id="cancelPhotoBtn"
            class="action-button bg-gray-300 hover:bg-gray-400 text-gray-800"
          >
            Batal
          </button>
          <button id="cropAndSaveBtn" class="action-button">
            Pangkas & Simpan
          </button>
        </div>
      </div>
    </div>

    <!-- PERBAIKAN: Skrip untuk fungsionalitas menu hamburger ditambahkan di sini -->
    <script>
      // --- PERBAIKAN: Event Delegation untuk Tombol Aksi di Semua Tabel ---

      // --- AKHIR DARI BLOK KODE BARU ---
      document.addEventListener("DOMContentLoaded", function () {
        const hamburgerBtn = document.getElementById("hamburgerBtn");
        const mobileMenu = document.getElementById("mobileMenu");
        const closeMenuBtn = document.getElementById("closeMenuBtn");

        hamburgerBtn.addEventListener("click", function () {
          mobileMenu.classList.remove("hidden");
        });

        closeMenuBtn.addEventListener("click", function () {
          mobileMenu.classList.add("hidden");
        });
      });
    </script>

    <script type="module">

        // ▼▼▼ FUNGSI BARU: B-BOOK PROFILER LOGIC ▼▼▼
      function calculateAndRenderBBookProfile() {
        const statusTitle = document.getElementById('bBookStatusTitle');
        const statusDesc = document.getElementById('bBookStatusDesc');
        const statusContainer = document.getElementById('bBookStatusContainer');
        const iconEl = document.getElementById('bBookIcon');
        
        const martingaleEl = document.getElementById('bBookMartingaleScore');
        const correlationEl = document.getElementById('bBookCorrelation');
        const mcProbEl = document.getElementById('bBookMcProbability');

        if (!statusTitle) return;

        // 1. Ambil Data Valid & Urutkan (Lama ke Baru)
        const validTrades = executedPlansData
            .filter(t => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        // Syarat minimal data
        if (validTrades.length < 5) {
            statusTitle.textContent = "Data Belum Cukup";
            statusTitle.className = "text-2xl font-bold text-gray-400 tracking-tight";
            statusDesc.textContent = "Sistem membutuhkan minimal 5 data trade yang selesai untuk mulai memprofilkan psikologi Anda.";
            statusContainer.className = "p-6 rounded-lg bg-gray-50 border border-gray-200 mb-6";
            iconEl.textContent = "📊";
            martingaleEl.textContent = "0%";
            correlationEl.textContent = "N/A";
            mcProbEl.textContent = "N/A";
            return;
        }

        // 2. Analisis Martingale (Perilaku Judi)
        // Hitung berapa kali user menaikkan Lot setelah mengalami Loss
        let totalLosses = 0;
        let martingaleActs = 0; // Aksi menaikkan lot setelah loss
        
        for (let i = 1; i < validTrades.length; i++) {
            const prevTrade = validTrades[i-1];
            const currTrade = validTrades[i];
            const prevResult = getTradeResult(prevTrade);
            
            if (!prevResult.isWin) { // Jika trade sebelumnya Loss
                totalLosses++;
                // Jika trade sekarang Lot-nya LEBIH BESAR > 10% dari trade sebelumnya yang loss
                if (currTrade.lotSize > (prevTrade.lotSize * 1.1)) {
                    martingaleActs++;
                }
            }
        }
        
        const martingaleScore = totalLosses > 0 ? (martingaleActs / totalLosses) * 100 : 0;

        // 3. Analisis Korelasi (Lot vs Performa)
        // Bagi data menjadi 2 babak (Awal & Akhir) untuk melihat tren
        const midPoint = Math.floor(validTrades.length / 2);
        const recentTrades = validTrades.slice(midPoint);
        const oldTrades = validTrades.slice(0, midPoint);

        const calcMetrics = (trades) => {
            if (trades.length === 0) return { avgLot: 0, winRate: 0 };
            const wins = trades.filter(t => getTradeResult(t).isWin).length;
            const avgLot = trades.reduce((sum, t) => sum + t.lotSize, 0) / trades.length;
            return { avgLot, winRate: (wins / trades.length) * 100 };
        };

        const oldMetrics = calcMetrics(oldTrades);
        const recentMetrics = calcMetrics(recentTrades);

        const lotTrend = recentMetrics.avgLot - oldMetrics.avgLot; // Positif = Lot Membesar
        const winRateTrend = recentMetrics.winRate - oldMetrics.winRate; // Positif = Performa Membaik

        // Logika Korelasi:
        // Ideal (A-Book): Winrate Naik, Lot Naik (Confident Scaling)
        // Buruk (B-Book): Winrate Turun, Lot Naik (Desperation/Revenge)
        let correlationStatus = "Neutral";
        if (lotTrend > 0 && winRateTrend < -10) correlationStatus = "Negative (Danger)";
        else if (lotTrend > 0 && winRateTrend >= -10) correlationStatus = "Positive (Scaling)";
        else if (lotTrend <= 0) correlationStatus = "Stable/Conservative";

        // 4. Penentuan Profil & Probabilitas MC
        let isBBook = false;
        let profileTitle = "";
        let profileReason = "";
        let mcProb = 0; // 0 - 100%

        // -- LOGIKA DETEKSI --
        if (martingaleScore > 40) {
            // Jika > 40% dari loss diikuti dengan kenaikan lot
            isBBook = true;
            profileTitle = "B-Book (Santapan Bandar)";
            profileReason = "Terdeteksi pola <strong>Martingale Agresif</strong>. Anda cenderung melipatgandakan risiko untuk membalas kerugian. Ini adalah perilaku favorit bandar.";
            mcProb = 85 + (martingaleScore * 0.1); 
            iconEl.textContent = "🥩"; // Daging/Santapan
        } 
        else if (correlationStatus === "Negative (Danger)") {
            // Lot Naik TAPI Winrate Turun
            isBBook = true;
            profileTitle = "B-Book (Desperate Trader)";
            profileReason = "Volume Lot Anda meningkat saat performa (Winrate) sedang menurun tajam. Ini indikasi kuat <strong>Revenge Trading</strong> atau frustrasi.";
            mcProb = 75;
            iconEl.textContent = "🎣"; // Pancingan
        } 
        else {
            // A-Book Logic
            isBBook = false;
            profileTitle = "A-Book (Ancaman)";
            profileReason = "Pola trading Anda konsisten atau konservatif. Risiko tidak meningkat saat emosi. Bandar akan menganggap Anda 'Toxic Flow' (Sulit dikalahkan) dan mungkin melempar order Anda ke LP.";
            // Rumus kasar probabilitas MC untuk A-book: Semakin rendah winrate, semakin tinggi risiko, tapi cap di 40%
            mcProb = Math.max(5, 50 - recentMetrics.winRate); 
            if (mcProb < 1) mcProb = 1;
            iconEl.textContent = "🦈"; // Hiu/Predator
        }

        // Cap Probability
        if (mcProb > 99) mcProb = 99.9;

        // 5. Render UI
        statusTitle.textContent = profileTitle;
        statusDesc.innerHTML = profileReason; // Gunakan innerHTML untuk bold tag
        
        martingaleEl.textContent = `${martingaleScore.toFixed(0)}%`;
        martingaleEl.className = martingaleScore > 30 ? "font-mono text-lg font-bold text-red-600" : "font-mono text-lg font-bold text-green-600";

        correlationEl.textContent = correlationStatus;
        correlationEl.className = correlationStatus.includes("Danger") ? "font-mono text-sm font-bold text-red-600" : "font-mono text-sm font-bold text-gray-700";

        mcProbEl.textContent = `${mcProb.toFixed(1)}%`;
        mcProbEl.className = mcProb > 50 ? "font-mono text-lg font-bold text-red-600" : "font-mono text-lg font-bold text-green-600";

        if (isBBook) {
            statusTitle.className = "text-2xl font-bold text-red-600 tracking-tight";
            statusContainer.className = "p-6 rounded-lg bg-red-50 border border-red-200 mb-6 shadow-sm border-l-4 border-l-red-500";
        } else {
            statusTitle.className = "text-2xl font-bold text-green-600 tracking-tight";
            statusContainer.className = "p-6 rounded-lg bg-green-50 border border-green-200 mb-6 shadow-sm border-l-4 border-l-green-500";
        }
      }
      // ▲▲▲ AKHIR FUNGSI BARU ▲▲▲

        // ▼▼▼ BANK SOAL & LOGIKA KUIS (BARU) ▼▼▼
      
      // 1. Bank Soal Logika (Bisa ditambah hingga 100+)
      const logicQuestionBank = [
        { q: "Jika A = 2, B = 4, C = 6, maka G = ?", a: "14", options: ["10", "12", "14", "16"] },
        { q: "1, 1, 2, 3, 5, 8, ... Angka berikutnya?", a: "13", options: ["10", "11", "12", "13"] },
        { q: "Apa yang naik tapi tidak pernah turun?", a: "Umur", options: ["Gaji", "Umur", "Harga", "Pesawat"] },
        { q: "Semua A adalah B. Sebagian B adalah C. Apakah semua A adalah C?", a: "Tidak Pasti", options: ["Ya", "Tidak", "Tidak Pasti", "Mungkin"] },
        { q: "Jika kemarin lusa adalah Senin, hari apa besok?", a: "Kamis", options: ["Rabu", "Kamis", "Jumat", "Sabtu"] },
        { q: "Trading: Jika Winrate 40% dan RR 1:2, apakah profitable?", a: "Ya", options: ["Ya", "Tidak", "BEP", "Tergantung"] },
        { q: "Mana yang lebih berat: 1kg Kapas atau 1kg Besi?", a: "Sama", options: ["Kapas", "Besi", "Sama", "Tergantung Gravitasi"] },
        { q: "Lengkapi: Kucing - Meong, Anjing - ...?", a: "Gonggong", options: ["Moo", "Kukuruyuk", "Gonggong", "Aum"] },
        { q: "Jika Anda menyalip orang di posisi ke-2, Anda posisi berapa?", a: "2", options: ["1", "2", "3", "4"] },
        { q: "Berapa kali angka 7 muncul dari 1 sampai 100?", a: "20", options: ["10", "11", "19", "20"] },
        // ... Tambahkan lebih banyak soal variatif di sini agar tidak repetitif
        { q: "Pintu apa yang didorong tidak bisa dibuka?", a: "Pintu Geser", options: ["Pintu Besi", "Pintu Geser", "Pintu Rusak", "Pintu Hati"] },
        { q: "Bulan apa yang memiliki 28 hari?", a: "Semua Bulan", options: ["Februari", "Maret", "Semua Bulan", "Tidak Ada"] },
        { q: "Arah jam 9 itu ke mana?", a: "Barat/Kiri", options: ["Atas", "Bawah", "Timur", "Barat/Kiri"] },
        { q: "Mana yang bukan alat trading?", a: "Obeng", options: ["Laptop", "Mouse", "Obeng", "Chart"] },
        { q: "Apa lawan kata dari 'Panjang'?", a: "Pendek", options: ["Kecil", "Sempit", "Pendek", "Rendah"] },
        { q: "2 + 2 x 2 = ?", a: "6", options: ["6", "8", "4", "10"] },
        { q: "Stop Loss gunanya untuk?", a: "Membatasi Rugi", options: ["Menambah Rugi", "Membatasi Rugi", "Gaya-gayaan", "Syarat Broker"] },
        { q: "FOMO singkatan dari?", a: "Fear Of Missing Out", options: ["Fear Of Missing Out", "Fear Of Money Out", "Full Of Money Only", "Fast On Market Open"] },
        { q: "Apa warna kotak hitam pesawat?", a: "Oranye", options: ["Hitam", "Putih", "Merah", "Oranye"] },
        { q: "Ibukota Indonesia (saat ini de jure)?", a: "Jakarta", options: ["Bandung", "IKN", "Jakarta", "Surabaya"] },
        { q: "8 / 2 (2 + 2) = ?", a: "16", options: ["1", "16", "10", "8"] },
        { q: "Ayam berkokok pada?", a: "Pagi", options: ["Siang", "Sore", "Malam", "Pagi"] },
        { q: "Jika dibalik, angka apa yang nilainya berkurang 3?", a: "9", options: ["6", "9", "8", "0"] },
        { q: "Benda apa yang kalau dipotong malah makin tinggi?", a: "Celana", options: ["Rambut", "Rumput", "Celana", "Tiang"] },
        { q: "Buy Low, Sell ...?", a: "High", options: ["Lower", "High", "Hard", "Fast"] }
      ];

      // 2. Bank Soal Introspeksi (Isian/Pilihan Refleksi)
      const introspectionQuestionBank = [
        "Apa emosi dominan saya saat ini? (Marah/Takut/Serakah/Tenang)",
        "Apakah saya baru saja melanggar aturan trading plan saya?",
        "Apakah saya sedang mencoba membalas kerugian (Revenge Trading)?",
        "Jika saya loss lagi di trade berikutnya, apakah saya akan baik-baik saja?",
        "Apakah saya trading karena melihat peluang atau karena bosan?",
        "Sudahkah saya menerima risiko kehilangan uang ini sepenuhnya?",
        "Apakah ukuran lot saya sudah sesuai dengan manajemen risiko?",
        "Apakah saya sedang dalam kondisi fisik/mental yang prima (tidak lapar/lelah)?",
        "Apa pelajaran terpenting dari kesalahan hari ini?",
        "Apakah saya siap berhenti sejenak untuk menenangkan pikiran?"
      ];

      // 3. Bank Pesan Harian
      const dailyQuotes = [
        "Trading itu seperti maraton, bukan lari sprint. Jangan habiskan napasmu di awal.",
        "Pasar tidak peduli dengan perasaanmu. Tetaplah logis, bukan emosional.",
        "Seorang pilot tidak terbang saat badai tanpa radar. Jangan trading tanpa rencana.",
        "Kerugian adalah biaya bisnis dalam trading. Terima, pelajari, lupakan.",
        "Disiplin adalah melakukan apa yang harus dilakukan, saat harus dilakukan, meski tidak ingin melakukannya.",
        "Jangan mengejar uang, kejarlah eksekusi yang sempurna. Uang akan mengikuti.",
        "Sabar menunggu setup terbaik sama pentingnya dengan eksekusi itu sendiri.",
        "Tujuanmu hari ini: Lindungi modal, baru cari profit.",
        "Jangan biarkan satu trade buruk merusak minggu yang baik.",
        "Jika ragu, menepi. Cash adalah posisi."
      ];

      // 4. State & Fungsi Kuis Harian
      function initDailyQuizSystem() {
        const today = new Date().toISOString().slice(0, 10);
        const savedData = JSON.parse(localStorage.getItem('dailyQuizData')) || { lastDate: '', streak: 0, completed: false };
        const quoteIndex = new Date().getDate() % dailyQuotes.length;
        
        // Render Quote
        document.getElementById('dailyQuoteContainer').innerHTML = `"${dailyQuotes[quoteIndex]}"`;
        document.getElementById('consistencyScoreDisplay').textContent = savedData.streak;

        // Cek status hari ini
        if (savedData.lastDate === today && savedData.completed) {
          document.getElementById('dailyQuizStatus').textContent = "Selesai ✅";
          document.getElementById('dailyQuizStatus').className = "inline-block mt-1 px-3 py-1 rounded-full text-xs font-bold bg-green-100 text-green-700";
          document.getElementById('startDailyQuizBtn').textContent = "Anda Sudah Menyelesaikan Kuis Hari Ini";
          document.getElementById('startDailyQuizBtn').disabled = true;
          document.getElementById('startDailyQuizBtn').classList.add('opacity-50', 'cursor-not-allowed');
        } else {
          // Reset jika hari berganti dan belum selesai
          if (savedData.lastDate !== today) {
             // Cek jika kemarin bolos (opsional: reset streak)
             const yesterday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);
             if (savedData.lastDate !== yesterday && savedData.lastDate !== '') {
                 savedData.streak = 0; // Reset streak jika tidak konsisten
                 savedData.lastDate = today; // Update tanggal
                 savedData.completed = false;
                 localStorage.setItem('dailyQuizData', JSON.stringify(savedData));
                 document.getElementById('consistencyScoreDisplay').textContent = 0;
             }
          }
          
          document.getElementById('startDailyQuizBtn').addEventListener('click', () => {
             renderDailyQuizQuestions(today);
             document.getElementById('startDailyQuizContainer').classList.add('hidden');
             document.getElementById('dailyQuizContainer').classList.remove('hidden');
          });
        }
        
        // Listener Submit
        document.getElementById('submitDailyQuizBtn').addEventListener('click', submitDailyQuiz);
      }

      function renderDailyQuizQuestions(seedDate) {
        const container = document.getElementById('dailyQuizQuestions');
        container.innerHTML = "";
        
        // Pseudo-random generator berdasarkan tanggal agar soal sama seharian
        let seed = seedDate.split('-').join('') * 1; 
        const random = () => {
            var x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        };

        // Pilih 20 soal acak
        const questions = [];
        const indices = new Set();
        while(indices.size < 20 && indices.size < logicQuestionBank.length) {
            const idx = Math.floor(random() * logicQuestionBank.length);
            if(!indices.has(idx)) {
                indices.add(idx);
                questions.push(logicQuestionBank[idx]);
            }
        }

        questions.forEach((q, index) => {
            const html = `
                <div class="bg-gray-50 p-3 rounded border border-gray-200 text-sm">
                    <p class="font-semibold mb-2">${index + 1}. ${q.q}</p>
                    <div class="grid grid-cols-2 gap-2">
                        ${q.options.map(opt => `
                            <label class="flex items-center space-x-2 cursor-pointer">
                                <input type="radio" name="dq_${index}" value="${opt}" class="form-radio text-blue-600">
                                <span>${opt}</span>
                            </label>
                        `).join('')}
                    </div>
                    <input type="hidden" id="dq_ans_${index}" value="${q.a}">
                </div>
            `;
            container.insertAdjacentHTML('beforeend', html);
        });
      }

      function submitDailyQuiz() {
        const container = document.getElementById('dailyQuizQuestions');
        const inputs = container.querySelectorAll('input[type="hidden"]');
        let score = 0;
        let answered = 0;

        inputs.forEach((input, index) => {
            const selected = document.querySelector(`input[name="dq_${index}"]:checked`);
            if (selected) {
                answered++;
                if (selected.value === input.value) score++;
            }
        });

        if (answered < 20) {
            showMessageBox("Belum Selesai", "Mohon jawab semua 20 pertanyaan sebelum mengirim.", false);
            return;
        }

        // Hitung Hasil
        const finalScore = (score / 20) * 100;
        const today = new Date().toISOString().slice(0, 10);
        
        // Simpan Data
        const savedData = JSON.parse(localStorage.getItem('dailyQuizData')) || { lastDate: '', streak: 0, completed: false };
        savedData.lastDate = today;
        savedData.completed = true;
        savedData.streak += 1;
        localStorage.setItem('dailyQuizData', JSON.stringify(savedData));

        // Update UI
        document.getElementById('dailyQuizContainer').innerHTML = `
            <div class="text-center p-6">
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Skor Anda: ${finalScore.toFixed(0)}/100</h3>
                <p class="text-gray-600 mb-4">Konsistensi +1 Hari. Total: ${savedData.streak} Hari.</p>
                <div class="bg-green-100 text-green-800 p-3 rounded">
                    Selamat! Anda telah melatih logika hari ini. Tetap disiplin di market!
                </div>
            </div>
        `;
        document.getElementById('dailyQuizStatus').textContent = "Selesai ✅";
        document.getElementById('dailyQuizStatus').className = "inline-block mt-1 px-3 py-1 rounded-full text-xs font-bold bg-green-100 text-green-700";
        document.getElementById('consistencyScoreDisplay').textContent = savedData.streak;
        
        showMessageBox("Kuis Selesai", `Skor Logika: ${finalScore}. Konsistensi ditingkatkan!`, false);
      }

      // 5. Fungsi Lockout Quiz
      function showLockoutQuizModal() {
        const modal = document.getElementById('lockoutQuizModal');
        const logicContainer = document.getElementById('lockoutLogicQuestions');
        const introContainer = document.getElementById('lockoutIntrospectionQuestions');
        const submitBtn = document.getElementById('submitLockoutQuizBtn');
        const closeBtn = document.getElementById('closeLockoutModalBtn');
        const scoreResult = document.getElementById('lockoutScoreResult');

        // Reset UI
        logicContainer.innerHTML = "";
        introContainer.innerHTML = "";
        scoreResult.classList.add('hidden');
        closeBtn.classList.add('hidden');
        submitBtn.classList.remove('hidden');
        submitBtn.disabled = false;
        
        // 1. Pilih 10 Soal Logika Acak
        const shuffledLogic = [...logicQuestionBank].sort(() => 0.5 - Math.random()).slice(0, 10);
        shuffledLogic.forEach((q, index) => {
             const html = `
                <div class="text-sm mb-3">
                    <p class="font-semibold mb-1">${index + 1}. ${q.q}</p>
                    <select id="lq_${index}" class="w-full border rounded p-1">
                        <option value="" disabled selected>Pilih Jawaban...</option>
                        ${q.options.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
                    </select>
                    <input type="hidden" id="lq_ans_${index}" value="${q.a}">
                </div>
            `;
            logicContainer.insertAdjacentHTML('beforeend', html);
        });

        // 2. Render 10 Soal Introspeksi (Wajib Diisi Teks)
        introspectionQuestionBank.forEach((q, index) => {
            const html = `
                <div class="text-sm mb-3">
                    <p class="font-semibold mb-1">${index + 1}. ${q}</p>
                    <input type="text" id="iq_${index}" class="w-full border rounded p-2" placeholder="Jawab dengan jujur...">
                </div>
            `;
            introContainer.insertAdjacentHTML('beforeend', html);
        });

        // Tampilkan Modal
        showModal(modal);

        // Handler Submit
        // Hapus listener lama jika ada (untuk menghindari duplikasi)
        const newSubmitBtn = submitBtn.cloneNode(true);
        submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);
        
        newSubmitBtn.addEventListener('click', () => {
            // Validasi Logika
            let logicScore = 0;
            let allLogicAnswered = true;
            shuffledLogic.forEach((q, index) => {
                const ans = document.getElementById(`lq_${index}`).value;
                const correct = document.getElementById(`lq_ans_${index}`).value;
                if (!ans) allLogicAnswered = false;
                if (ans === correct) logicScore++;
            });

            // Validasi Introspeksi
            let allIntroAnswered = true;
            introspectionQuestionBank.forEach((q, index) => {
                const val = document.getElementById(`iq_${index}`).value.trim();
                if (val.length < 3) allIntroAnswered = false; // Minimal 3 karakter
            });

            if (!allLogicAnswered || !allIntroAnswered) {
                alert("Mohon jawab SEMUA soal logika dan introspeksi dengan lengkap sebelum melanjutkan.");
                return;
            }

            // Tampilkan Hasil
            const finalScore = logicScore * 10; // 10 soal x 10 poin
            scoreResult.innerHTML = `Skor Logika Anda: ${finalScore}/100<br><span class="text-sm font-normal text-gray-600">Terima kasih telah melakukan introspeksi. Pikiran Anda sekarang lebih jernih.</span>`;
            scoreResult.classList.remove('hidden');
            
            newSubmitBtn.classList.add('hidden');
            closeBtn.classList.remove('hidden');
            
            // Simpan status bahwa lockout quiz sudah diselesaikan HARI INI
            const today = new Date().toISOString().slice(0, 10);
            localStorage.setItem('lockoutQuizPassedDate', today);
        });

        // Handler Close
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        newCloseBtn.addEventListener('click', () => {
            hideModal(modal);
        });
    }
    // ▲▲▲ AKHIR DATA & FUNGSI BARU ▲▲▲



      

      // --- Letakkan di dekat variabel global lainnya ---
      let deletionTimerInterval = null; // Untuk menyimpan ID interval countdown
      const deletionTimestampKey = 'scheduledDeletionTimestamp'; // Kunci localStorage
      

      // --- TAMBAHKAN FUNGSI-FUNGSI BARU BERIKUT INI ---

      /**
       * Memformat sisa detik menjadi string HH:MM:SS.
       * @param {number} totalSeconds - Total detik yang tersisa.
       * @returns {string} String waktu terformat.
       */
      function formatCountdownTime(totalSeconds) {
        if (totalSeconds < 0) totalSeconds = 0;
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
      

      /**
       * Memperbarui teks tombol Hapus dengan waktu hitung mundur.
       * @param {number} remainingSeconds - Detik yang tersisa.
       */
      function updateCountdownButton(remainingSeconds) {
        const deleteAllDataBtn = document.getElementById('deleteAllDataBtn');
        const deleteCountdownInfo = document.getElementById('deleteCountdownInfo');
        if (deleteAllDataBtn && deleteCountdownInfo) {
           deleteAllDataBtn.textContent = `Hapus dalam ${formatCountdownTime(remainingSeconds)}`;
           deleteCountdownInfo.classList.remove('hidden');
        }
      }

      /**
       * Mengembalikan teks tombol Hapus ke default.
       */
      function resetDeleteButton() {
        const deleteAllDataBtn = document.getElementById('deleteAllDataBtn');
        const deleteCountdownInfo = document.getElementById('deleteCountdownInfo');
         if (deleteAllDataBtn && deleteCountdownInfo) {
           deleteAllDataBtn.textContent = 'Hapus Semua Data';
           deleteCountdownInfo.classList.add('hidden');
         }
      }

      // --- Letakkan di dalam blok document.addEventListener("DOMContentLoaded", async () => { ... }); ---

      // ... (Kode listener untuk downloadExecutedOnlyBtn yang sudah ada) ...
      const downloadExecutedOnlyBtn = document.getElementById('downloadExecutedOnlyBtn');
      if (downloadExecutedOnlyBtn) {
          downloadExecutedOnlyBtn.addEventListener('click', () => {
              // ... (Logika unduh excel tabel selesai) ...
              console.log("Tombol Unduh Excel (Hanya Selesai) diklik.");
              // ... (rest of the download logic) ...
          });
      } else {
         console.error("Tombol 'Unduh Excel (Tabel Ini)' (#downloadExecutedOnlyBtn) tidak ditemukan.");
      }

      // --- TAMBAHKAN EVENT LISTENER BARU UNTUK TOMBOL HAPUS KHUSUS ---
      const deleteExecutedOnlyBtn = document.getElementById('deleteExecutedOnlyBtn');

      if (deleteExecutedOnlyBtn) {
          deleteExecutedOnlyBtn.addEventListener('click', async () => {
              console.log("Tombol Hapus Data Tabel Selesai diklik.");

              // 1. Cek apakah ada data untuk dihapus
              if (!executedPlansData || executedPlansData.length === 0) {
                  showMessageBox("Informasi", "Tidak ada data Rencana Trading Selesai untuk dihapus.", false);
                  return;
              }

              // 2. Tampilkan konfirmasi
              const confirmResult = await showMessageBox(
                  "Konfirmasi Hapus Data Selesai",
                  `Anda yakin ingin menghapus <strong>semua ${executedPlansData.length} data</strong> dari tabel "Rencana Trading Selesai"? Data akan diunduh terlebih dahulu sebelum dihapus permanen.`,
                  true // Tampilkan tombol Ya/Batal
              );

              // 3. Proses jika dikonfirmasi (klik Ya)
              if (confirmResult.confirmed) {
                  showMessageBox("Memproses...", "Mengunduh dan menghapus data...", false); // Tampilkan notifikasi loading

                  try {
                      // 4. Unduh Data Terlebih Dahulu
                      console.log("Mengunduh data sebelum dihapus...");
                      const headers = [
                          "No.", "Aset", "Trade", "Balance Akun", "Waktu Masuk", "Price Now",
                          "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points", "TP Pips/Points",
                          "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP", "Catatan", "Hasil", "Waktu Keluar"
                          // Hapus kolom Revisi dari unduhan hapus data ini
                      ];
                      const dataColWidths = [
                          { wch: 5 }, { wch: 15 }, { wch: 8 }, { wch: 15 }, { wch: 20 }, { wch: 15 },
                          { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 18 }, { wch: 15 }, { wch: 15 },
                          { wch: 12 }, { wch: 18 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 25 },
                          { wch: 15 }, { wch: 20 }
                      ];
                      const bodyData = executedPlansData.map((plan, index) => {
                          const formattedPlan = preparePlanForExport(plan, "Selesai");
                          return [ // Sesuaikan urutan dengan header di atas
                              index + 1,
                              formattedPlan.Aset, formattedPlan.Trade, formattedPlan["Balance Akun"], formattedPlan["Waktu Masuk"], formattedPlan["Price Now"],
                              formattedPlan["Open Price"], formattedPlan["SL Price"], formattedPlan["TP Price"], formattedPlan["Pending Pips/Points"],
                              formattedPlan["SL Pips/Points"], formattedPlan["TP Pips/Points"], formattedPlan["R:R Pips"], formattedPlan["R:R %"],
                              formattedPlan["Lot/Units"], formattedPlan["Nett SL"], formattedPlan["Nett TP"], formattedPlan.Catatan,
                              formattedPlan.Hasil, formattedPlan["Waktu Keluar"]
                          ];
                      });
                      const wb = XLSX.utils.book_new();
                      const titleRow = ["ARSIP Rencana Trading Selesai (Dihapus)"];
                      for (let i = 1; i < headers.length; i++) { titleRow.push(""); }
                      const aoaData = [ titleRow, headers, ...bodyData ];
                      const ws = XLSX.utils.aoa_to_sheet(aoaData);
                      if (!ws['!merges']) ws['!merges'] = [];
                      ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: headers.length - 1 } });
                      ws['!cols'] = dataColWidths;
                      XLSX.utils.book_append_sheet(wb, ws, "Rencana Selesai");
                      const filename = `ARSIP_HAPUS_Rencana_Selesai_${new Date().toISOString().slice(0, 10)}.xlsx`;
                      XLSX.writeFile(wb, filename); // Pemicu unduhan

                      // Beri sedikit jeda agar unduhan dimulai sebelum menghapus
                      await new Promise(resolve => setTimeout(resolve, 1000));

                      // 5. Hapus Data
                      console.log("Menghapus data Rencana Trading Selesai...");
                      // Panggil fungsi hapus backend (asumsi deleteAllExecutedPlans menghapus semua data user ini)
                      await deleteAllExecutedPlans(); // Fungsi ini sudah ada

                      // Kosongkan array di state JavaScript
                      executedPlansData = [];

                      // Simpan state kosong ke localStorage
                      saveDataToLocalStorage();

                      // Perbarui UI (render tabel kosong & hitung ulang statistik)
                      updateAllDataAndRenderUI();

                      // Hapus notifikasi loading
                      const existingModal = document.querySelector(".message-box-modal");
                      if (existingModal && existingModal.querySelector("h3").textContent.includes("Memproses")) {
                          existingModal.remove();
                      }
                      // Tampilkan notifikasi sukses
                      showMessageBox("Berhasil", `Semua data Rencana Trading Selesai telah diunduh ke "${filename}" dan berhasil dihapus.`, false);

                  } catch (error) {
                      console.error("Gagal saat proses unduh & hapus data selesai:", error);
                      // Hapus notifikasi loading jika error
                      const existingModal = document.querySelector(".message-box-modal");
                      if (existingModal && existingModal.querySelector("h3").textContent.includes("Memproses")) {
                          existingModal.remove();
                      }
                      showMessageBox("Gagal", `Terjadi kesalahan: ${error.message}. Data tidak dihapus.`, false);
                  }

              } else {
                  // 4. Jika klik Batal
                  showMessageBox("Dibatalkan", "Penghapusan data tabel Rencana Trading Selesai dibatalkan.", false);
              }
          });
      } else {
          console.error("Tombol 'Hapus Data Tabel Ini' (#deleteExecutedOnlyBtn) tidak ditemukan.");
      }
      // --- AKHIR TAMBAHAN EVENT LISTENER BARU ---

      // ... (sisa kode event listener Anda seperti DOMContentLoaded, calculateAllBtn, dll) ...

      /**
       * Menjalankan proses penghapusan semua data trading dan mengunduh data Selesai.
       */
      async function deleteAllDataAndDownloadExecuted() {
        console.log("Memulai proses penghapusan semua data...");

        // 1. Unduh Data Selesai (jika ada)
        if (executedPlansData.length > 0) {
           console.log("Mengunduh data Rencana Trading Selesai...");
           const headers = [ // Pastikan header ini sesuai dengan fungsi preparePlanForExport
             "Status", "Aset", "Trade", "Balance Akun", "Waktu Masuk", "Price Now",
             "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points", "TP Pips/Points",
             "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP", "OriginalNettSL", "OriginalNettTP",
             "Catatan", "Hasil", "Waktu Keluar"
           ];
           const dataToExport = executedPlansData.map(plan => preparePlanForExport(plan, "Selesai"));
           downloadAsExcel( // Gunakan fungsi download yang sudah ada
             `ARSIP_SEMUA_Rencana_Trading_Selesai_${new Date().toISOString().slice(0, 10)}.csv`,
             dataToExport,
             headers
           );
           await new Promise(resolve => setTimeout(resolve, 500)); // Beri jeda sedikit agar unduhan dimulai
        } else {
           console.log("Tidak ada data Rencana Trading Selesai untuk diunduh.");
        }

        // 2. Hapus data dari state JavaScript
        console.log("Menghapus data dari memori...");
        calculatedPlansData = [];
        runningPlansData = [];
        executedPlansData = [];

        // 3. Hapus data dari localStorage
        console.log("Menghapus data dari localStorage...");
        localStorage.removeItem('calculatedPlansData');
        localStorage.removeItem('runningPlansData');
        localStorage.removeItem('executedPlansData');
        localStorage.removeItem('calculatorInputRows');
        localStorage.removeItem(deletionTimestampKey); // Hapus timestamp jadwal jika ada
        // Hapus juga kunci notifikasi batas kerugian jika ada
        localStorage.removeItem('tradingLockoutDate');
        localStorage.removeItem('tradingLockoutMonth');
        localStorage.removeItem('tradingLockoutReason');

        // 4. Hapus data dari backend (jika menggunakan) - PENTING!
        console.log("Menghapus data dari backend (jika ada)...");
        if (db && userId !== "anonymous") {
            try {
                // Hapus Calculated (jika disimpan di Firestore)
                // await deleteAllCalculatedPlans(userId); // Uncomment jika ada fungsi ini
                // Hapus Running (jika disimpan di Firestore)
                // const runningSnapshot = await getDocs(query(collection(db, `artifacts/${appId}/users/${userId}/runningPlans`)));
                // const deleteRunningPromises = runningSnapshot.docs.map(doc => deleteDoc(doc.ref));
                // await Promise.all(deleteRunningPromises);
                // Hapus Executed (menggunakan API yang ada)
                await deleteAllExecutedPlans(); // Fungsi ini sudah ada dan memanggil API backend
            } catch (error) {
                console.error("Gagal menghapus data dari backend:", error);
                // Mungkin tampilkan pesan error ke pengguna, tapi proses reset UI tetap lanjut
                showMessageBox("Peringatan", "Gagal menghapus data dari server, namun data lokal telah dihapus.", false);
            }
        }

        // 5. Reset tampilan input rows
        console.log("Mereset baris input...");
        inputRowsContainer.innerHTML = '';
        addInputRow(); // Tambahkan satu baris kosong baru
        saveInputRowsToLocalStorage(); // Simpan state input yang kosong

        // 6. Perbarui seluruh UI (render tabel kosong, reset statistik & grafik)
        console.log("Memperbarui UI...");
        updateAllDataAndRenderUI();

        // 7. Reset tombol hapus
        resetDeleteButton();

        console.log("Proses penghapusan selesai.");
      }


      /**
       * Memulai timer hitung mundur dan memperbarui tombol.
       * @param {number} targetTimestamp - Timestamp (ms) kapan penghapusan dijadwalkan.
       */
      function startCountdownTimer(targetTimestamp) {
         clearInterval(deletionTimerInterval); // Hapus interval lama jika ada

         deletionTimerInterval = setInterval(() => {
           const now = Date.now();
           const remainingMs = targetTimestamp - now;
           const remainingSeconds = Math.max(0, Math.floor(remainingMs / 1000));

           if (remainingSeconds > 0) {
             updateCountdownButton(remainingSeconds);
           } else {
             // Waktu habis, jalankan penghapusan
             clearInterval(deletionTimerInterval);
             deletionTimerInterval = null;
             console.log("Waktu hitung mundur habis, menjalankan penghapusan terjadwal...");
             executeScheduledDeletion(); // Jalankan penghapusan otomatis
           }
         }, 1000); // Update setiap detik
      }

      /**
       * Menjadwalkan penghapusan data 24 jam dari sekarang.
       */
      function scheduleDeletion() {
        const targetTimestamp = Date.now() + 24 * 60 * 60 * 1000; // 24 jam dalam milidetik
        localStorage.setItem(deletionTimestampKey, targetTimestamp.toString());
        console.log(`Penghapusan dijadwalkan pada: ${new Date(targetTimestamp).toLocaleString()}`);
        startCountdownTimer(targetTimestamp);
        showMessageBox("Terjadwal", "Sukses, Semua data akan dihapus dalam 24 jam.", false);
      }

      /**
       * Membatalkan penghapusan data yang terjadwal.
       */
      function cancelScheduledDeletion() {
        clearInterval(deletionTimerInterval);
        deletionTimerInterval = null;
        localStorage.removeItem(deletionTimestampKey);
        resetDeleteButton();
        console.log("Penghapusan terjadwal dibatalkan.");
        showMessageBox("Dibatalkan", "Sukses, Penghapusan data dibatalkan.", false);
      }

       /**
       * Menjalankan penghapusan yang sudah dijadwalkan (dipanggil saat timer habis).
       */
       async function executeScheduledDeletion() {
          await deleteAllDataAndDownloadExecuted();
          resetDeleteButton(); // Pastikan tombol reset setelah selesai
          showMessageBox("Sukses", "Sukses, Semua data telah dihapus otomatis setelah 24 jam dan diunduh.", false);
       }

      // --- AKHIR DARI FUNGSI-FUNGSI BARU ---


      // --- Letakkan di dalam blok document.addEventListener("DOMContentLoaded", async () => { ... }); ---

      // --- TAMBAHKAN KODE INI UNTUK INISIALISASI DAN EVENT LISTENER TOMBOL HAPUS ---
      const deleteAllDataBtn = document.getElementById('deleteAllDataBtn');

      // Cek status penghapusan saat halaman dimuat
      const scheduledTimestamp = localStorage.getItem(deletionTimestampKey);
      if (scheduledTimestamp) {
        const targetTime = parseInt(scheduledTimestamp, 10);
        if (targetTime > Date.now()) {
          // Masih dalam periode countdown, mulai timer
          console.log("Melanjutkan hitung mundur penghapusan data...");
          startCountdownTimer(targetTime);
        } else {
          // Waktu sudah lewat saat halaman dimuat, langsung hapus
          console.log("Waktu penghapusan terjadwal sudah lewat, menjalankan penghapusan...");
           executeScheduledDeletion(); // Langsung hapus
        }
      } else {
          resetDeleteButton(); // Pastikan tombol dalam keadaan default
      }

      // Tambahkan event listener untuk tombol hapus
      if (deleteAllDataBtn) {
        deleteAllDataBtn.addEventListener('click', async () => {
          const currentTimestamp = localStorage.getItem(deletionTimestampKey);

          if (currentTimestamp && parseInt(currentTimestamp, 10) > Date.now()) {
            // Jika sedang countdown, tanya untuk batal
            const confirmCancel = await showMessageBox(
              "Batalkan Penghapusan?",
              "Data dijadwalkan untuk dihapus. Apakah Anda ingin membatalkan penghapusan otomatis ini?",
              true // Tampilkan tombol Ya/Batal
            );
            if (confirmCancel.confirmed) { // Jika klik Ya (batalkan penghapusan)
              cancelScheduledDeletion();
            } else {
               showMessageBox("Info", "Penghapusan otomatis tetap berjalan.", false); // Klik Batal (jangan batalkan)
            }
          } else {
            // Jika tidak sedang countdown, tanya untuk jadwal hapus
            const confirmSchedule = await showMessageBox(
              "Hapus Semua Data?",
              "Semua data input, rencana baru, aktif, dan selesai akan dihapus permanen setelah 24 jam. Anda dapat membatalkannya sebelum waktu habis. Data 'Rencana Trading Selesai' akan diunduh otomatis sebelum dihapus. Yakin ingin melanjutkan?",
              true // Tampilkan tombol Ya/Batal
            );
            if (confirmSchedule.confirmed) { // Jika klik Ya (jadwalkan)
              scheduleDeletion();
            } else {
              showMessageBox("Dibatalkan", "Sukses, Data anda berhasil di batalkan.", false); // Klik Batal (jangan jadwalkan)
            }
          }
        });
      }
      // --- AKHIR TAMBAHAN KODE INISIALISASI DAN LISTENER ---

      // ... (sisa kode event listener Anda seperti DOMContentLoaded, calculateAllBtn, dll) ...
      // Firebase imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        collection,
        query,
        onSnapshot,
        addDoc,
        deleteDoc,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
      import {
        getStorage,
        ref,
        uploadBytes,
        getDownloadURL,
        deleteObject,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

      // Global Firebase variables
      let app;
      let db;
      let auth;
      let storage;
      let userId = "anonymous"; // Default to anonymous

      // Initialize Firebase
      const firebaseConfig = JSON.parse(
        typeof __firebase_config !== "undefined" ? __firebase_config : "{}"
      );
      const appId =
        typeof __app_id !== "undefined" ? __app_id : "default-app-id";

      // Global variables for data storage
      let calculatedPlansData = []; // New: for plans that are calculated but not yet running
      let runningPlansData = []; //
      let executedPlansData = [];
      let limitNotificationMessage = "";
      let monthlyPercentageLineChart = null;

      // ... (existing constants like PENDING_PIPS_RULES, MAX_ACTIVE_RISK_PERCENT, etc.) ...
      // --- ATURAN BARU: Batas Risiko & Pending Pips ---
      const PENDING_PIPS_RULES = {};
      // PERUBAHAN: Memperbarui nilai konstanta batas risiko sesuai permintaan pengguna
      const MAX_ACTIVE_RISK_PERCENT = 3.6; // Batas risiko aktif (sebagai persentase positif)
      const DAILY_LOSS_LIMIT = -4; // Batas kerugian harian (sebagai persentase negatif)
      const MONTHLY_LOSS_LIMIT = -5; // Batas kerugian bulanan (sebagai persentase negatif)
      const OVERALL_MAX_LOSS_LIMIT = -7; // Batas kerugian maksimal keseluruhan (sebagai persentase negatif)
      const MAX_RISK_PER_TRADE = 0.4;
      const ASSET_SL_LIMITS = {
        "XAU/USD": 250,   // Batas 300 pips untuk Gold
        "NDX100": 2500    // Batas 2500 points untuk Nasdaq
      };

      // --- DATA ASET & NILAI PIPS/POINTS ---
      // Menambahkan properti 'minLotIncrement' untuk setiap aset
      const assetValues = {
        "EUR/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/DKK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "DKK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/GBP": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "GBP",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CHF/JPY": {
          decimals: 3,
          pipValue: 6.78,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/AUD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "AUD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/AUD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "AUD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/MXN": {
          decimals: 5,
          pipValue: 0.5,
          contractSize: 100000,
          type: "forexExotic",
          currency: "MXN",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/ZAR": {
          decimals: 5,
          pipValue: 0.05,
          contractSize: 100000,
          type: "forexExotic",
          currency: "ZAR",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/HKD": {
          decimals: 5,
          pipValue: 1.28,
          contractSize: 100000,
          type: "forexExotic",
          currency: "HKD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CHF/SGD": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/PLN": {
          decimals: 5,
          pipValue: 0.25,
          contractSize: 100000,
          type: "forexExotic",
          currency: "PLN",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/HUF": {
          decimals: 5,
          pipValue: 0.003,
          contractSize: 100000,
          type: "forexExotic",
          currency: "HUF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CZK": {
          decimals: 5,
          pipValue: 0.04,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CZK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "XAU/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 100,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "XAG/USD": {
          decimals: 3,
          pipValue: 50.0,
          contractSize: 5000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "WTI/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 1000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "BRENT/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 1000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NATGAS/USD": {
          decimals: 3,
          pipValue: 10.0,
          contractSize: 10000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "COPPER/USD": {
          decimals: 4,
          pipValue: 25000.0,
          contractSize: 25000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "PLATINUM/USD": {
          decimals: 2,
          pipValue: 50.0,
          contractSize: 50,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        // --- LETAKKAN SELURUH BLOK KODE BARU DI SINI ---
        SPX500: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        NASDAQ: {
          decimals: 2,
          pipValue: 0.1,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        DJI30: {
          decimals: 2,
          pipValue: 0.5,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        GER40: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "EUR",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        JP225: {
          decimals: 2,
          pipValue: 100.0,
          contractSize: 100,
          type: "index",
          currency: "JPY",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        FTSE100: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "GBP",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        STX50: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "EUR",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
      };

      // --- GLOBAL VARIABLES DOM ELEMENTS ---
      let rowCounter = 0;
      const inputRowsContainer = document.getElementById("inputRowsContainer");
      const calculatedPlansBody = document.getElementById(
        "calculatedPlansBody"
      ); // New element
      const runningPlansBody = document.getElementById("runningPlansBody"); // Renamed from activePlansData
      const executedPlansBody = document.getElementById("executedPlansBody");
      const calculationDetailsContainer =
        document.getElementById("calculationDetails");
      const dailyChartDateTime = document.getElementById("dailyChartDateTime");
      const deleteAndExportDataBtn = document.getElementById(
        "deleteAndExportDataBtn"
      );
      const uploadDataBtn = document.getElementById("uploadDataBtn");
      const photoCarousel = document.getElementById("photoCarousel"); // New carousel container
      const photoSlides = document.getElementById("photoSlides"); // New slides container
      const prevPhotoBtn = document.getElementById("prevPhotoBtn"); // New prev button
      const nextPhotoBtn = document.getElementById("nextPhotoBtn"); // New next button
      const photoCounter = document.getElementById("photoCounter"); // New photo counter
      const imageInput = document.getElementById("imageInput");
      const imageCanvas = document.getElementById("imageCanvas");
      const ctx = imageCanvas.getContext("2d");
      const photoUploadModal = document.getElementById("photoUploadModal");
      const cropAndSaveBtn = document.getElementById("cropAndSaveBtn");
      const cancelPhotoBtn = document.getElementById("cancelPhotoBtn");
      let currentImageToCrop = null; // Stores the image currently being cropped
      let userPhotos = []; // Array to store all user photo URLs
      let currentPhotoIndex = 0; // Index of the currently displayed photo
      const MAX_PHOTOS = 8;
      // --- LETAKKAN KODE BARU DI SINI ---
      let bannerPhotos = []; // Array untuk foto banner 16:4
      let currentBannerPhotoIndex = 0;
      const MAX_BANNER_PHOTOS = 5; // Batas jumlah foto banner
      let bannerAutoslideInterval; // Variabel untuk menyimpan interval autoslide
      let currentUploadTarget = "1:1"; // Untuk membedakan target unggahan
      // NEW: Download buttons
      const downloadExecutedExcelBtn = document.getElementById(
        "downloadExecutedExcelBtn"
      );
      const downloadAllExcelBtn = document.getElementById(
        "downloadAllExcelBtn"
      );
      // --- Letakkan di dalam blok document.addEventListener("DOMContentLoaded", async () => { ... }); ---

      // ▼▼▼ KODE BARU 1: PENYUSUN DETAIL LENGKAP & RAPI ▼▼▼
      function buildFullPlanDetailsHtml(plan, indexNumber) {
          const assetData = getAssetData(plan.symbol);
          const timeStr = formatDateAndTimeForExport(plan.entryTime);
          
          // Format Visual Pips
          const visualPending = getVisualPoints(plan.pendingPips, plan.symbol, true).display;
          const visualSL = getVisualPoints(plan.slPips, plan.symbol).display;
          const visualTP = getVisualPoints(plan.tpPips, plan.symbol).display;
          
          // Format R:R
          const rrPips = plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : "N/A";
          const rrPercent = plan.rrPercentage 
              ? `<span class="negative-value">-${formatNumber(plan.rrPercentage.sl, 2)}%</span> : <span class="positive-value">${formatNumber(plan.rrPercentage.tp, 2)}%</span>`
              : "N/A";

          // Style Baris agar rapi
          const rowStyle = "flex justify-between border-b border-gray-300/50 pb-1 mb-1 last:border-0 text-xs";
          const labelStyle = "text-gray-600 font-medium";
          const valStyle = "font-mono text-gray-900 text-right font-semibold";
          const headerStyle = "mt-2 pt-1 border-t border-gray-400/30 font-bold text-gray-400 text-[10px] uppercase tracking-wider";

          return `
          <div class="p-3 bg-gray-50/80 rounded-md border border-gray-200">
              <!-- INFO UTAMA -->
              <div class="${rowStyle}"><span class="${labelStyle}">No.</span> <span class="${valStyle}">${indexNumber}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Aset</span> <span class="${valStyle}">${plan.symbol}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Trade</span> <span class="${valStyle} ${plan.tradeType === 'BUY' ? 'positive-value' : 'negative-value'}">${plan.tradeType}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Balance Akun</span> <span class="${valStyle}">${formatCurrency(plan.balance, "USD")}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Waktu Masuk</span> <span class="${valStyle} text-[10px]">${timeStr}</span></div>
              
              <!-- HARGA -->
              <div class="${headerStyle}">Harga</div>
              <div class="${rowStyle}"><span class="${labelStyle}">Price Now</span> <span class="${valStyle}">${formatNumber(plan.priceNow, assetData.decimals, false)}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Open Price</span> <span class="${valStyle}">${formatNumber(plan.openPrice, assetData.decimals, false)}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">SL Price</span> <span class="${valStyle}">${formatNumber(plan.slPrice, assetData.decimals, false)}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">TP Price</span> <span class="${valStyle}">${formatNumber(plan.tpPrice, assetData.decimals, false)}</span></div>

              <!-- PIPS / POINTS -->
              <div class="${headerStyle}">Pips / Points</div>
              <div class="${rowStyle}"><span class="${labelStyle}">Pending Pips/Points</span> <span class="${valStyle} ${plan.pendingPips >= 0 ? 'positive-value' : 'negative-value'}">${visualPending}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">SL Pips/Points</span> <span class="${valStyle}">${visualSL}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">TP Pips/Points</span> <span class="${valStyle}">${visualTP}</span></div>

              <!-- MANAJEMEN RISIKO -->
              <div class="${headerStyle}">Risk & Reward</div>
              <div class="${rowStyle}"><span class="${labelStyle}">R:R Pips</span> <span class="${valStyle}">${rrPips}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">R:R %</span> <span class="${valStyle}">${rrPercent}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Lot/Units</span> <span class="${valStyle}">${formatNumber(plan.lotSize, 2)}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Nett SL</span> <span class="${valStyle} negative-value">${formatCurrency(plan.nettSL, "USD")}</span></div>
              <div class="${rowStyle}"><span class="${labelStyle}">Nett TP</span> <span class="${valStyle} positive-value">${formatCurrency(plan.nettTP, "USD")}</span></div>
              
              <!-- CATATAN -->
              <div class="${headerStyle}">Catatan</div>
              <div class="text-xs italic text-gray-600 bg-gray-100/50 p-2 rounded mt-1 text-left border border-gray-200 text-wrap break-words">
                 ${plan.note || '-'}
              </div>
          </div>
          `;
      }
      // ▲▲▲ AKHIR KODE BARU 1 ▲▲▲
      
      // --- AKHIR TAMBAHAN Listener Input File ---

      // ... (sisa kode event listener Anda seperti DOMContentLoaded, calculateAllBtn, dll) ...

      let scrollObserver; // Variabel global untuk instance IntersectionObserver
      // --- LETAKKAN KODE BARU DI SINI ---
      let currentCalendarDate = new Date();
      const calendarBody = document.getElementById("calendarBody");
      const monthYearDisplay = document.getElementById("monthYearDisplay");
      const prevMonthBtn = document.getElementById("prevMonthBtn");
      const nextMonthBtn = document.getElementById("nextMonthBtn");
      let dailyLineChart = null,
        monthlyBarChart = null,
        assetPieChart = null,
        overallPercentageCumulativeChart = null,
        overallBalanceCumulativeChart = null,
        overallPipsCumulativeChart = null,
        tradeFrequencyChart = null;
      let combinedBarChart = null;
      let balanceFrequencyChart = null,
        percentageFrequencyChart = null,
        pipsFrequencyChart = null;
      let executionFrequencyChart = null;
      let assetExecutionCountChart = null; // <-- TAMBAHKAN BARIS INI
      let outcomeRadarChart = null;
      let combinedCumulativeChart = null;
      let ghostEquityChart = null; // <-- Tambahkan ini

     // ... (Kode handleActionClick yang lama diganti/ditambah bagian ini) ...

      const handleActionClick = async (event) => {
         // ▼▼▼ LOGIKA BARU: HANDLER TOMBOL FOTO ▼▼▼
         const photoBtn = event.target.closest("button[data-action]");
         if (photoBtn) {
             const action = photoBtn.dataset.action;
             const entryTime = photoBtn.dataset.entryTime;
             
             if (action === "upload-photo") {
                 // Trigger input file tersembunyi
                 const fileInput = document.getElementById("planPhotoInput");
                 fileInput.dataset.targetEntryTime = entryTime;
                 fileInput.click();
                 const planPhotoInput = document.getElementById("planPhotoInput");
      if (planPhotoInput) {
          planPhotoInput.addEventListener("change", async (e) => {
              const file = e.target.files[0];
              const targetEntryTime = e.target.dataset.targetEntryTime;
              
              if (!file || !targetEntryTime) return;

              // Kompresi Gambar sederhana menggunakan Canvas agar tidak memberatkan LocalStorage
              const reader = new FileReader();
              reader.onload = (event) => {
                  const img = new Image();
                  img.onload = () => {
                      const canvas = document.createElement("canvas");
                      const ctx = canvas.getContext("2d");
                      
                      // Max dimensi 800px untuk hemat memori
                      const MAX_SIZE = 800;
                      let width = img.width;
                      let height = img.height;

                      if (width > height) {
                          if (width > MAX_SIZE) {
                              height *= MAX_SIZE / width;
                              width = MAX_SIZE;
                          }
                      } else {
                          if (height > MAX_SIZE) {
                              width *= MAX_SIZE / height;
                              height = MAX_SIZE;
                          }
                      }

                      canvas.width = width;
                      canvas.height = height;
                      ctx.drawImage(img, 0, 0, width, height);

                      // Konversi ke Base64 (JPEG quality 0.7)
                      const dataUrl = canvas.toDataURL("image/jpeg", 0.7);

                      // Simpan ke data plan
                      const planIndex = calculatedPlansData.findIndex(p => p.entryTime === targetEntryTime);
                      if (planIndex !== -1) {
                          calculatedPlansData[planIndex].photoUrl = dataUrl;
                          
                          // Simpan ke database (background process)
                          savePhotoToDatabase(file, planIndex);
                          
                          // Simpan state terbaru ke LocalStorage agar tidak hilang jika user refresh manual
                          saveDataToLocalStorage(); 

                          // Update tampilan tabel
                          renderCalculatedPlans();

                          showMessageBox("Sukses", "Foto berhasil diunggah.", false);
                      }
                  };
                  img.src = event.target.result;
              };
              reader.readAsDataURL(file);
              
              // Reset input
              e.target.value = "";
          });
      }
                 return;
             } else if (action === "view-photo") {
                 // Cari plan di semua array
                 const plan = calculatedPlansData.find(p => p.entryTime === entryTime) ||
                              runningPlansData.find(p => p.entryTime === entryTime) ||
                              executedPlansData.find(p => p.entryTime === entryTime);
                 
                 if (plan && plan.images.length > 0) {
                     // Tampilkan Modal Preview
                     const modalHtml = `
                        <div class="flex justify-center items-center bg-black/90 p-2 rounded">
                            <img src="https://leodra.fiqrianandahakin.my.id/uploads/${plan.images[0].filename}" class="max-w-full max-h-[80vh] object-contain rounded border border-gray-600 shadow-lg">
                        </div>
                     `;
                     showMessageBox("Pratinjau Foto", modalHtml, false);
                 }
                 return;
             }
         }
         // ▲▲▲ AKHIR LOGIKA FOTO ▲▲▲

         const btn = event.target.closest(".action-button-small");
         if (!btn) return;

         const { fromSection, outcome, entryTime, id } = btn.dataset;
         
         // --- RENCANA BARU ---
         if (fromSection === "calculated") {
             const plan = calculatedPlansData.find(p => p.entryTime === entryTime);
             
             if (!plan) return;

             // Bangun Detail HTML
             let detailsHtml = "";
             if (typeof buildFullPlanDetailsHtml === 'function') {
                 const idx = calculatedPlansData.indexOf(plan) + 1;
                 detailsHtml = buildFullPlanDetailsHtml(plan, idx);
             }

             if (outcome === "Running") {
                 // ▼▼▼ VALIDASI WAJIB FOTO ▼▼▼
                 if (!plan.images || plan.images.length === 0) {
                     showMessageBox("Foto Wajib", "<p class='text-center text-red-600'>Anda <strong>harus mengunggah foto/gambar analisis</strong> sebelum melanjutkan ke Rencana Trading Aktif.</p>", false);
                     return; // STOP PROSES
                 }
                 // ▲▲▲ AKHIR VALIDASI ▲▲▲

                 const message = `${detailsHtml}<p class="text-center mt-3 text-blue-600 font-bold">Lanjutkan ke Rencana Trading Aktif?</p>`;
                 const confirmRun = await showMessageBox("Konfirmasi: Set Running", message, true);
                 
                 if (confirmRun.confirmed) {
                     setRunning(id, entryTime);
                 }
             } 
             else if (outcome === "Hapus") {
                 let message = "Data rencana trading ini akan dihapus permanen. Lanjutkan?";
                 if (detailsHtml) {
                     message = `${detailsHtml}<p class="text-center mt-3 text-red-600 font-bold">YAKIN HAPUS?</p>`;
                 }
                 const confirmDelete = await showMessageBox("Hapus Rencana?", message, true);
                 
                 if (confirmDelete.confirmed) {
                     // 1. Coba Hapus dari Backend (API)
                     try {
                        if (id && !id.startsWith('local-')) { // Hanya hapus di server jika ID valid dari server
                            await fetch(`https://leodra.fiqrianandahakin.my.id/api/trade/${id}`, {
                                method: "DELETE",
                                headers: {
                                    "Content-Type": "application/json",
                                    Authorization: `Bearer ${localStorage.getItem("token")}`,
                                },
                            });
                        }
                     } catch (err) {
                         console.error("Gagal menghapus dari server:", err);
                     }

                     // 2. Hapus dari Data Lokal (UI)
                     const index = calculatedPlansData.findIndex(p => p.entryTime === entryTime);
                     if (index !== -1) {
                         calculatedPlansData.splice(index, 1);
                         saveDataToLocalStorage();
                         renderCalculatedPlans();
                     }
                     
                     showMessageBox("Berhasil", "Rencana trading berhasil dihapus.", false);
                 }
             }
         }
         // ... (Kode untuk 'running' dan 'executed' di bawahnya TETAP SAMA) ...
         else if (fromSection === "running") {
             // ... (kode lama handleActionClick bagian running) ...
             // Pastikan untuk copy-paste bagian running dari kode sebelumnya
             // Gunakan kode handleActionClick yang Anda miliki, hanya sisipkan logika Foto di atas
             // dan validasi set running di atas.
             // Agar tidak merusak kode Anda, saya hanya memberikan pointer di mana menyelipkannya.
             // Untuk kemudahan, di bawah ini saya sertakan fungsi lengkap yang sudah digabung.
             handleRunningAndExecutedActions(btn, runningPlansData, executedPlansData);
         }
         else if (fromSection === "executed" && outcome === "Revisi") {
            revertExecutedPlan(id, entryTime);
         }
      };

      // FUNGSI BANTUAN UNTUK MEMPERSINGKAT handleActionClick (Opsional, untuk kerapihan)
      async function handleRunningAndExecutedActions(btn, runningData, executedData) {
            const { fromSection, outcome, entryTime, id } = btn.dataset;
            
            if (fromSection === "running") {
                const planIndex = runningData.findIndex(p => p.entryTime === entryTime);
                const plan = runningData[planIndex];
                if (!plan) return;

                const detailsHtml = buildFullPlanDetailsHtml(plan, planIndex + 1);
                let actionMessage = "";
                let isEditable = false;
                let title = `Konfirmasi: ${outcome}`;

                if (outcome === "Edit") {
                    actionMessage = "Kembalikan data ini ke form input untuk diedit?";
                    title = "Edit Data";
                } else if (outcome === "Take Profit") {
                    actionMessage = "Selesaikan trade dengan hasil <strong class='positive-value text-lg'>PROFIT</strong>?";
                    isEditable = true; 
                } else if (outcome === "Stop Loss") {
                    actionMessage = "Selesaikan trade dengan hasil <strong class='negative-value text-lg'>LOSS</strong>?";
                    isEditable = true; 
                } else if (outcome === "Tes") {
                    actionMessage = "Tandai sebagai data <strong>TEST</strong> (Selesai)?";
                } else if (outcome === "Cancel") {
                    actionMessage = "<strong>BATALKAN</strong> trade aktif ini? (Data dihapus/diarsipkan)";
                }

                const confirmAction = await showMessageBox(title, `${detailsHtml}<div class="mt-3 p-2 bg-white/50 border border-gray-200 rounded text-center text-sm text-gray-800 font-bold">${actionMessage}</div>`, true, { editableNettValues: isEditable, plan: plan });

                if (confirmAction.confirmed) {
                    if (outcome === "Edit") {
                        editRunningPlan(id, entryTime);
                    } else {
                        completeTrade(id, entryTime, outcome, fromSection, confirmAction);
                    }
                }
            } 
      }

      // ▼▼▼ PERBAIKAN: LISTENER INPUT FOTO (Diletakkan di luar handleActionClick) ▼▼▼
const planPhotoInputMain = document.getElementById("planPhotoInput");
if (planPhotoInputMain) {
    planPhotoInputMain.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        // Ambil ID Unik (Entry Time) dari dataset input
        const targetEntryTime = e.target.dataset.targetEntryTime;

        if (!file || !targetEntryTime) return;

        // Kompresi Gambar menggunakan Canvas
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");

                // Max dimensi 800px
                const MAX_SIZE = 800;
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > MAX_SIZE) {
                        height *= MAX_SIZE / width;
                        width = MAX_SIZE;
                    }
                } else {
                    if (height > MAX_SIZE) {
                        width *= MAX_SIZE / height;
                        height = MAX_SIZE;
                    }
                }

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);

                // Konversi ke Base64
                const dataUrl = canvas.toDataURL("image/jpeg", 0.7);

                // Cari Plan di Array Calculated
                const planIndex = calculatedPlansData.findIndex(p => p.entryTime === targetEntryTime);
                
                if (planIndex !== -1) {
                    // PERBAIKAN LOGIC DATA:
                    // Simpan ke array 'images' agar terbaca oleh renderPlans
                    if (!calculatedPlansData[planIndex].images) {
                        calculatedPlansData[planIndex].images = [];
                    }
                    
                    // Kita simpan objek dengan properti 'url' untuk preview lokal
                    calculatedPlansData[planIndex].images = [{ 
                        filename: 'local-preview', 
                        url: dataUrl 
                    }];

                    // Simpan ke Database (Background)
                    savePhotoToDatabase(file, planIndex);

                    // Simpan LocalStorage & Render Ulang
                    saveDataToLocalStorage();
                    renderCalculatedPlans();

                    showMessageBox("Sukses", "Foto berhasil diunggah.", false);
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);

        // Reset input agar bisa upload file yang sama jika perlu
        e.target.value = "";
    });
}
// ▲▲▲ AKHIR PERBAIKAN LISTENER ▲▲▲
      // ▲▲▲ AKHIR LISTENER FILE ▲▲▲

      async function savePhotoToDatabase(image, planIndex) {
        try {
          const formData = new FormData();
          formData.append("image", image);
          formData.append("tradeId", calculatedPlansData[planIndex].id);
          
          await fetch("https://leodra.fiqrianandahakin.my.id/api/trade/upload", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: formData,
          });
          
          // location.reload(); DIHAPUS agar tidak refresh
          console.log("Foto berhasil disimpan ke database.");

        } catch (error) {
          console.error("Error saving photo to database:", error);
        }
      }

      // --- AKHIR DARI FUNGSI handleActionClick ---

      // Pasang listener ke kedua tabel
      calculatedPlansBody.addEventListener("click", handleActionClick);
      runningPlansBody.addEventListener("click", handleActionClick);

      // ▼▼▼ TAMBAHKAN EVENT LISTENER INI ▼▼▼
      executedPlansBody.addEventListener("click", handleActionClick);
      // ▲▲▲ AKHIR TAMBAHAN ▲▲▲
      // --- HELPER FUNCTIONS ---
      // Modified formatNumber to control thousands grouping
      const formatNumber = (value, decimals = 2, useGrouping = true) => {
        if (isNaN(value) || value === null || !isFinite(value)) return "N/A";
        const num = parseFloat(value);
        if (useGrouping) {
          // Use toLocaleString for grouping (e.g., for currency, balance, etc.)
          return num.toLocaleString("en-US", {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
          });
        } else {
          // Use toFixed for raw numerical string with specified decimals, no grouping
          return num.toFixed(decimals);
        }
      };

      const formatCurrency = (value, currency = "USD") =>
        isNaN(value) || value === null || !isFinite(value)
          ? "N/A"
          : parseFloat(value).toLocaleString("en-US", {
              style: "currency",
              currency: currency,
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            });
      const getColoredValueHtml = (value, isCurrency = false, decimals = 2) => {
        if (value === "N/A" || isNaN(value) || !isFinite(value))
          return `<span class="text-black">N/A</span>`;
        const formattedValue = isCurrency
          ? formatCurrency(value, "USD")
          : formatNumber(value, decimals);
        const colorClass = value >= 0 ? "text-black" : "text-red-500";
        return `<span class="${colorClass}">${formattedValue}</span>`;
      };

      // --- TAMBAHKAN FUNGSI HELPER BARU INI ---
      /**
       * Membuat string HTML untuk menampilkan detail plan dalam format grid.
       * @param {Object} plan - Objek data plan.
       * @returns {string} String HTML.
       */
      function buildDetailsHtml(plan) {
          if (!plan) return '<p>Data tidak ditemukan.</p>';
          const currentAssetData = plan.assetData || getAssetData(plan.symbol);
          const rrPipsFormatted = plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1)}` : 'N/A';
          let rrPercentageHtml = '<span class="neutral-value">N/A</span>';
          if (plan.rrPercentage && typeof plan.rrPercentage.sl !== 'undefined') {
              rrPercentageHtml = `<span class="negative-value">-${formatNumber(plan.rrPercentage.sl, 2)}%</span> : <span class="${plan.rrPercentage.tp >= 0 ? 'positive-value' : 'negative-value'}">${formatNumber(plan.rrPercentage.tp, 2)}%</span>`;
          }
          const pendingPipsDisplay = getVisualPoints(plan.pendingPips, plan.symbol).display;
          const slPipsDisplay = getVisualPoints(plan.slPips, plan.symbol).display;
          const tpPipsDisplay = getVisualPoints(plan.tpPips, plan.symbol).display;

          return `
              <div class="text-left text-xs space-y-1 bg-gray-50 p-4 rounded-lg border border-gray-200 grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                  <p><strong>Aset:</strong></p> <p>${plan.symbol}</p>
                  <p><strong>Tipe Trade:</strong></p> <p><span class="${plan.tradeType === 'BUY' ? 'positive-value' : 'negative-value'} font-semibold">${plan.tradeType}</span></p>
                  <p><strong>Balance Akun:</strong></p> <p>${formatCurrency(plan.balance, "USD")}</p>
                  <p><strong>Waktu Masuk:</strong></p> <p>${formatDateAndTimeForExport(plan.entryTime)}</p>
                  <p><strong>Open Price:</strong></p> <p>${formatNumber(plan.openPrice, currentAssetData.decimals, false)}</p>
                  <p><strong>SL Price:</strong></p> <p>${formatNumber(plan.slPrice, currentAssetData.decimals, false)}</p>
                  <p><strong>TP Price:</strong></p> <p>${formatNumber(plan.tpPrice, currentAssetData.decimals, false)}</p>
                  <p><strong>Pending Pips:</strong></p> <p class="${plan.pendingPips >= 0 ? 'positive-value' : 'negative-value'}">${pendingPipsDisplay}</p>
                  <p><strong>SL Pips:</strong></p> <p class="neutral-value">${slPipsDisplay}</p>
                  <p><strong>TP Pips:</strong></p> <p class="positive-value">${tpPipsDisplay}</p>
                  <p><strong>R:R Pips:</strong></p> <p>${rrPipsFormatted}</p>
                  <p><strong>R:R %:</strong></p> <div>${rrPercentageHtml}</div>
                  <p><strong>Lot/Units:</strong></p> <p>${formatNumber(plan.lotSize, 2)}</p>
                  <p><strong>Nett SL:</strong></p> <p class="negative-value">${formatCurrency(plan.nettSL, "USD")}</p>
                  <p><strong>Nett TP:</strong></p> <p class="${plan.nettTP >= 0 ? 'positive-value' : 'negative-value'}">${formatCurrency(plan.nettTP, "USD")}</p>
                  <p><strong>Catatan:</strong></p> <p>${plan.note || '-'}</p>
                  ${plan.outcome ? `<p><strong>Hasil:</strong></p> <p>${plan.outcome}</p>` : ''}
                  ${plan.timestamp ? `<p><strong>Waktu Keluar:</strong></p> <p>${formatDateAndTimeForExport(plan.timestamp)}</p>` : ''}
              </div>
              <hr class="my-4">
          `;
      }
      // --- AKHIR DARI FUNGSI HELPER BARU ---
      function updateDateTime() {
        const now = new Date();
        const dateOptions = {
          weekday: "long",
          year: "numeric",
          month: "short",
          day: "numeric",
        };
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: true,
        };
        const fullDateTimeString = `${now.toLocaleDateString(
          "id-ID",
          dateOptions
        )} ${now.toLocaleTimeString("id-ID", timeOptions)}`;

        document.getElementById("currentDate").textContent =
          now.toLocaleDateString("id-ID", dateOptions);
        document.getElementById("currentTime").textContent =
          now.toLocaleTimeString("id-ID", timeOptions);
        document.getElementById("currentDateHeader").textContent =
          now.toLocaleDateString("id-ID", dateOptions);
        document.getElementById("currentTimeHeader").textContent =
          now.toLocaleTimeString("id-ID", timeOptions);
        if (dailyChartDateTime)
          dailyChartDateTime.textContent = `(${fullDateTimeString})`;

        // Update date/time in mobile menu
        const mobileMenuDateTime =
          document.getElementById("mobileMenuDateTime");
        if (mobileMenuDateTime) {
          mobileMenuDateTime.textContent = fullDateTimeString;
        }
      }
      const getRandomColor = (index) =>
        `hsl(${(index * 137.508) % 360}, 70%, 50%)`;

      // --- HELPER FUNCTIONS ---
      // ... (existing helper functions like formatNumber, formatCurrency, getColoredValueHtml, updateDateTime, getRandomColor, getStepValue, getVisualPoints, showModal, hideModal, showMessageBox, updateActivePlansSummary) ...

      // PERBAIKAN: Memperbarui fungsi formatDuration untuk menampilkan "N/A" jika durasi 0
      function formatDuration(milliseconds) {
        if (isNaN(milliseconds) || milliseconds <= 0) return "N/A";
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
          return `${days} Hari`;
        } else if (hours > 0) {
          return `${hours} Jam`;
        } else if (minutes > 0) {
          return `${minutes} Menit`;
        } else if (seconds > 0) {
          return `${seconds} Detik`;
        }
        return "< 1 Detik"; // Default jika kurang dari 1 detik tapi lebih dari 0
      }

      /**
       * FUNGSI BARU: Memformat tanggal dan waktu ke dalam format dua baris HTML.
       * @param {string} isoString - Timestamp dalam format ISO.
       * @returns {string} String HTML dengan tanggal di atas dan waktu di bawah.
       */
      function formatDateAndTime(isoString) {
        if (!isoString || isNaN(new Date(isoString).getTime())) {
          return "N/A";
        }
        const date = new Date(isoString);
        // Opsi untuk mendapatkan format DD/MM/YYYY
        const dateOptions = {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
        };
        // Opsi untuk mendapatkan format HH:MM:SS
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        };

        const formattedDate = date.toLocaleDateString("id-ID", dateOptions);
        // Mengganti titik dengan titik dua untuk konsistensi
        const formattedTime = date
          .toLocaleTimeString("id-ID", timeOptions)
          .replace(/\./g, ":");

        // Mengembalikan HTML dengan dua baris: tanggal di atas, waktu di bawah
        return `<div class="flex flex-col items-center">
                      <span class="text-xs text-gray-500">${formattedDate}</span>
                      <span class="font-medium">${formattedTime}</span>
                  </div>`;
      }
      // ... kode fungsi formatDateAndTime yang sudah ada ...

      /**
       * FUNGSI BARU UNTUK EKSPOR: Memformat tanggal dan waktu menjadi satu baris string.
       * @param {string} isoString - Timestamp dalam format ISO.
       * @returns {string} String yang diformat 'DD/MM/YYYY JJ:MM:DD'.
       */
      function formatDateAndTimeForExport(isoString) {
        if (!isoString || isNaN(new Date(isoString).getTime())) {
          return "N/A";
        }
        const date = new Date(isoString);
        const dateOptions = {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
        };
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        };

        const formattedDate = date.toLocaleDateString("id-ID", dateOptions);
        const formattedTime = date
          .toLocaleTimeString("id-ID", timeOptions)
          .replace(/\./g, ":");

        return `${formattedDate} ${formattedTime}`;
      }

      // ... kode fungsi lainnya setelah ini ...

      // ... kode fungsi lainnya setelah ini ...

      /**
       * Mengambil semua data statistik yang terlihat di UI untuk keperluan ekspor.
       * Fungsi ini memastikan data yang diekspor sama persis dengan yang ditampilkan.
       * @returns {{summaryStats: Array<Array<string>>, riskStats: Array<Array<string>>}}
       */
      function getDetailedStatisticsForExport() {
        // Mengambil data dari bagian Statistik Ringkasan Keseluruhan
        const summaryStats = [
          [
            "Total Trade Selesai",
            document.getElementById("totalSettledTradesSummary").textContent,
          ],
          [
            "Probabilitas",
            document.getElementById("probabilitySummary").textContent,
          ],
          [
            "Total Pips/Points",
            document.getElementById("totalPipsSummary").textContent,
          ],
          [
            "Rata-rata % per Trade",
            document.getElementById("avgPercentagePerTradeSummary").textContent,
          ],
          [
            "Persentase Harian",
            document.getElementById("dailyPercentageSummary").textContent,
          ],
          [
            "Persentase Bulanan",
            document.getElementById("monthlyPercentageSummary").textContent,
          ],
          [
            "Persentase Tahunan",
            document.getElementById("yearlyPercentageSummary").textContent,
          ],
          [
            "Persentase Keseluruhan",
            document.getElementById("overallPercentageSummary").textContent,
          ],
          [
            "Saldo Akun Akhir",
            document.getElementById("finalBalanceSummary").textContent,
          ],
          [
            "Waktu Bergabung",
            document.getElementById("joinTimeSummary").textContent,
          ],
          [
            "Drawdown Saldo",
            `${
              document.getElementById("balanceDrawdownSummary").textContent
            } (${
              document.getElementById("balanceDrawdownSummaryPeriod")
                .textContent
            })`,
          ],
          [
            "Maksimum Drawdown %",
            `${
              document.getElementById("overallMaxDrawdownPercentage")
                .textContent
            } (${
              document.getElementById("overallMaxDrawdownPercentagePeriod")
                .textContent
            })`,
          ],
        ];

        // Mengambil data dari bagian Statistik Risiko dan Imbalan
        const riskStats = [
          [
            "Rata-rata Risiko dan Imbalan",
            document.getElementById("avgRiskReward").textContent,
          ],
          [
            "Rata-rata Sinyal Diselesaikan/Minggu",
            document.getElementById("avgSignalSettledWeek").textContent,
          ],
          [
            "Rata-rata Sinyal Diselesaikan/Bulan",
            document.getElementById("avgSignalSettledMonth").textContent,
          ],
          [
            "Rata-rata Periode Penahanan",
            document.getElementById("avgHoldingPeriod").textContent,
          ],
          [
            "Periode Penahanan Maks",
            document.getElementById("maxHoldingPeriod").textContent,
          ],
          [
            "Rata-rata Pips",
            document.getElementById("averagePips").textContent,
          ],
          [
            "Rata-rata TP Pips",
            document.getElementById("avgTpPips").textContent,
          ],
          ["Max TP Pips", document.getElementById("maxTpPips").textContent],
          [
            "Rata-rata SL Pips",
            document.getElementById("avgSlPips").textContent,
          ],
          ["Max SL Pips", document.getElementById("maxSlPips").textContent],
          [
            "Keuntungan Beruntun",
            `${document.getElementById("consecutiveProfit").textContent} (${
              document.getElementById("consecutiveProfitPeriod").textContent
            })`,
          ],
          [
            "Kerugian Beruntun",
            `${document.getElementById("consecutiveLoss").textContent} (${
              document.getElementById("consecutiveLossPeriod").textContent
            })`,
          ],
          [
            "Laba Kotor (Total TP)",
            document.getElementById("grossProfit").textContent,
          ],
          [
            "Laba Kotor (Total SL)",
            document.getElementById("grossLoss").textContent,
          ],
          ["Laba Bersih", document.getElementById("netProfit").textContent], // <-- DATA YANG HILANG SEKARANG DITAMBAHKAN
          [
            "Balance Drawdown Maximal",
            `${document.getElementById("maxBalanceDrawdown").textContent} (${
              document.getElementById("maxBalanceDrawdownPeriod").textContent
            })`,
          ],
          [
            "Balance Drawdown Monthly",
            `${
              document.getElementById("monthlyBalanceDrawdown").textContent
            } (${
              document.getElementById("monthlyBalanceDrawdownPeriod")
                .textContent
            })`,
          ],
          [
            "Maksimum Drawdown Bulanan %",
            `${
              document.getElementById("monthlyMaxDrawdownPercentage")
                .textContent
            } (${
              document.getElementById("monthlyMaxDrawdownPercentagePeriod")
                .textContent
            })`,
          ],
        ];

        return { summaryStats, riskStats };
      }
      // Fungsi pembantu baru untuk mengatur atribut step
      function getStepValue(decimals) {
        if (decimals <= 0) return "1"; // Untuk bilangan bulat
        return "0." + "0".repeat(decimals - 1) + "1";
      }

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN: Fungsi ini sekarang memiliki aturan khusus untuk XAG/USD.
       * Untuk XAG/USD, nilai pips visual akan dikalikan 100 (menambahkan satu angka).
       * Untuk aset lain, tetap dikalikan 10.
       * @param {number} pipsValue The precise pips value (e.g., 12.5).
       * @param {string} symbol The asset symbol (e.g., 'XAG/USD').
       * @param {boolean} isForExecutedTable - Flag to determine display format.
       * @returns {{display: string, forCalc: number}} An object with the display string and the number for calculation.
       */
      function getVisualPoints(pipsValue, symbol, isForExecutedTable = false) {
        // 1. Tangani input yang tidak valid atau nol
        if (pipsValue === 0) {
          return { display: "0", forCalc: 0 };
        }
        if (isNaN(pipsValue) || pipsValue === null || !isFinite(pipsValue)) {
          return { display: "N/A", forCalc: 0 };
        }

        // 2. Ambil nilai absolut
        const floatValue = Math.abs(parseFloat(pipsValue));
        let finalValue;

        // 3. LOGIKA BARU: Terapkan aturan khusus untuk XAG/USD
        if (symbol === "XAG/USD") {
          // Untuk XAG/USD, kalikan 100 untuk menambahkan satu angka di belakang
          // Contoh: 12.5 -> 1250
          finalValue = Math.round(floatValue * 100);
        } else {
          // Untuk semua aset lainnya, gunakan logika standar (kalikan 10)
          // Contoh: 12.5 -> 125
          finalValue = Math.round(floatValue * 10);
        }

        // 4. Kembalikan nilai yang sudah diformat
        return { display: String(finalValue), forCalc: finalValue };
      }

      // Helper functions for modals
      function showModal(modalElement) {
        modalElement.classList.add("show");
      }
      function hideModal(modalElement) {
        modalElement.classList.remove("show");
      }

      function showMessageBox(title, message, isConfirm = false, options = {}) {
        return new Promise((resolve) => {
          const existingModal = document.querySelector(".message-box-modal");
          if (existingModal) existingModal.remove();

          const confirmText = options.customButtonText || "Ya"; 

          let editableFieldsHtml = "";
          if (options.editableNettValues && options.plan) {
            const plan = options.plan;
            const assetData = getAssetData(plan.symbol);
            const stepValue = getStepValue(assetData.decimals);
            
            // Note: Placeholder Nett SL ditampilkan positif agar user tidak bingung, tapi input akan diproses
            const displayPlaceHolderSL = Math.abs(plan.nettSL);

            editableFieldsHtml = `
              <div class="mt-4 pt-4 border-t border-gray-300">
                  <h4 class="text-sm font-semibold text-center mb-3">Edit Manual Hasil Akhir (Opsional)</h4>
                  <p class="text-[10px] text-gray-500 text-center mb-2">Cukup masukkan angka positif, sistem otomatis menyesuaikan +/-</p>
                  <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs">
                      <div><label class="block mb-1 font-medium">TP Price</label><input type="number" id="editedTpPrice" step="${stepValue}" class="w-full input-field" placeholder="${formatNumber(plan.tpPrice, assetData.decimals, false)}"></div>
                      <div><label class="block mb-1 font-medium text-red-600">Nett SL ($)</label><input type="number" id="editedNettSL" step="0.01" min="0" class="w-full input-field" placeholder="${formatNumber(displayPlaceHolderSL, 2, false)}"></div>
                      <div><label class="block mb-1 font-medium text-green-600">Nett TP ($)</label><input type="number" id="editedNettTP" step="0.01" class="w-full input-field" placeholder="${formatNumber(plan.nettTP, 2, false)}"></div>
                  </div>
              </div>`;
          }

          const modal = document.createElement("div");
          modal.className = "modal message-box-modal";
          
          modal.innerHTML = `
            <div class="modal-content" style="background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.6); max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 10px 30px rgba(0,0,0,0.15);">
              
              <div class="flex-shrink-0 relative">
                  <button class="modal-close-button" id="closeMessageBoxBtn" style="top: -10px; right: -10px; font-size: 1.5rem;">&times;</button>
                  <h3 class="text-lg font-light text-primary mb-2 text-center border-b border-gray-300/50 pb-2">${title}</h3>
              </div>

              <div class="modal-body-scrollable flex-grow" style="overflow-y: auto; max-height: 70vh; -webkit-overflow-scrolling: touch; padding-right: 5px;">
                <div class="text-gray-800 mb-4 font-light text-sm">${message}</div>
                ${editableFieldsHtml}
              </div>

              <div class="flex-shrink-0 flex justify-end gap-3 mt-4 pt-3 border-t border-gray-300/50">
                ${isConfirm 
                  ? `<button id="cancelMessageBoxBtn" class="action-button bg-gray-500 hover:bg-gray-600 font-light text-white px-4 py-2 rounded shadow-sm">Batal</button>
                     <button id="confirmMessageBoxBtn" class="action-button font-light text-white px-4 py-2 rounded shadow-sm bg-blue-600 hover:bg-blue-700 border-transparent">${confirmText}</button>`
                  : `<button id="okMessageBoxBtn" class="action-button font-light text-white px-4 py-2 rounded shadow-sm">OK</button>`
                }
              </div>

            </div>`;
            
          document.body.appendChild(modal);
          setTimeout(() => showModal(modal), 10);

          const hideAndResolve = (result) => {
            hideModal(modal);
            modal.addEventListener("transitionend", () => modal.remove(), { once: true });
            resolve(result);
          };

          modal.querySelector("#closeMessageBoxBtn")?.addEventListener("click", () => hideAndResolve({ confirmed: false }));
          modal.querySelector("#okMessageBoxBtn")?.addEventListener("click", () => hideAndResolve({ confirmed: true }));
          modal.querySelector("#cancelMessageBoxBtn")?.addEventListener("click", () => hideAndResolve({ confirmed: false }));
          
          modal.querySelector("#confirmMessageBoxBtn")?.addEventListener("click", () => {
            let result = { confirmed: true };
            if (options.editableNettValues) {
              const editedTpPrice = document.getElementById("editedTpPrice").value;
              const editedNettSL = document.getElementById("editedNettSL").value;
              const editedNettTP = document.getElementById("editedNettTP").value;
              
              if (editedTpPrice !== "") result.editedTpPrice = parseFloat(editedTpPrice);
              
              // ▼▼▼ PERBAIKAN UTAMA: Paksa Nett SL jadi NEGATIF ▼▼▼
              if (editedNettSL !== "") {
                  // Math.abs memastikan angka positif, lalu diberi minus (-) di depannya
                  result.editedNettSL = -Math.abs(parseFloat(editedNettSL)); 
              }
              // ▲▲▲

              if (editedNettTP !== "") result.editedNettTP = parseFloat(editedNettTP);
            }
            hideAndResolve(result);
          });
        });
      }
      // ▲▲▲ AKHIR KODE PERBAIKAN 2 ▲▲▲
      // ▲▲▲ AKHIR KODE BARU 2 ▲▲▲
      function updateActivePlansSummary() {
        const summaryContainer = document.getElementById("activePlansSummary");
        // Ambil semua elemen <p> untuk menampilkan nilai
        const totalSlPipsEl = document.getElementById("summaryTotalSlPips");
        const totalTpPipsEl = document.getElementById("summaryTotalTpPips");
        const totalRiskPercentageEl = document.getElementById("summaryTotalRiskPercentage");
        const totalNettSLEl = document.getElementById("summaryTotalNettSL");
        const totalNettTPEl = document.getElementById("summaryTotalNettTP");
        const totalLotEl = document.getElementById("summaryTotalLot"); // Elemen baru untuk Total Lot

        // Pastikan semua elemen ada
        if (!summaryContainer || !totalSlPipsEl || !totalTpPipsEl || !totalRiskPercentageEl || !totalNettSLEl || !totalNettTPEl || !totalLotEl) {
          console.error("Elemen ringkasan rencana aktif tidak ditemukan.");
          return;
        }

        // Cek jika ada data di runningPlansData
        if (runningPlansData.length === 0) {
          summaryContainer.classList.add("hidden"); // Sembunyikan jika tidak ada data
          return;
        }

        // Tampilkan kontainer jika ada data
        summaryContainer.classList.remove("hidden");

        // Inisialisasi total
        let totalSlPips = 0;
        let totalTpPips = 0;
        let totalRiskPercentage = 0;
        let totalNettSL = 0;
        let totalNettTP = 0;
        let totalLot = 0; // Variabel baru untuk total lot

        // Iterasi melalui data rencana aktif untuk menghitung total
        runningPlansData.forEach((plan) => {
          // Gunakan poin visual (forCalc) untuk SL dan TP Pips
          totalSlPips += getVisualPoints(plan.slPips, plan.symbol, false).forCalc || 0; // Tambahkan || 0 untuk keamanan
          totalTpPips += getVisualPoints(plan.tpPips, plan.symbol, false).forCalc || 0; // Tambahkan || 0

          // Gunakan persentase risiko (rrPercentage.sl)
          if (plan.rrPercentage && typeof plan.rrPercentage.sl === 'number') {
            totalRiskPercentage += plan.rrPercentage.sl;
          }

          // Gunakan Nett SL dan Nett TP
          totalNettSL += plan.nettSL || 0; // Tambahkan || 0
          totalNettTP += plan.nettTP || 0; // Tambahkan || 0

          // Hitung total Lot
          totalLot += plan.lotSize || 0; // Tambahkan || 0
        });

        // Update teks elemen dengan total yang sudah diformat
        totalSlPipsEl.textContent = formatNumber(totalSlPips, 0, false); // Format tanpa ribuan
        totalTpPipsEl.textContent = formatNumber(totalTpPips, 0, false); // Format tanpa ribuan
        totalRiskPercentageEl.textContent = `-${formatNumber(totalRiskPercentage, 2)}%`; // Selalu negatif
        totalNettSLEl.textContent = formatCurrency(totalNettSL, "USD");
        totalNettTPEl.textContent = formatCurrency(totalNettTP, "USD");
        totalLotEl.textContent = formatNumber(totalLot, 2); // Format lot dengan 2 desimal

        // Atur warna berdasarkan nilai (opsional, karena beberapa sudah diatur di HTML)
        totalTpPipsEl.classList.toggle("positive-value", totalTpPips >= 0);
        totalTpPipsEl.classList.toggle("negative-value", totalTpPips < 0);
        totalNettTPEl.classList.toggle("positive-value", totalNettTP >= 0);
        totalNettTPEl.classList.toggle("negative-value", totalNettTP < 0);
        // Total SL Pips, Risk %, Nett SL selalu negatif/merah
        totalSlPipsEl.classList.add("negative-value");
        totalRiskPercentageEl.classList.add("negative-value");
        totalNettSLEl.classList.add("negative-value");
        // Total Lot netral
        totalLotEl.classList.remove("positive-value", "negative-value");
        totalLotEl.classList.add("neutral-value");
      }
      // --- PERBAIKAN ---
      // Fungsi ini sekarang tidak lagi memerlukan 'uid' dan hanya memuat dari localStorage.
      function loadBannerPhotos() {
        console.log("Loading banner photos from localStorage.");
        try {
          // Cukup ambil data dari localStorage dan parse. Jika tidak ada, gunakan array kosong.
          bannerPhotos = JSON.parse(localStorage.getItem("bannerPhotos")) || [];
        } catch (e) {
          console.error("Error loading banner photos from localStorage:", e);
          bannerPhotos = []; // Jika ada error parsing, reset ke array kosong.
        }
        renderBannerGallery(); // Tampilkan gambar yang sudah dimuat.
      }

      /**
       * Menyimpan array foto banner saat ini ke localStorage.
       */
      function saveBannerPhotosToLocalStorage() {
        try {
          localStorage.setItem("bannerPhotos", JSON.stringify(bannerPhotos));

        } catch (e) {
          console.error("Error saving banner photos to localStorage:", e);
        }
      }

      // --- PERBAIKAN ---
      // Fungsi ini tidak lagi 'async' dan tidak memerlukan 'uid'.
      function saveBannerPhoto(imageDataUrl, index) {
        console.log(`Saving banner photo to localStorage at index ${index}.`);

        // Langsung tambahkan URL data base64 ke array.
        bannerPhotos[index] = imageDataUrl;

        // Panggil fungsi yang sudah ada untuk menyimpan array ke localStorage.
        saveBannerPhotosToLocalStorage();
      }

      // --- PERBAIKAN ---
      // Fungsi ini tidak lagi 'async' dan tidak memerlukan 'uid'.
      function deleteBannerPhoto(index) {
        if (index < 0 || index >= bannerPhotos.length) {
          console.error("Indeks tidak valid untuk menghapus foto banner.");
          return;
        }

        // Cukup hapus item dari array.
        bannerPhotos.splice(index, 1);

        // Simpan array yang sudah diperbarui ke localStorage.
        saveBannerPhotosToLocalStorage();
        console.log(
          `Banner photo at index ${index} deleted from localStorage.`
        );
      }

      /**
       * Menampilkan gambar di galeri banner 16:4.
       */
      function renderBannerGallery() {
        const bannerSlides = document.getElementById("bannerSlides");
        const bannerCounter = document.getElementById("bannerCounter");
        if (!bannerSlides || !bannerCounter) return;

        bannerSlides.innerHTML = ""; // Kosongkan slide

        if (bannerPhotos.length === 0) {
          bannerSlides.innerHTML = `<img src="https://placehold.co/1600x400/cccccc/ffffff?text=Click+%26+Hold+to+Add+Banner" alt="Placeholder Banner" class="w-full h-full object-cover">`;
          bannerCounter.classList.add("hidden");
          return;
        }

        bannerPhotos.forEach((url) => {
          const img = document.createElement("img");
          img.src = url;
          img.className = "w-full h-full object-cover flex-shrink-0";
          bannerSlides.appendChild(img);
        });

        bannerSlides.style.transform = `translateX(-${
          currentBannerPhotoIndex * 100
        }%)`;
        bannerCounter.textContent = `${currentBannerPhotoIndex + 1} / ${
          bannerPhotos.length
        }`;
        bannerCounter.classList.toggle("hidden", bannerPhotos.length <= 1);
      }

      /**
       * Pindah ke foto banner berikutnya, kembali ke awal jika sudah di akhir.
       */
      function showNextBannerPhoto() {
        if (bannerPhotos.length > 1) {
          currentBannerPhotoIndex =
            (currentBannerPhotoIndex + 1) % bannerPhotos.length;
          renderBannerGallery();
        }
      }

      /**
       * Memulai fungsi autoslide untuk banner.
       */
      function startBannerAutoslide() {
        // Hentikan interval sebelumnya jika ada
        if (bannerAutoslideInterval) {
          clearInterval(bannerAutoslideInterval);
        }
        // Mulai interval baru
        bannerAutoslideInterval = setInterval(showNextBannerPhoto, 30000); // 30 detik
      }

      // --- FIREBASE STORAGE FUNCTIONS ---
      async function loadProfilePictures(uid) {
        if (!storage) {
          console.warn(
            "Firebase Storage is not initialized. Using localStorage for photos."
          );
          loadPhotosFromLocalStorage();
          renderPhotoGallery();
          return;
        }

        let permissionErrorOccurred = false;
        userPhotos = [];
        const loadPromises = [];

        for (let i = 0; i < MAX_PHOTOS; i++) {
          const imageRef = ref(
            storage,
            `artifacts/${appId}/users/${uid}/profile_${i}.png`
          );
          loadPromises.push(
            getDownloadURL(imageRef)
              .then((url) => ({ url, index: i }))
              .catch((error) => {
                if (error.code === "storage/unauthorized") {
                  // Set flag jika terjadi error izin, jangan log di sini untuk menghindari spam.
                  permissionErrorOccurred = true;
                } else if (error.code !== "storage/object-not-found") {
                  // Log error lain yang tidak terduga, abaikan jika file tidak ditemukan (ini normal).
                  console.error(
                    `Error loading profile picture profile_${i}.png:`,
                    error
                  );
                }
                return null; // Kembalikan null untuk setiap kegagalan muat.
              })
          );
        }

        const results = await Promise.all(loadPromises);

        // Jika error izin terdeteksi, tangani sekarang secara terpusat.
        if (permissionErrorOccurred) {
          console.error(
            "Firebase Storage Permission Error: User does not have permission to access profile pictures. Please check your Firebase Storage Security Rules to ensure read access for authenticated users (e.g., 'allow read: if request.auth != null;'). Falling back to localStorage for photos."
          );
          loadPhotosFromLocalStorage(); // Fallback ke data lokal
          renderPhotoGallery();
          return; // Hentikan eksekusi lebih lanjut
        }

        // Jika tidak ada error izin, lanjutkan seperti biasa.
        results.forEach((result) => {
          if (result) {
            userPhotos[result.index] = result.url;
          }
        });
        userPhotos = userPhotos.filter((url) => url); // Bersihkan slot kosong
        console.log("Memuat foto profil 1:1 HANYA dari localStorage.");
        loadPhotosFromLocalStorage(); // Memanggil fungsi lokal yang sudah ada
        renderPhotoGallery(); // Menampilkan foto yang dimuat
      }

      async function saveProfilePicture(uid, imageDataUrl, index) {
        if (!storage) {
          console.warn(
            "Firebase Storage is not initialized. Cannot save profile picture."
          );
          userPhotos[index] = imageDataUrl; // Update in memory
          savePhotosToLocalStorage(); // Fallback to local storage
          renderPhotoGallery();
          return;
        }
        try {
          const imageRef = ref(
            storage,
            `artifacts/${appId}/users/${uid}/profile_${index}.png`
          );
          const response = await fetch(imageDataUrl);
          const blob = await response.blob();
          await uploadBytes(imageRef, blob);

          // Update local state AFTER successful upload
          userPhotos[index] = imageDataUrl;
          console.warn(
          "Menyimpan foto profil 1:1 HANYA ke localStorage."
        );
        userPhotos[index] = imageDataUrl; // Update di memori
        savePhotosToLocalStorage(); // Panggil fungsi simpan lokal
        renderPhotoGallery(); // Perbarui tampilan
        showMessageBox("Berhasil", "Foto profil berhasil disimpan (Lokal).", false);
      }catch (error) {
          if (error.code === "storage/unauthorized") {
            console.error(
              "Firebase Storage Permission Error: User does not have permission to save profile picture. Please check your Firebase Storage Security Rules to ensure write access for authenticated users (e.g., 'allow write: if request.auth != null;').",
              error
            );
            showMessageBox(
              "Gagal",
              "Tidak ada izin untuk menyimpan foto. Periksa aturan keamanan Firebase Anda.",
              false
            );
          } else {
            console.error(
              `Error saving profile picture profile_${index}.png to Firebase:`,
              error
            );
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat menyimpan foto. Silakan coba lagi.",
              false
            );
          }
        }
      }

      // --- GANTI SELURUH FUNGSI deleteProfilePicture LAMA DENGAN INI ---
      async function deleteProfilePicture(uid, indexToDelete) {
        // PERBAIKAN: Hapus semua logika Firebase.
        // Fungsi ini sekarang hanya menghapus dari localStorage, parameter uid diabaikan.
        console.warn(
          "Menghapus foto profil 1:1 HANYA dari localStorage."
        );
        
        if (indexToDelete < 0 || indexToDelete >= userPhotos.length) {
            console.error("Indeks tidak valid untuk menghapus foto profil.");
            return;
        }

        userPhotos.splice(indexToDelete, 1); // Hapus dari array memori
        savePhotosToLocalStorage(); // Simpan perubahan ke localStorage
        
        // Atur ulang indeks foto saat ini jika perlu
        if (
          currentPhotoIndex >= userPhotos.length &&
          userPhotos.length > 0
        ) {
          currentPhotoIndex = userPhotos.length - 1;
        } else if (userPhotos.length === 0) {
          currentPhotoIndex = 0;
        }
        
        renderPhotoGallery(); // Perbarui tampilan
        showMessageBox("Berhasil", "Foto berhasil dihapus (Lokal).", false);
      }
      // --- AKHIR PENGGANTIAN ---

      // --- FIREBASE FIRESTORE FUNCTIONS (No changes needed here for photo functionality) ---

      async function saveCalculatedPlan(uid, plan) {
        if (!db) return;
        try {
          await setDoc(
            doc(
              db,
              `artifacts/${appId}/users/${uid}/calculatedPlans`,
              plan.rowId
            ),
            plan
          );
          console.log("Calculated plan saved to Firestore:", plan.rowId);
        } catch (error) {
          console.error("Error saving calculated plan to Firestore:", error);
        }
      }

      async function deleteCalculatedPlan(uid, rowId) {
        if (!db) return;
        try {
          await deleteDoc(
            doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, rowId)
          );
          console.log("Calculated plan deleted from Firestore:", rowId);
        } catch (error) {
          console.error(
            "Error deleting calculated plan from Firestore:",
            error
          );
        }
      }

      async function loadRunningPlans(uid) {
        if (!db) return;
        try {
          const q = query(
            collection(db, `artifacts/${appId}/users/${uid}/runningPlans`)
          );
          onSnapshot(
            q,
            (snapshot) => {
              runningPlansData = snapshot.docs.map((doc) => {
                const data = doc.data();
                data.assetData = getAssetData(data.symbol);
                return data;
              });
              console.log(
                "Running plans loaded from Firestore:",
                runningPlansData.length
              );
              renderRunningPlans();

              saveDataToLocalStorage(); // Keep local storage in sync
            },
            (error) => {
              console.error(
                "Error listening to running plans from Firestore:",
                error
              );
            }
          );
        } catch (error) {
          console.error(
            "Error setting up Firestore listener for running plans:",
            error
          );
        }
      }

      async function updatePrice(
        id,
        tpPrice,
        NettSL,
        NetTP,
        slPercentage,
        tpPercentage,
        RrPips,
        TpPips,
        slPips
      ) {
        try {
          await fetch("https://leodra.fiqrianandahakin.my.id/api/trade/price", {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              id,
              tpPrice,
              NettSL,
              NetTP,
              slPercentage,
              tpPercentage,
              RrPips,
              TpPips,
              slPips,
            }),
          });
        } catch (error) {
          console.error("Error updating price to backend:", error);
        }
      }

      // ▼▼▼ FUNGSI saveRunningPlan YANG SUDAH DIBERSIHKAN ▼▼▼
      async function saveRunningPlan(
        id,
        status = "RUNNING",
        outcome = null,
        exitTime = null,
        originalTpPrice = null,
        originalNettSL = null,
        originalNettTP = null,
        originalrrSlPercentage = null,
        originalrrTpPercentage = null,
        originalRrPips = null,
        originalTpPips = null,
        originalSlPips = null
      ) {
        try {
          console.log("Saving running plan status to backend:", id, status);
          
          await fetch("https://leodra.fiqrianandahakin.my.id/api/trade", {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              id,
              status,
              outcome,
              exitTime,
              originalTpPrice,
              originalNettSL,
              originalNettTP,
              originalrrSlPercentage,
              originalrrTpPercentage,
              originalRrPips,
              originalTpPips,
              originalSlPips,
            }),
          });
        } catch (error) {
          console.error("Error saving running plan to Firestore:", error);
        }
      }

      async function deleteRunningPlan(uid, id) {
        try {
          await fetch(`https://leodra.fiqrianandahakin.my.id/api/trade/${id}`, {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });
          console.log("Running plan deleted from Firestore:", rowId);
        } catch (error) {
          console.error("Error deleting running plan from Firestore:", error);
        }
      }

// ▼▼▼ GANTI FUNGSI LAMA (baris 2305-2351) DENGAN INI ▼▼▼
async function loadExecutedPlans(uid) {
  if (!db) {
    console.warn(
      "Firestore is not initialized. Cannot load executed plans."
    );
    // Jika DB tidak ada, kita asumsikan initializeAppFromLocalStorage akan menangani UI update.
    await initializeAppFromLocalStorage(); // Panggil fallback jika DB gagal
    return;
  }
  try {
    console.log(`Setting up Firestore listener for executedPlans (UID: ${uid})...`);
    const q = query(
      collection(db, `artifacts/${appId}/users/${uid}/executedPlans`)
    );

    // Listener onSnapshot akan berjalan saat data awal dimuat DAN saat ada perubahan
    onSnapshot(
      q,
      (snapshot) => {
        const plans = snapshot.docs.map((doc) => {
          const data = doc.data();
          // Pastikan assetData ditambahkan jika perlu
          if (!data.assetData) {
            data.assetData = getAssetData(data.symbol);
          }
          // Pastikan ada ID unik (dari Firestore doc ID)
          data.id = doc.id;
          return data;
        });

        // Update data global
        executedPlansData = plans; // Data sudah diupdate di sini

        console.log(
          "Executed plans updated/loaded from Firestore:",
          executedPlansData.length
        );

        // Panggil fungsi update pusat SETELAH data diupdate
        updateAllDataAndRenderUI();
      },
      (error) => {
        console.error(
          "Error listening to executed plans from Firestore:",
          error
        );
        // ▼▼▼ PERBAIKAN: JANGAN panggil initializeAppFromLocalStorage() DI SINI ▼▼▼
        // Memanggilnya di sini dapat menyebabkan data tercampur (Race Condition)
        // Jika listener gagal, biarkan data lokal (jika ada) yang digunakan.
        // initializeAppFromLocalStorage(); // <-- BARIS INI DIHAPUS
        // ▼▼▼ AKHIR PERBAIKAN ▼▼▼
      }
    );
  } catch (error) {
    console.error(
      "Error setting up Firestore listener for executed plans:",
      error
    );
    // Fallback jika setup listener awal gagal
    await initializeAppFromLocalStorage();
  }
}
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 3 ▲▲▲
      // --- AKHIR DARI FUNGSI loadExecutedPlans ---

      async function saveExecutedPlan(uid, plan) {
        if (!db) {
          console.warn(
            "Firestore is not initialized. Cannot save executed plan."
          );
          return;
        }
        try {
          await addDoc(
            collection(db, `artifacts/${appId}/users/${uid}/executedPlans`),
            plan
          );
          console.log("Executed plan saved to Firestore.");
        } catch (error) {
          console.error("Error saving executed plan to Firestore:", error);
        }
      }

      async function deleteAllExecutedPlans() {
        try {
          await fetch("https://leodra.fiqrianandahakin.my.id/api/trade/all", {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });
        } catch (error) {
          console.error(
            "Error deleting all executed plans from Firestore:",
            error
          );
        }
      }

      async function deleteAllCalculatedPlans(uid) {
        if (!db) return;
        try {
          const q = query(
            collection(db, `artifacts/${appId}/users/${uid}/calculatedPlans`)
          );
          const snapshot = await getDocs(q);
          const deletePromises = snapshot.docs.map((doc) => deleteDoc(doc.ref));
          await Promise.all(deletePromises);
          console.log("All calculated plans deleted from Firestore.");
        } catch (error) {
          console.error(
            "Error deleting all calculated plans from Firestore:",
            error
          );
        }
      }

      // --- LOCAL STORAGE FUNCTIONS (Used as fallback if Firebase is not configured or fails) ---
      function saveDataToLocalStorage(planPhotoInput) {
        try {
          localStorage.setItem(
            "calculatedPlansData",
            JSON.stringify(calculatedPlansData)
          );
          localStorage.setItem(
            "runningPlansData",
            JSON.stringify(runningPlansData)
          );
          localStorage.setItem(
            "executedPlansData",
            JSON.stringify(executedPlansData)
          );
          console.log("Data saved to localStorage.");
        } catch (e) {
          console.error("Error saving to localStorage:", e);
        }
      }
      async function loadDataFromLocalStorage() {
        try {
          const response = await fetch("https://leodra.fiqrianandahakin.my.id/api/trade", {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) {
            console.error("Fetch failed:", response.status);
            return;
          }

          const res = await response.json();

          calculatedPlansData = res.calculated || [];
          runningPlansData = res.running || [];
          executedPlansData = res.executed || [];

          console.log("Data loaded:", {
            calculated: calculatedPlansData.length,
            running: runningPlansData.length,
            executed: executedPlansData.length,
          });
        } catch (e) {
          console.error("Error loading data:", e);
        }
      }

      // --- Photo Local Storage (separate for photos) ---
      async function savePhotosToLocalStorage() {
        try {
            // const formData = new FormData();
 
          localStorage.setItem("userPhotos", JSON.stringify(userPhotos));
          console.log("userphotos saved to localStorage:", userPhotos);
          // formData.append("image", imageInput.files[0]);
          // formData.append("tradeId", tradeIdInput.value)
          try {
            // const response = await fetch("https://leodra.fiqrianandahakin.my.id/api/trade/upload", {
            //   method: "POST",
            //   headers: {
            //     "Content-Type": "application/json",
            //     Authorization: `Bearer ${localStorage.getItem("token")}`,
            //   },
            //   body: JSON.stringify({ photos: userPhotos }),
            // })
          } catch (error) {
            console.error("Error saving photos to Firebase Storage:", error);
          }
          console.log("Photos saved to localStorage.");
        } catch (e) {
          console.error("Error saving photos to localStorage:", e);
        }
      }

      function loadPhotosFromLocalStorage() {
        try {
          userPhotos = JSON.parse(localStorage.getItem("userPhotos")) || [];
          console.log("Photos loaded from localStorage:", userPhotos.length);
        } catch (e) {
          console.error("Error loading photos from localStorage:", e);
          userPhotos = [];
        }
      }

      // --- Simulator Local Storage ---
      function saveSimulatorData() {
        try {
          const simData = {
            balance: document.getElementById("simBalance").value,
            risk: document.getElementById("simRiskPerTrade").value,
            target: document.getElementById("simMonthlyTarget").value,
            period: document.getElementById("simPeriod").value,
          };
          localStorage.setItem(
            "compoundingSimulatorData",
            JSON.stringify(simData)
          );
        } catch (e) {
          console.error("Error saving simulator data to localStorage:", e);
        }
      }

      function loadSimulatorData() {
        try {
          const simData = JSON.parse(
            localStorage.getItem("compoundingSimulatorData")
          );
          if (simData) {
            document.getElementById("simBalance").value = simData.balance || "";
            document.getElementById("simRiskPerTrade").value =
              simData.risk || "";
            document.getElementById("simMonthlyTarget").value =
              simData.target || "";
            document.getElementById("simPeriod").value = simData.period || "";
          }
        } catch (e) {
          console.error("Error loading simulator data from localStorage:", e);
        }
      }

      // --- Input Rows Local Storage ---
      function saveInputRowsToLocalStorage() {
        try {
          const inputRows = document.querySelectorAll(".input-row");
          const dataToSave = [];
          inputRows.forEach((row) => {
            const rowId = row.id.split("-")[1];
            const rowData = {
              symbol: row.querySelector(`#symbol-${rowId}`).value,
              tradeType: row
                .querySelector(`#buyBtn-${rowId}`)
                .classList.contains("active")
                ? "BUY"
                : "SELL",
              balance: row.querySelector(`#balance-${rowId}`).value,
              riskPercent: row.querySelector(`#riskPercent-${rowId}`).value,
              priceNow: row.querySelector(`#priceNow-${rowId}`).value,
              openPrice: row.querySelector(`#openPrice-${rowId}`).value,
              slPrice: row.querySelector(`#slPrice-${rowId}`).value,
              tpPrice: row.querySelector(`#tpPrice-${rowId}`).value,
              note: row.querySelector(`#note-${rowId}`).value,
              image: []
            };
            dataToSave.push(rowData);
          });
          localStorage.setItem(
            "calculatorInputRows",
            JSON.stringify(dataToSave)
          );
        } catch (e) {
          console.error("Error saving input rows to localStorage:", e);
        }
      }

      function loadInputRowsFromLocalStorage() {
        try {
          const savedRows = JSON.parse(
            localStorage.getItem("calculatorInputRows")
          );
          if (savedRows && savedRows.length > 0) {
            inputRowsContainer.innerHTML = ""; // Clear any default rows
            savedRows.forEach((rowData) => addInputRow(rowData));
            return true; // Indicate that data was loaded
          }
          return false; // No data found
        } catch (e) {
          console.error("Error loading input rows from localStorage:", e);
          return false;
        }
      }

      // --- CHART.JS RENDERING FUNCTIONS (simplified error/loading handling) ---
      const setupChartContainer = (canvasId, loadingId, errorId, noDataId) => {
        const canvas = document.getElementById(canvasId);
        const loading = document.getElementById(loadingId);
        const error = document.getElementById(errorId);
        const noData = document.getElementById(noDataId);
        loading.classList.remove("hidden");
        error.classList.add("hidden");
        noData.classList.add("hidden");
        canvas.style.display = "none";
        return { canvas, loading, error, noData };
      };

      // --- ▼▼▼ GANTI SELURH FUNGSI LAMA INI DENGAN VERSI BARU ▼▼▼ ---

      const handleChartData = (
        data,
        { canvas, loading, error, noData },
        chartInstanceRef,
        chartType,
        options
      ) => {
        loading.classList.add("hidden");
        // Check if data is empty or if all values are zero for pie chart
        if (
          data.labels.length === 0 ||
          (chartType === "pie" &&
            data.datasets &&
            data.datasets.length > 0 &&
            data.datasets[0].data.every((val) => val === 0))
        ) {
          noData.classList.remove("hidden");
          canvas.style.display = "none";
          return false;
        }

        // --- PERBAIKAN UTAMA DI SINI ---
        // Secara eksplisit hancurkan chart yang ada di kanvas ini, jika ada.
        // Ini adalah cara paling andal untuk mencegah error "Canvas is already in use",
        // terlepas dari status variabel global yang kita lacak.
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
          existingChart.destroy();
        }
        // --- AKHIR PERBAIKAN ---

        canvas.style.display = "block";

        // Buat instance chart baru dan perbarui referensi global melalui setter.
        // Pengecekan lama (if (chartInstanceRef.chart)...) dihapus karena sudah ditangani di atas.
        chartInstanceRef.chart = new Chart(canvas, {
          type: chartType,
          data: { labels: data.labels, datasets: data.datasets },
          options,
        });

        return true;
      };

      // --- GANTI SELURUH FUNGSI fetchAndRenderPieChart LAMA DENGAN INI ---
      async function fetchAndRenderPieChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "assetSuccessPieChart",
          "pieChartLoading",
          "pieChartError",
          "pieChartNoData"
        );
        const chartInstanceRef = {
          chart: assetPieChart,
          set chart(c) {
            assetPieChart = c;
          },
        };

        try {
          const takeProfitTradesByAsset = {};
          let totalTakeProfitTrades = 0;

          // Menggunakan helper getTradeResult
          executedPlansData.forEach((trade) => {
            if (getTradeResult(trade).isWin) { // isWin = Take Profit
              takeProfitTradesByAsset[trade.symbol] =
                (takeProfitTradesByAsset[trade.symbol] || 0) + 1;
              totalTakeProfitTrades++;
            }
          });

          if (totalTakeProfitTrades === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartInstanceRef,
              "pie",
              {}
            );
            return;
          }

          const labels = [],
            data = [],
            backgroundColors = [];

          // ▼▼▼ PERBAIKAN: Palet warna gelap ▼▼▼
          const darkColors = [
              '#343a40', // Dark Gray
              '#007bff', // Blue
              '#6c757d', // Medium Gray
              '#dc3545', // Red
              '#ffc107', // Yellow
              '#17a2b8', // Teal
              '#28a745', // Green
              '#6610f2'  // Indigo
          ];
          // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

          let colorIndex = 0; 
          for (const symbol in takeProfitTradesByAsset) {
            const percentage =
              (takeProfitTradesByAsset[symbol] / totalTakeProfitTrades) * 100;
            labels.push(`${symbol} (${formatNumber(percentage, 2)}%)`);
            data.push(percentage);
            // ▼▼▼ PERBAIKAN: Gunakan palet warna baru ▼▼▼
            backgroundColors.push(darkColors[colorIndex % darkColors.length]);
            colorIndex++;
            // ▲▲▲ AKHIR PERBAIKAN ▲▲▲
          }

          handleChartData(
            {
              labels,
              // ▼▼▼ PERBAIKAN UTAMA: Perbaiki struktur datasets ▼▼▼
              datasets: [ // PERBAIKAN: Harus berupa array
                {
                  label: "Distribusi Take Profit", // PERBAIKAN: Label yang benar
                  data: data, // data (persentase)
                  backgroundColor: backgroundColors, // palet warna gelap
                  borderColor: "#ffffff", // Garis pemisah putih
                  borderWidth: 1.5
                }
              ] // PERBAIKAN: Tutup array
              // ▲▲▲ AKHIR PERBAIKAN UTAMA ▲▲▲
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "pie",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: {
                  display: true,
                  position: "bottom",
                  labels: {
                    color: "#333",
                    font: { family: "Inter", size: 10, weight: "300" },
                    padding: 15,
                    boxWidth: 12,
                  },
                },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      // Ambil label asli (tanpa persentase) dan tambahkan data mentah (persen)
                      `${ctx.label.split(' (')[0]}: ${formatNumber(ctx.raw, 2)}%`,
                  },
                  spacing: 10,
                },
              },
            }
          );
        } catch (err) {
          console.error("Error pie chart:", err);
          loading.classList.add("hidden");
          // Tampilkan pesan error yang lebih spesifik jika mungkin
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }
      // --- AKHIR DARI FUNGSI fetchAndRenderPieChart ---

     // ▼▼▼ GANTI SELURUH FUNGSI LAMA (baris 2235-2351) DENGAN INI ▼▼▼
async function fetchAndRenderDailyLineChart() {
  const { canvas, loading, error, noData } = setupChartContainer(
    "dailyLineChart",
    "dailyLineChartLoading",
    "dailyLineChartError",
    "dailyLineChartNoData"
  );
  try {
    const now = new Date();
    const todayStart = new Date(
      now.getFullYear(),
      now.getMonth(),
      now.getDate(),
      0,
      0,
      0
    ).getTime();

    // PERBAIKAN: Filter dan urutkan data
    const tradesToday = executedPlansData
      .filter(
        (trade) =>
          getTradeResult(trade).isValid &&
          new Date(trade.timestamp).getTime() >= todayStart
      )
      .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    if (tradesToday.length === 0) {
      handleChartData(
        { labels: [], datasets: [] },
        { canvas, loading, error, noData },
        {
          chart: dailyLineChart,
          set chart(c) {
            dailyLineChart = c;
          },
        },
        "line",
        {}
      );
      return;
    }

    const initialBalanceForTheDay = tradesToday[0].balance;
    let cumulativePLForTheDay = 0;
    const labels = ["Mulai"],
      data = [0];

    tradesToday.forEach((trade) => {
      cumulativePLForTheDay += getTradeResult(trade).profitLoss;
      const currentCumulativePercentage =
        initialBalanceForTheDay > 0
          ? (cumulativePLForTheDay / initialBalanceForTheDay) * 100
          : 0;
      labels.push(
        new Date(trade.timestamp).toLocaleString("id-ID", {
          hour: "2-digit",
          minute: "2-digit",
        })
      );
      data.push(currentCumulativePercentage);
    });

    // ▼▼▼ PERBAIKAN: Kalkulasi Skala Y (Sumbu Kiri) ▼▼▼
    const DAILY_LIMIT = -3.6;
    // 1. Tentukan rentang data, paksa menyertakan 0 dan batas limit
    const dataValues = [0, DAILY_LIMIT, ...data];
    const dataMin = Math.min(...dataValues);
    const dataMax = Math.max(...dataValues);
    // 2. Beri padding asimetris (RASIO BARU YANG LEBIH AGRESIIF)
    const range = dataMax - dataMin;
    const bottomPadding = range * 0.05 || 0.5; // Padding bawah 5% (SANGAT KECIL)
    const topPadding = range * 1.5 || 10;   // Padding atas 150% (SANGAT BESAR)

    const finalMin = dataMin - bottomPadding;
    const finalMax = dataMax + topPadding;
    // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

    handleChartData(
      {
        labels,
        datasets: [
          {
            label: "Persentase Harian",
            data,
            borderColor: "#222",
            backgroundColor: "rgba(34, 34, 34, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 3,
            pointBackgroundColor: "#222",
          },
        ],
      },
      { canvas, loading, error, noData },
      {
        chart: dailyLineChart,
        set chart(c) {
          dailyLineChart = c;
        },
      },
      "line",
      {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) =>
                ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
            },
          },
          annotation: {
            annotations: {
              limitLine: {
                type: "line",
                yMin: -3.5, // <-- PERBAIKAN
                yMax: -3.5, // <-- PERBAIKAN
                borderColor: "rgb(220, 53, 69)", // Warna merah
                label: {
                  content: "Batas Harian -3.5%", // <-- PERBAIKAN
                  enabled: true,
                  position: "end",
                  backgroundColor: "rgba(220, 53, 69, 0.8)",
                  color: "white",
                  font: { size: 9, family: "Inter", style: "normal" },
                  padding: 4,
                  yAdjust: -10,
                },
              },
            },
          },
        },
        scales: {
          x: { ticks: { font: { size: 7 } } },
          y: {
            ticks: {
              callback: (val) => formatNumber(val, 2) + "%",
              font: { size: 7 },
              maxTicksLimit: 6, // <-- PERBAIKAN: Batasi jumlah label Y
            },
            // ▼▼▼ PERBAIKAN: Gunakan min/max baru ▼▼▼
            suggestedMin: finalMin,
            suggestedMax: finalMax,
            // ▲▲▲ AKHIR PERBAIKAN ▲▲▲
          },
        },
      }
    );
  } catch (err) {
    console.error("Error daily line chart:", err);
    loading.classList.add("hidden");
    error.textContent = "Gagal memuat data: " + err.message;
    error.classList.remove("hidden");
    canvas.style.display = "none";
  }
}
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 1 ▲▲▲
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 1 ▲▲▲

      async function fetchAndRenderMonthlyBarChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "monthlyBarChart",
          "monthlyBarChartLoading",
          "monthlyBarChartError",
          "monthlyBarChartNoData"
        );
        try {
          // PERBAIKAN: Filter dan urutkan data
          const relevantTrades = executedPlansData
            .filter((trade) => getTradeResult(trade).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (relevantTrades.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: monthlyBarChart,
                set chart(c) {
                  monthlyBarChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const monthlyStatsMap = {};

          relevantTrades.forEach((trade) => {
            const monthYear = new Date(trade.timestamp).toLocaleString(
              "id-ID",
              { month: "long", year: "numeric" }
            );
            if (!monthlyStatsMap[monthYear]) {
              const firstTradeOfMonth = relevantTrades.find(
                (t) =>
                  new Date(t.timestamp).toLocaleString("id-ID", {
                    month: "long",
                    year: "numeric",
                  }) === monthYear
              );
              monthlyStatsMap[monthYear] = {
                monthlyPL: 0,
                initialBalance: firstTradeOfMonth
                  ? firstTradeOfMonth.balance
                  : 0,
              };
            }
            monthlyStatsMap[monthYear].monthlyPL +=
              getTradeResult(trade).profitLoss;
          });

          const labels = Object.keys(monthlyStatsMap).sort(
            (a, b) => new Date(`01 ${a}`) - new Date(`01 ${b}`)
          );
          const data = labels.map((my) => {
            const monthData = monthlyStatsMap[my];
            return monthData.initialBalance > 0
              ? (monthData.monthlyPL / monthData.initialBalance) * 100
              : 0;
          });

          const backgroundColors = data.map((val) =>
            val >= 0 ? "rgba(34, 34, 34, 0.8)" : "rgba(220, 53, 69, 0.8)"
          );
          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Perubahan Bulanan",
                  data,
                  backgroundColor: backgroundColors,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: monthlyBarChart,
              set chart(c) {
                monthlyBarChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
                  },
                },
              },
              scales: {
                y: { ticks: { callback: (val) => formatNumber(val, 2) + "%" } },
              },
            }
          );
        } catch (err) {
          console.error("Error monthly bar chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallPercentageCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallPercentageCumulativeChart",
          "overallPercentageCumulativeChartLoading",
          "overallPercentageCumulativeChartError",
          "overallPercentageCumulativeChartNoData"
        );

        const lastExecDateEl = document.getElementById(
          "lastExecDate_Percentage"
        );
        const finalValueEl = document.getElementById("finalValue_Percentage");
        const assetListEl = document.getElementById("assetList_Percentage");

        try {
          const sortedTrades = [...executedPlansData]
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = "0.00%";
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallPercentageCumulativeChart,
                set chart(c) {
                  overallPercentageCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const actualLabels = [],
            actualData = [];
          let initialBalance = sortedTrades[0].balance;
          let currentBalance = initialBalance;

          actualLabels.push("Mulai");
          actualData.push(0);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            actualLabels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            actualData.push(
              initialBalance > 0
                ? ((currentBalance - initialBalance) / initialBalance) * 100
                : 0
            );
          });

          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = actualData[actualData.length - 1];
          finalValueEl.textContent = `${formatNumber(finalValue, 2)}%`;
          finalValueEl.classList.toggle("positive-value", finalValue >= 0);
          finalValueEl.classList.toggle("negative-value", finalValue < 0);

          const uniqueAssets = [
            ...new Set(
              executedPlansData
                .filter((t) => getTradeResult(t).isValid)
                .map((trade) => trade.symbol)
            ),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          const { projectionLabels, projectionData } =
            calculateProjectionData("percentage");
          const combinedLabels = [...actualLabels, ...projectionLabels];
          const actualDataset = {
            label: "Persentase Aktual",
            data: actualData,
            borderColor: "#007bff",
            backgroundColor: "rgba(0, 123, 255, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "#007bff",
          };
          const projectionDataset = {
            label: "Proyeksi",
            data: [
              ...new Array(actualData.length - 1).fill(null),
              actualData[actualData.length - 1],
              ...projectionData,
            ],
            borderColor: "rgba(0, 123, 255, 0.5)",
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "rgba(0, 123, 255, 0.5)",
          };
          const datasets = [actualDataset];
          if (projectionData.length > 0) datasets.push(projectionDataset);

          const scalesConfig = getResponsiveChartScales(
            combinedLabels,
            "Persentase Kumulatif (%)",
            (val) => formatNumber(val, 2) + "%"
          );
          handleChartData(
            { labels: combinedLabels, datasets },
            { canvas, loading, error, noData },
            {
              chart: overallPercentageCumulativeChart,
              set chart(c) {
                overallPercentageCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative percentage chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallBalanceCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallBalanceCumulativeChart",
          "overallBalanceCumulativeChartLoading",
          "overallBalanceCumulativeChartError",
          "overallBalanceCumulativeChartNoData"
        );

        const lastExecDateEl = document.getElementById("lastExecDate_Balance");
        const finalValueEl = document.getElementById("finalValue_Balance");
        const assetListEl = document.getElementById("assetList_Balance");

        try {
          const sortedTrades = [...executedPlansData]
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = formatCurrency(0);
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallBalanceCumulativeChart,
                set chart(c) {
                  overallBalanceCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const actualLabels = [],
            actualData = [];
          let currentBalance = sortedTrades[0].balance;

          actualLabels.push("Mulai");
          actualData.push(currentBalance);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            actualLabels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            actualData.push(currentBalance);
          });

          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = actualData[actualData.length - 1];
          const initialBalance = actualData[0];
          finalValueEl.textContent = formatCurrency(finalValue, "USD");
          finalValueEl.classList.toggle(
            "positive-value",
            finalValue >= initialBalance
          );
          finalValueEl.classList.toggle(
            "negative-value",
            finalValue < initialBalance
          );

          const uniqueAssets = [
            ...new Set(
              executedPlansData
                .filter((t) => getTradeResult(t).isValid)
                .map((trade) => trade.symbol)
            ),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          const { projectionLabels, projectionData } =
            calculateProjectionData("balance");
          const combinedLabels = [...actualLabels, ...projectionLabels];
          const actualDataset = {
            label: "Saldo Aktual",
            data: actualData,
            borderColor: "#dc3545",
            backgroundColor: "rgba(220, 53, 69, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "#dc3545",
          };
          const projectionDataset = {
            label: "Proyeksi",
            data: [
              ...new Array(actualData.length - 1).fill(null),
              actualData[actualData.length - 1],
              ...projectionData,
            ],
            borderColor: "rgba(220, 53, 69, 0.5)",
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "rgba(220, 53, 69, 0.5)",
          };
          const datasets = [actualDataset];
          if (projectionData.length > 0) datasets.push(projectionDataset);

          const scalesConfig = getResponsiveChartScales(
            combinedLabels,
            "Saldo Akun ($)",
            (val) => formatCurrency(val, "USD")
          );
          handleChartData(
            { labels: combinedLabels, datasets },
            { canvas, loading, error, noData },
            {
              chart: overallBalanceCumulativeChart,
              set chart(c) {
                overallBalanceCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatCurrency(ctx.raw, "USD"),
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative balance chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallPipsCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallPipsCumulativeChart",
          "overallPipsCumulativeChartLoading",
          "overallPipsCumulativeChartError",
          "overallPipsCumulativeChartNoData"
        );

        // Ambil elemen UI baru
        const lastExecDateEl = document.getElementById("lastExecDate_Pips");
        const finalValueEl = document.getElementById("finalValue_Pips");
        const assetListEl = document.getElementById("assetList_Pips");

        try {
          const sortedTrades = executedPlansData
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            // Reset info jika tidak ada data
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = "0";
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallPipsCumulativeChart,
                set chart(c) {
                  overallPipsCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const labels = [],
            data = [];
          let currentCumulativePoints = 0;

          // Tambahkan titik awal
          labels.push("Mulai");
          data.push(0);

          sortedTrades.forEach((trade) => {
            const pointsForTrade = getTradeResult(trade).isWin
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;
            currentCumulativePoints += pointsForTrade;
            labels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            data.push(currentCumulativePoints);
          });

          // Update Info Tambahan
          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = data[data.length - 1];
          finalValueEl.textContent = formatNumber(finalValue, 0);
          finalValueEl.classList.toggle("positive-value", finalValue >= 0);
          finalValueEl.classList.toggle("negative-value", finalValue < 0);

          const uniqueAssets = [
            ...new Set(executedPlansData.map((trade) => trade.symbol)),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          // Lanjutkan render grafik seperti biasa...
          const scalesConfig = getResponsiveChartScales(
            labels,
            "Pips/Points",
            (val) => formatNumber(val, 0),
            true
          );
          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Pips/Points Kumulatif Keseluruhan",
                  data,
                  borderColor: "#ffc107",
                  backgroundColor: "rgba(255, 193, 7, 0.1)",
                  fill: true,
                  tension: 0.3,
                  borderWidth: 1.5,
                  pointRadius: 2,
                  pointBackgroundColor: "#ffc107",
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: overallPipsCumulativeChart,
              set chart(c) {
                overallPipsCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 0),
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative pips chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderCombinedBarChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "combinedSummaryBarChart",
          "combinedSummaryBarChartLoading",
          "combinedSummaryBarChartError",
          "combinedSummaryBarChartNoData"
        );
        try {
          const sortedTrades = [...executedPlansData]
            .filter(
              (trade) =>
                trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
            )
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: combinedBarChart,
                set chart(c) {
                  combinedBarChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = [];
          const balanceData = [];
          // Objek untuk menyimpan data tambahan untuk tooltip
          const tooltipData = [];

          let initialBalance = sortedTrades[0].balance;
          let cumulativeBalance = initialBalance;
          let cumulativePips = 0;
          let cumulativeTradeCount = 0;

          sortedTrades.forEach((trade, index) => {
            const profitLossAmount =
              trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
            const pointsForTrade =
              trade.outcome === "Take Profit"
                ? getVisualPoints(trade.tpPips, trade.symbol).forCalc
                : -getVisualPoints(trade.slPips, trade.symbol).forCalc;

            cumulativeBalance += profitLossAmount;
            cumulativePips += pointsForTrade;
            cumulativeTradeCount++;
            const cumulativePercentage =
              initialBalance > 0
                ? ((cumulativeBalance - initialBalance) / initialBalance) * 100
                : 0;

            labels.push(`Trade #${index + 1}`);
            balanceData.push(cumulativeBalance);
            tooltipData.push({
              percentage: cumulativePercentage,
              pips: cumulativePips,
              trades: cumulativeTradeCount,
            });
          });

          const scalesConfig = getResponsiveChartScales(
            labels,
            "Akumulasi Saldo ($)",
            (val) => formatCurrency(val, "USD")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Akumulasi Saldo",
                  data: balanceData,
                  backgroundColor: "rgba(220, 53, 69, 0.8)", // Warna merah
                  borderColor: "rgba(220, 53, 69, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: combinedBarChart,
              set chart(c) {
                combinedBarChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    // Menampilkan data gabungan di tooltip
                    label: function (context) {
                      const index = context.dataIndex;
                      const balance = context.raw;
                      const extraData = tooltipData[index];
                      return `Saldo: ${formatCurrency(balance, "USD")}`;
                    },
                    afterLabel: function (context) {
                      const index = context.dataIndex;
                      const extraData = tooltipData[index];
                      return [
                        `Persentase: ${formatNumber(extraData.percentage, 2)}%`,
                        `Total Pips: ${formatNumber(extraData.pips, 0)}`,
                        `Total Trade: ${extraData.trades}`,
                      ];
                    },
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error combined bar chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data grafik gabungan: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderTradeFrequencyChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "tradeFrequencyChart",
          "tradeFrequencyChartLoading",
          "tradeFrequencyChartError",
          "tradeFrequencyChartNoData"
        );
        try {
          const tradeCounts = {};
          executedPlansData.forEach((trade) => {
            if (trade.outcome !== "Cancel" && trade.outcome !== "Tes") {
              const key = `${trade.symbol} - ${trade.tradeType}`;
              tradeCounts[key] = (tradeCounts[key] || 0) + 1;
            }
          });
          const labels = Object.keys(tradeCounts).sort();
          const data = labels.map((label) => tradeCounts[label]);
          const backgroundColors = labels.map((label) =>
            label.includes("BUY")
              ? "rgba(34, 34, 34, 0.8)"
              : label.includes("SELL")
              ? "rgba(220, 53, 69, 0.8)"
              : "rgba(108, 117, 125, 0.8)"
          );
          const borderColors = backgroundColors.map((c) =>
            c.replace("0.8)", "1)")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data,
                  backgroundColor: backgroundColors,
                  borderColor: borderColors,
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: tradeFrequencyChart,
              set chart(c) {
                tradeFrequencyChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.label}: ${ctx.raw} kali`,
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Aset & Tipe Trade",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                    autoSkip: false,
                    maxRotation: 45,
                    minRotation: 45,
                  },
                },
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Jumlah Eksekusi",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: (val) => (Number.isInteger(val) ? val : null),
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error trade frequency chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data grafik frekuensi trade: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // --- NEW: Functions for Frequency Charts ---

      /**
       * Generic data aggregation function for frequency charts.
       * @returns {Object} Aggregated data grouped by asset symbol.
       */
      function aggregateAssetFrequencyData() {
        const assetStats = {};
        const relevantTrades = executedPlansData.filter(
          (trade) =>
            trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
        );

        // Find the first trade for each asset to establish its initial balance for percentage calculation
        const initialBalances = {};
        [...relevantTrades]
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          .forEach((trade) => {
            if (!initialBalances[trade.symbol]) {
              initialBalances[trade.symbol] = trade.balance;
            }
          });

        relevantTrades.forEach((trade) => {
          const symbol = trade.symbol;
          if (!assetStats[symbol]) {
            assetStats[symbol] = {
              tradeCount: 0,
              cumulativeBalance: 0,
              cumulativePips: 0,
              initialBalance: initialBalances[symbol] || 0, // Use the found initial balance
            };
          }

          const profitLossAmount =
            trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
          const pointsForTrade =
            trade.outcome === "Take Profit"
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          assetStats[symbol].tradeCount++;
          assetStats[symbol].cumulativeBalance += profitLossAmount;
          assetStats[symbol].cumulativePips += pointsForTrade;
        });

        // Calculate cumulative percentage for each asset
        for (const symbol in assetStats) {
          const stats = assetStats[symbol];
          stats.cumulativePercentage =
            stats.initialBalance > 0
              ? (stats.cumulativeBalance / stats.initialBalance) * 100
              : 0;
        }

        return assetStats;
      }

      /**
       * Generic rendering function for horizontal frequency bar charts.
       */
      async function renderFrequencyChart(chartConfig) {
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );
        try {
          const assetStats = aggregateAssetFrequencyData();
          const sortedSymbols = Object.keys(assetStats).sort(
            (a, b) =>
              assetStats[b][chartConfig.dataKey] -
              assetStats[a][chartConfig.dataKey]
          );

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartConfig.chartInstanceRef,
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const data = sortedSymbols.map(
            (symbol) => assetStats[symbol][chartConfig.dataKey]
          );

          // Use the provided color, with a lighter version for negative values
          const backgroundColors = data.map((val) =>
            val >= 0 ? chartConfig.positiveColor : chartConfig.negativeColor
          );
          const borderColors = backgroundColors.map((c) =>
            c.replace("0.8)", "1)").replace("0.4)", "0.6)")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: chartConfig.label,
                  data,
                  backgroundColor: backgroundColors,
                  borderColor: borderColors,
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            chartConfig.chartInstanceRef,
            "bar",
            {
              indexAxis: "y", // Make it a horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      const symbol = context.label;
                      const value = context.raw;
                      const tradeCount = assetStats[symbol].tradeCount;
                      return `${chartConfig.label}: ${chartConfig.formatter(
                        value
                      )} (Total Trade: ${tradeCount})`;
                    },
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: chartConfig.xAxisLabel,
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: chartConfig.formatter,
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error(`Error rendering ${chartConfig.label} chart:`, err);
          loading.classList.add("hidden");
          error.textContent =
            `Gagal memuat data ${chartConfig.label}: ` + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // Specific functions that call the generic renderer
      async function fetchAndRenderBalanceFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "balanceFrequencyChart",
          loadingId: "balanceFrequencyChartLoading",
          errorId: "balanceFrequencyChartError",
          noDataId: "balanceFrequencyChartNoData",
          chartInstanceRef: {
            chart: balanceFrequencyChart,
            set chart(c) {
              balanceFrequencyChart = c;
            },
          },
          dataKey: "cumulativeBalance",
          label: "Akumulasi Balance",
          xAxisLabel: "Total Balance ($)",
          formatter: (val) => formatCurrency(val, "USD"),
          positiveColor: "rgba(220, 53, 69, 0.8)", // Red
          negativeColor: "rgba(220, 53, 69, 0.4)", // Lighter Red
        });
      }

      async function fetchAndRenderPercentageFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "percentageFrequencyChart",
          loadingId: "percentageFrequencyChartLoading",
          errorId: "percentageFrequencyChartError",
          noDataId: "percentageFrequencyChartNoData",
          chartInstanceRef: {
            chart: percentageFrequencyChart,
            set chart(c) {
              percentageFrequencyChart = c;
            },
          },
          dataKey: "cumulativePercentage",
          label: "Akumulasi Persentase",
          xAxisLabel: "Total Persentase (%)",
          formatter: (val) => `${formatNumber(val, 2)}%`,
          positiveColor: "rgba(0, 0, 139, 0.8)", // Dark Blue
          negativeColor: "rgba(0, 0, 139, 0.4)", // Lighter Dark Blue
        });
      }

      async function fetchAndRenderPipsFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "pipsFrequencyChart",
          loadingId: "pipsFrequencyChartLoading",
          errorId: "pipsFrequencyChartError",
          noDataId: "pipsFrequencyChartNoData",
          chartInstanceRef: {
            chart: pipsFrequencyChart,
            set chart(c) {
              pipsFrequencyChart = c;
            },
          },
          dataKey: "cumulativePips",
          label: "Akumulasi Pips/Points",
          xAxisLabel: "Total Pips/Points",
          formatter: (val) => formatNumber(val, 0),
          positiveColor: "rgba(255, 193, 7, 0.8)", // Yellow
          negativeColor: "rgba(255, 193, 7, 0.4)", // Lighter Yellow
        });
      }

      // --- NEW: Functions for Execution Frequency Chart ---

      /**
       * Aggregates executed trade data, separating stats by asset and trade type (BUY/SELL).
       * @returns {Object} Aggregated data.
       */
      function aggregateExecutionFrequencyData() {
        const assetStats = {};
        const relevantTrades = executedPlansData.filter(
          (trade) =>
            trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
        );

        // Find the initial balance for each asset to calculate percentage changes accurately.
        const initialBalances = {};
        [...relevantTrades]
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          .forEach((trade) => {
            if (!initialBalances[trade.symbol]) {
              initialBalances[trade.symbol] = trade.balance;
            }
          });

        relevantTrades.forEach((trade) => {
          const symbol = trade.symbol;
          const tradeType = trade.tradeType.toUpperCase(); // 'BUY' or 'SELL'

          // Initialize structure if it doesn't exist
          if (!assetStats[symbol]) {
            assetStats[symbol] = {
              BUY: {
                tradeCount: 0,
                cumulativeBalance: 0,
                cumulativePips: 0,
                initialBalance: initialBalances[symbol] || 0,
              },
              SELL: {
                tradeCount: 0,
                cumulativeBalance: 0,
                cumulativePips: 0,
                initialBalance: initialBalances[symbol] || 0,
              },
            };
          }

          const profitLossAmount =
            trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
          const pointsForTrade =
            trade.outcome === "Take Profit"
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          if (assetStats[symbol][tradeType]) {
            assetStats[symbol][tradeType].tradeCount++;
            assetStats[symbol][tradeType].cumulativeBalance += profitLossAmount;
            assetStats[symbol][tradeType].cumulativePips += pointsForTrade;
          }
        });

        // Calculate cumulative percentage for each asset and trade type
        for (const symbol in assetStats) {
          for (const tradeType in assetStats[symbol]) {
            const stats = assetStats[symbol][tradeType];
            stats.cumulativePercentage =
              stats.initialBalance > 0
                ? (stats.cumulativeBalance / stats.initialBalance) * 100
                : 0;
          }
        }

        return assetStats;
      }

      /**
       * Renders the horizontal grouped bar chart for execution frequency.
       */
      async function fetchAndRenderExecutionFrequencyChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "executionFrequencyChart",
          "executionFrequencyChartLoading",
          "executionFrequencyChartError",
          "executionFrequencyChartNoData"
        );
        try {
          const assetStats = aggregateExecutionFrequencyData();
          const sortedSymbols = Object.keys(assetStats).sort((a, b) => {
            const totalBalanceA =
              (assetStats[a].BUY.cumulativeBalance || 0) +
              (assetStats[a].SELL.cumulativeBalance || 0);
            const totalBalanceB =
              (assetStats[b].BUY.cumulativeBalance || 0) +
              (assetStats[b].SELL.cumulativeBalance || 0);
            return totalBalanceB - totalBalanceA;
          });

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: executionFrequencyChart,
                set chart(c) {
                  executionFrequencyChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const buyData = sortedSymbols.map(
            (symbol) => assetStats[symbol].BUY.cumulativeBalance
          );
          const sellData = sortedSymbols.map(
            (symbol) => assetStats[symbol].SELL.cumulativeBalance
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "BUY",
                  data: buyData,
                  backgroundColor: "rgba(0, 0, 139, 0.8)", // Dark Blue
                  borderColor: "rgba(0, 0, 139, 1)",
                  borderWidth: 1,
                },
                {
                  label: "SELL",
                  data: sellData,
                  backgroundColor: "rgba(220, 53, 69, 0.8)", // Red
                  borderColor: "rgba(220, 53, 69, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: executionFrequencyChart,
              set chart(c) {
                executionFrequencyChart = c;
              },
            },
            "bar",
            {
              indexAxis: "y", // Horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label; // Just show BUY or SELL
                    },
                    afterLabel: (context) => {
                      const symbol = context.label;
                      const tradeType = context.dataset.label;
                      const stats = assetStats[symbol][tradeType];
                      return [
                        `  Saldo: ${formatCurrency(
                          stats.cumulativeBalance,
                          "USD"
                        )}`,
                        `  Persentase: ${formatNumber(
                          stats.cumulativePercentage,
                          2
                        )}%`,
                        `  Pips/Points: ${formatNumber(
                          stats.cumulativePips,
                          0
                        )}`,
                        `  Total Trade: ${stats.tradeCount}`,
                      ];
                    },
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Akumulasi Saldo ($)",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: (val) => formatCurrency(val, "USD"),
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering execution frequency chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data frekuensi eksekusi: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      /**
       * Renders the horizontal bar chart for total executed trades per asset.
       */
      async function fetchAndRenderAssetExecutionCountChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "assetExecutionCountChart",
          "assetExecutionCountChartLoading",
          "assetExecutionCountChartError",
          "assetExecutionCountChartNoData"
        );
        try {
          const assetCounts = {};
          const relevantTrades = executedPlansData.filter(
            (trade) =>
              trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
          );

          relevantTrades.forEach((trade) => {
            const symbol = trade.symbol;
            assetCounts[symbol] = (assetCounts[symbol] || 0) + 1;
          });

          const sortedSymbols = Object.keys(assetCounts).sort(
            (a, b) => assetCounts[b] - assetCounts[a]
          );

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: assetExecutionCountChart,
                set chart(c) {
                  assetExecutionCountChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const data = sortedSymbols.map((symbol) => assetCounts[symbol]);

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data,
                  backgroundColor: "rgba(132, 204, 22, 0.8)", // Bright Green
                  borderColor: "rgba(101, 163, 13, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: assetExecutionCountChart,
              set chart(c) {
                assetExecutionCountChart = c;
              },
            },
            "bar",
            {
              indexAxis: "y", // Horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => `Jumlah Eksekusi: ${context.raw}`,
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Jumlah Eksekusi Selesai",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                    stepSize: 1, // Ensure ticks are integers
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering asset execution count chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data frekuensi aset: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // --- GANTI SELURUH FUNGSI fetchAndRenderOutcomeRadarChart LAMA DENGAN INI ---
      async function fetchAndRenderOutcomeRadarChart() {
        const chartConfig = {
          canvasId: "outcomeRadarChart",
          loadingId: "outcomeRadarChartLoading",
          errorId: "outcomeRadarChartError",
          noDataId: "outcomeRadarChartNoData",
        };
        const chartInstanceRef = {
          chart: outcomeRadarChart,
          set chart(c) {
            outcomeRadarChart = c;
          },
        };
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );
        const titleElement = document.getElementById("outcomeChartTitle");

        try {
          const outcomeCounts = {
            "Take Profit": 0,
            "Stop Loss": 0,
            Tes: 0,
            Cancel: 0,
          };
          let totalExecutions = 0; // Hitung total di sini

          executedPlansData.forEach((trade) => {
            if (trade.outcome && outcomeCounts.hasOwnProperty(trade.outcome)) {
              outcomeCounts[trade.outcome]++;
              totalExecutions++; // Tambahkan ke total
            }
          });

          // Update judul dengan total eksekusi
          if (titleElement) {
            titleElement.textContent = `Ringkasan Hasil Eksekusi (Total: ${totalExecutions})`;
          }

          if (totalExecutions === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartInstanceRef,
              "radar",
              {}
            );
            return;
          }

          const labels = Object.keys(outcomeCounts);
          const data = Object.values(outcomeCounts);

          handleChartData(
            {
              labels: labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data: data,
                  fill: true,
                  backgroundColor: "rgba(42, 42, 42, 0.2)",
                  borderColor: "rgba(42, 42, 42, 1)",
                  borderWidth: 1,
                  pointBackgroundColor: "rgba(42, 42, 42, 1)",
                  pointBorderColor: "#fff",
                  pointHoverBackgroundColor: "#fff",
                  pointHoverBorderColor: "rgba(42, 42, 42, 1)",
                },
              ],
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "radar",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                // ▼▼▼ PERBAIKAN: Modifikasi Tooltip ▼▼▼
                tooltip: {
                  enabled: true, // Pastikan tooltip aktif
                  callbacks: {
                    label: function (context) {
                      // context.label berisi nama outcome (misal: "Take Profit")
                      // context.raw berisi jumlah untuk outcome tersebut
                      const outcomeLabel = context.label || "";
                      const outcomeCount = context.raw || 0;
                      // Ambil total eksekusi dari variabel di scope luar
                      return `Total Eksekusi: ${totalExecutions}, ${outcomeLabel}: ${outcomeCount}`;
                    },
                  },
                },
                // ▲▲▲ AKHIR PERBAIKAN TOOLTIP ▲▲▲
              },
              scales: {
                r: { // 'r' adalah untuk sumbu radial (nilai)
                  beginAtZero: true,
                  // ▼▼▼ PERBAIKAN: Sembunyikan angka di skala radial ▼▼▼
                  ticks: {
                    display: false, // Sembunyikan label angka (0, 10, 20, dst.)
                    stepSize: 1,
                    // backdropColor: 'rgba(255, 255, 255, 0.75)' // Hapus backdrop jika ticks disembunyikan
                  },
                  // ▲▲▲ AKHIR PERBAIKAN TICKS ▲▲▲
                  pointLabels: { // Label di sudut (Take Profit, Stop Loss, dll.)
                    font: {
                      size: 10,
                      family: "Inter",
                    },
                     color: '#555' // Warna label sudut
                  },
                   grid: {
                       color: '#e0e0e0' // Warna garis grid radial
                   },
                   angleLines: {
                       color: '#e0e0e0' // Warna garis sudut
                   }
                },
              },
               // Tambahkan opsi interaksi jika ingin tooltip muncul saat klik (lebih kompleks)
               // onClick: (event, elements) => { /* Logika custom untuk menampilkan tooltip */ }
            }
          );
        } catch (err) {
          console.error("Error rendering outcome radar chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data ringkasan hasil: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }
      // --- AKHIR DARI FUNGSI fetchAndRenderOutcomeRadarChart ---

      async function fetchAndRenderCombinedCumulativeChart() {
        const chartConfig = {
          canvasId: "combinedCumulativeChart",
          loadingId: "combinedCumulativeChartLoading",
          errorId: "combinedCumulativeChartError",
          noDataId: "combinedCumulativeChartNoData",
        };
        const chartInstanceRef = {
          chart: combinedCumulativeChart,
          set chart(c) {
            combinedCumulativeChart = c;
          },
        };
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );

        try {
          // --- PERBAIKAN: Selalu filter dan urutkan data sebelum digunakan ---
          const sortedTrades = executedPlansData
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            // Jika tidak ada data, panggil handleChartData dengan data kosong
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartInstanceRef,
              "line",
              {} // Opsi default kosong
            );
            return; // Keluar dari fungsi
          }

          // Persiapan data untuk grafik (seperti kode Anda sebelumnya)
          const labels = ["Mulai"],
            balanceData = [],
            percentageData = [],
            pipsData = [];
          const initialBalance = sortedTrades[0].balance;
          let currentBalance = initialBalance;
          let currentCumulativePips = 0;

          balanceData.push(initialBalance);
          percentageData.push(0);
          pipsData.push(0);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            currentCumulativePips += getTradeResult(trade).isWin
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;
            const currentPercentage =
              initialBalance > 0
                ? ((currentBalance - initialBalance) / initialBalance) * 100
                : 0;

            labels.push(
              new Date(trade.timestamp).toLocaleDateString("id-ID", {
                day: "2-digit",
                month: "short", // Gunakan bulan singkat agar label tidak terlalu panjang
              })
            );
            balanceData.push(currentBalance);
            percentageData.push(currentPercentage);
            pipsData.push(currentCumulativePips);
          });

          // --- Opsi Grafik (Dengan Font Kecil) ---
          const chartOptions = {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                    position: "top",
                    labels: {
                        font: { size: 9 }, // Font legenda kecil
                        padding: 10,
                        boxWidth: 10,
                    }
                 },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  titleFont: { size: 10 }, // Font judul tooltip kecil
                  bodyFont: { size: 9 },   // Font isi tooltip kecil
                  padding: 8,
                  callbacks: {
                    label: function (context) {
                      let label = context.dataset.label || "";
                      if (label) {
                        label += ": ";
                      }
                      if (context.parsed.y !== null) {
                        if (context.dataset.yAxisID === "yBalance") {
                          label += formatCurrency(context.parsed.y, "USD");
                        } else if (context.dataset.yAxisID === "yPercentage") {
                          label += `${formatNumber(context.parsed.y, 2)}%`;
                        } else { // yPips
                          label += formatNumber(context.parsed.y, 0);
                        }
                      }
                      return label;
                    },
                  },
                },
              },
              scales: {
                x: {
                    ticks: {
                        autoSkip: true,
                        maxTicksLimit: window.innerWidth < 768 ? 5 : 10, // Kurangi label di HP
                        font: { size: 8 } // Font sumbu X kecil
                    },
                    grid: {
                        display: false
                    }
                },
                yBalance: { // Sumbu Y untuk Saldo (Kiri)
                  type: "linear",
                  display: true,
                  position: "left",
                  title: {
                      display: true,
                      text: "Saldo ($)",
                      font: {size: 9} // Font judul sumbu kecil
                  },
                  ticks: {
                      callback: (value) => formatCurrency(value, "USD"),
                      font: { size: 8 }, // Font label sumbu Y kecil
                      maxTicksLimit: 6
                   },
                   grid: {
                       color: "#e0e0e0",
                       borderDash: [2, 3]
                   }
                },
                yPercentage: { // Sumbu Y untuk Persentase (Kanan)
                  type: "linear",
                  display: true,
                  position: "right",
                  title: {
                      display: true,
                      text: "Persen (%)",
                      font: {size: 9} // Font judul sumbu kecil
                  },
                  ticks: {
                      callback: (value) => `${formatNumber(value, 1)}%`,
                      font: { size: 8 }, // Font label sumbu Y kecil
                      maxTicksLimit: 6
                  },
                  grid: { drawOnChartArea: false }, // Jangan gambar grid untuk sumbu ini
                },
                yPips: { // Sumbu Y untuk Pips (Tersembunyi)
                  type: "linear",
                  display: false,
                },
              },
               interaction: {
                    mode: 'index',
                    intersect: false,
               },
                animation: {
                    duration: 500,
                    easing: 'easeOutQuad'
               }
            };

          // --- PERBAIKAN: Pastikan handleChartData dipanggil (tidak dikomentari) ---
          handleChartData(
            {
              labels: labels,
              datasets: [
                {
                  label: "Saldo Akun ($)",
                  data: balanceData,
                  borderColor: "#2a2a2a", // Hitam
                  backgroundColor: "rgba(42, 42, 42, 0.1)",
                  yAxisID: "yBalance", // Kaitkan ke sumbu kiri
                  tension: 0.3,
                  borderWidth: 2,
                   pointRadius: 1,
                   pointHoverRadius: 4
                },
                {
                  label: "Persentase (%)",
                  data: percentageData,
                  borderColor: "#007bff", // Biru
                  backgroundColor: "rgba(0, 123, 255, 0.1)",
                  yAxisID: "yPercentage", // Kaitkan ke sumbu kanan
                  tension: 0.3,
                  borderWidth: 1.5,
                   pointRadius: 1,
                   pointHoverRadius: 4
                },
                {
                  label: "Pips/Points", // Tetap ada tapi tidak terlihat
                  data: pipsData,
                  borderColor: "#ffc107", // Kuning
                  backgroundColor: "rgba(255, 193, 7, 0.1)",
                  yAxisID: "yPips", // Kaitkan ke sumbu tersembunyi
                  hidden: true, // Sembunyikan dataset ini dari legenda dan tampilan awal
                  tension: 0.3,
                  borderWidth: 1.5,
                   pointRadius: 1,
                   pointHoverRadius: 4
                },
              ]
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "line",
            chartOptions // Gunakan opsi yang sudah dimodifikasi
          );
          // --- AKHIR PERBAIKAN ---

        } catch (err) {
          console.error("Error rendering combined cumulative chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data gabungan: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // ▼▼▼ FUNGSI BARU: GHOST EQUITY CHART ▼▼▼
      async function fetchAndRenderGhostEquityChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "ghostEquityChart",
          "ghostEquityChartLoading",
          "ghostEquityChartError",
          "ghostEquityChartNoData"
        );
        const chartInstanceRef = {
          chart: ghostEquityChart,
          set chart(c) { ghostEquityChart = c; },
        };

        try {
          // Filter & Sort Data
          const sortedTrades = executedPlansData
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            handleChartData({ labels: [], datasets: [] }, { canvas, loading, error, noData }, chartInstanceRef, "line", {});
            return;
          }

          const labels = ["Mulai"];
          const actualData = [];
          const ghostData = []; // Data Murni

          const initialBalance = sortedTrades[0].balance;
          let currentActualBalance = initialBalance;
          let currentGhostBalance = initialBalance;

          // Push titik awal
          actualData.push(initialBalance);
          ghostData.push(initialBalance);

          sortedTrades.forEach((trade) => {
            const result = getTradeResult(trade);
            
            // 1. Hitung Aktual (Intervensi)
            const actualPL = result.profitLoss;
            currentActualBalance += actualPL;

            // 2. Hitung Ghost (Murni)
            // Ambil original jika ada, jika tidak fallback ke aktual
            let ghostPL = 0;
            if (result.isWin) {
                // Jika TP, pakai original TP
                ghostPL = (trade.originalNettTP !== undefined) ? trade.originalNettTP : trade.nettTP;
            } else {
                // Jika SL, pakai original SL
                ghostPL = (trade.originalNettSL !== undefined) ? trade.originalNettSL : trade.nettSL;
            }
            currentGhostBalance += ghostPL;

            labels.push(new Date(trade.timestamp).toLocaleDateString("id-ID", { day: "numeric", month: "short" }));
            actualData.push(currentActualBalance);
            ghostData.push(currentGhostBalance);
          });

          handleChartData(
            {
              labels: labels,
              datasets: [
                {
                  label: "Ekuitas Aktual (Intervensi)",
                  data: actualData,
                  borderColor: "#0ea5e9", // Sky Blue
                  backgroundColor: "rgba(14, 165, 233, 0.1)",
                  borderWidth: 2,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  fill: true,
                  tension: 0.3
                },
                {
                  label: "Ekuitas Murni (Tanpa Edit)",
                  data: ghostData,
                  borderColor: "#64748b", // Slate Gray
                  borderDash: [5, 5], // Garis putus-putus
                  backgroundColor: "rgba(0,0,0,0)",
                  borderWidth: 2,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  fill: false,
                  tension: 0.3
                }
              ]
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              plugins: {
                legend: { position: 'top', align: 'end', labels: { boxWidth: 10, font: { size: 10 } } },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.dataset.label}: ${formatCurrency(ctx.raw, "USD")}`
                  }
                }
              },
              scales: {
                x: { ticks: { font: { size: 8 }, maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }, grid: { display: false } },
                y: { ticks: { font: { size: 9 }, callback: (v) => formatCurrency(v, "USD") }, grid: { color: '#f3f4f6' } }
              }
            }
          );

        } catch (err) {
          console.error("Error rendering Ghost Equity chart:", err);
          loading.classList.add("hidden");
          error.textContent = err.message;
          error.classList.remove("hidden");
        }
      }

      // ▼▼▼ FUNGSI BARU: HITUNG SQN SCORE ▼▼▼
      function calculateAndRenderSQN() {
        const sqnValueEl = document.getElementById('sqnScoreValue');
        const sqnLabelEl = document.getElementById('sqnScoreLabel');
        const avgProfitEl = document.getElementById('sqnAvgProfit');
        const stdDevEl = document.getElementById('sqnStdDev');

        if (!sqnValueEl) return;

        const relevantTrades = executedPlansData.filter(t => getTradeResult(t).isValid);
        
        // SQN butuh minimal 30 data untuk valid statistik, tapi kita hitung saja apa adanya
        if (relevantTrades.length < 2) {
            sqnValueEl.textContent = "0.00";
            sqnLabelEl.textContent = "Data Belum Cukup (< 2)";
            sqnLabelEl.className = "text-sm font-medium mt-2 px-3 py-1 rounded-full bg-gray-100 text-gray-500 inline-block";
            return;
        }

        // 1. Kumpulkan nilai Profit/Loss (R-Multiple lebih akurat, tapi pakai $ P/L lebih mudah dipahami umum)
        // Kita pakai $ P/L agar konsisten dengan chart
        const pnlData = relevantTrades.map(t => getTradeResult(t).profitLoss);
        const n = pnlData.length;

        // 2. Hitung Rata-rata (Mean)
        const totalPnL = pnlData.reduce((sum, val) => sum + val, 0);
        const avgPnL = totalPnL / n;

        // 3. Hitung Standar Deviasi
        const variance = pnlData.reduce((sum, val) => sum + Math.pow(val - avgPnL, 2), 0) / n;
        const stdDev = Math.sqrt(variance);

        // 4. Hitung SQN
        // Rumus: (Avg / StdDev) * sqrt(N)
        let sqn = 0;
        if (stdDev > 0) {
            sqn = (avgPnL / stdDev) * Math.sqrt(n);
        }

        // 5. Tentukan Kategori
        let label = "";
        let colorClass = ""; // bg-color text-color

        if (sqn < 1.6) { label = "Buruk / Acak"; colorClass = "bg-red-100 text-red-700"; }
        else if (sqn < 2.0) { label = "Rata-rata"; colorClass = "bg-yellow-100 text-yellow-700"; }
        else if (sqn < 2.5) { label = "Bagus"; colorClass = "bg-blue-100 text-blue-700"; }
        else if (sqn < 3.0) { label = "Sangat Bagus"; colorClass = "bg-green-100 text-green-700"; }
        else if (sqn < 5.0) { label = "Luar Biasa"; colorClass = "bg-purple-100 text-purple-700"; }
        else { label = "Holy Grail"; colorClass = "bg-indigo-100 text-indigo-700 font-bold"; }

        // 6. Render
        sqnValueEl.textContent = formatNumber(sqn, 2);
        sqnLabelEl.textContent = label;
        sqnLabelEl.className = `text-sm font-medium mt-2 px-3 py-1 rounded-full inline-block ${colorClass}`;
        
        avgProfitEl.textContent = formatCurrency(avgPnL, "USD");
        stdDevEl.textContent = formatCurrency(stdDev, "USD");
      }
      // ▲▲▲ AKHIR FUNGSI BARU ▲▲▲

      // --- NEW: Compounding Simulator Logic ---
      function calculateProjectionData(dataType) {
        const simBalanceInput = document.getElementById("simBalance");
        const simMonthlyTargetInput =
          document.getElementById("simMonthlyTarget");
        const simPeriodInput = document.getElementById("simPeriod");

        const startBalance = parseFloat(simBalanceInput.value);
        const monthlyTarget = parseFloat(simMonthlyTargetInput.value) / 100;
        const periodMonths = parseInt(simPeriodInput.value);

        const projectionLabels = [];
        const projectionData = [];

        if (
          isNaN(startBalance) ||
          isNaN(monthlyTarget) ||
          isNaN(periodMonths) ||
          periodMonths <= 0
        ) {
          return { projectionLabels, projectionData };
        }

        const sortedTrades = [...executedPlansData]
          .filter((t) => t.outcome !== "Cancel" && t.outcome !== "Tes")
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        let lastTradeDate =
          sortedTrades.length > 0
            ? new Date(sortedTrades[sortedTrades.length - 1].timestamp)
            : new Date();
        let currentProjectedBalance = startBalance;
        let historicalInitialBalance =
          sortedTrades.length > 0 ? sortedTrades[0].balance : startBalance;

        for (let i = 1; i <= periodMonths; i++) {
          currentProjectedBalance *= 1 + monthlyTarget;
          const projectedDate = new Date(lastTradeDate);
          projectedDate.setMonth(projectedDate.getMonth() + i);

          projectionLabels.push(
            projectedDate.toLocaleString("id-ID", {
              day: "numeric",
              month: "short",
              year: "numeric",
            })
          );

          if (dataType === "balance") {
            projectionData.push(currentProjectedBalance);
          } else if (dataType === "percentage") {
            const percentageChange =
              historicalInitialBalance > 0
                ? ((currentProjectedBalance - historicalInitialBalance) /
                    historicalInitialBalance) *
                  100
                : 0;
            projectionData.push(percentageChange);
          }
        }
        return { projectionLabels, projectionData };
      }

      // --- GANTI FUNGSI LAMA DI BAWAH INI DENGAN YANG BARU ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      function handleImageUpload(event, target) {
        const files = event.target.files;
        if (files.length === 0) return;

        currentUploadTarget = target;
        const isBanner = target === "16:4";
        // Gunakan array yang sudah disaring dari nilai null/undefined untuk pengecekan batas
        const photoArray = isBanner
          ? bannerPhotos.filter(Boolean)
          : userPhotos.filter(Boolean);
        const maxPhotos = isBanner ? MAX_BANNER_PHOTOS : MAX_PHOTOS;

        if (photoArray.length >= maxPhotos) {
          showMessageBox(
            "Batas Unggahan Tercapai",
            `Anda hanya dapat mengunggah maksimal ${maxPhotos} foto untuk galeri ini.`,
            false
          );
          event.target.value = ""; // Reset input
          return;
        }

        const file = files[0];
        if (!file || !file.type.startsWith("image/")) {
          showMessageBox(
            "Gagal",
            "Silakan pilih file gambar yang valid.",
            false
          );
          event.target.value = ""; // Reset input
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const imageDataUrl = e.target.result;

          if (isBanner) {
            // PERBAIKAN: Logika disederhanakan untuk memastikan data disimpan dan dirender dengan benar.
            try {
              // 1. Tambahkan foto baru ke array data menggunakan 'push'.
              bannerPhotos.push(imageDataUrl);

              // 2. Simpan seluruh array yang sudah diperbarui ke localStorage.
              saveBannerPhotosToLocalStorage();

              // 3. Atur indeks agar foto yang baru diunggah yang ditampilkan.
              currentBannerPhotoIndex = bannerPhotos.length - 1;

              // 4. Panggil fungsi untuk merender ulang galeri dengan data baru.
              renderBannerGallery();

              // 5. Beri tahu pengguna bahwa proses berhasil setelah semuanya selesai.
              showMessageBox(
                "Berhasil",
                "Foto banner berhasil diunggah.",
                false
              );
            } catch (error) {
              console.error("Gagal menyimpan foto banner:", error);
              showMessageBox(
                "Gagal Unggah",
                "Terjadi kesalahan saat mengunggah foto banner.",
                false
              );
            }
          } else {
            // Logika untuk galeri 1:1 (tidak berubah)
            currentImageToCrop = new Image();
            currentImageToCrop.onload = () => {
              const modalCanvasContainer = photoUploadModal.querySelector(
                ".flex.justify-center.items-center"
              );
              const canvasSize = 600;

              modalCanvasContainer.style.aspectRatio = `1 / 1`;
              imageCanvas.width = canvasSize;
              imageCanvas.height = canvasSize;

              const modalTitle = photoUploadModal.querySelector("h3");
              modalTitle.textContent = `Unggah & Pangkas Foto (1:1)`;

              drawImageCover(
                ctx,
                currentImageToCrop,
                imageCanvas.width,
                imageCanvas.height,
                1 / 1
              );
              showModal(photoUploadModal);
            };
            currentImageToCrop.src = imageDataUrl;
          }
        };
        reader.readAsDataURL(file);
        event.target.value = ""; // Reset input agar bisa unggah file yang sama lagi
      }

      function handleSimulatorInputChange() {
        // Save data to local storage whenever it changes
        saveSimulatorData();
        // This function triggers the re-rendering of the charts that need projection lines.
        // The chart rendering functions themselves will read the simulator inputs.
        if (
          chartSections.overallBalanceCumulativeStatisticsSection.hasRendered
        ) {
          fetchAndRenderOverallBalanceCumulativeChart();
        }
        if (
          chartSections.overallPercentageCumulativeStatisticsSection.hasRendered
        ) {
          fetchAndRenderOverallPercentageCumulativeChart();
        }
      }

      // --- PERBAIKAN STRUKTURAL: BLOK FUNGSI RINGKASAN DIPINDAHKAN KE SINI (LINGKUP GLOBAL) ---

      /**
       * Helper function to get the week number of a date.
       * @param {Date} d The date.
       * @returns {number} The week number.
       */
      function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
        return weekNo;
      }

      // ▼▼▼ GANTI SELURUH FUNGSI LAMA (baris 2824-2920) DENGAN INI ▼▼▼
/**
 * PERBAIKAN: Menghitung dan merender data untuk "Resiko Harian".
 * Logika baru: Menghitung (P/L Selesai) - (Risiko Aktif) - (Risiko Rencana Baru)
 * Sisa (Remaining) tetap dihitung berdasarkan risiko (Aktif + Selesai).
 */
function renderDailyRiskSummary() {
  // Ambil semua elemen DOM baru
  const percentageNowEl = document.getElementById("dailyRiskPercentageNow");
  const percentageEl = document.getElementById("dailyRiskPercentage");
  const percentageRemainingEl = document.getElementById(
    "dailyRiskPercentageRemaining"
  );
  const pipsNowEl = document.getElementById("dailyRiskPipsNow");
  const pipsEl = document.getElementById("dailyRiskPips");
  const pipsRemainingEl = document.getElementById("dailyRiskPipsRemaining");
  const dolarEl = document.getElementById("dailyRiskDolar");
  const lotEl = document.getElementById("dailyRiskLot");

  if (
    !percentageNowEl ||
    !percentageEl ||
    !percentageRemainingEl ||
    !pipsNowEl ||
    !pipsEl ||
    !pipsRemainingEl ||
    !dolarEl ||
    !lotEl
  ) {
    console.warn("Elemen DOM Risiko Harian tidak ditemukan. Dilewati.");
    return;
  }

  const today = new Date().toISOString().slice(0, 10);

  // 1. Ambil data eksekusi HARI INI saja (TP atau SL)
  const executedToday = executedPlansData.filter(
    (p) =>
      p.timestamp && p.timestamp.startsWith(today) && getTradeResult(p).isValid
  );

  // 2. Hitung total RISIKO (nilai positif) dari Rencana Aktif
  const runningRiskPct = runningPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const runningSlPips = runningPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const runningNettSL_Risk = runningPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const runningLot = runningPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );

  // ▼▼▼ PERBAIKAN: 2.5. Hitung total RISIKO dari Rencana Trading BARU ▼▼▼
  // (Data "Rencana Baru" tidak punya timestamp harian, jadi kita asumsikan semua dihitung)
  const newPlansRiskPct = calculatedPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const newPlansSlPips = calculatedPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const newPlansNettSL_Risk = calculatedPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const newPlansLot = calculatedPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );
  // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

  // 3. Hitung total P/L (bisa positif/negatif) dari Rencana Selesai HARI INI
  let executedPL_Pct = 0;
  let executedPL_Pips = 0;
  let executedPL_Dolar = 0;
  let executedRisk_Pct_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedRisk_Pips_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedLot_Today = 0;

  executedToday.forEach((p) => {
    const tradeResult = getTradeResult(p);

    // Akumulasi P/L (Profit/Loss)
    if (tradeResult.isWin) {
      // Jika Take Profit (TP)
      executedPL_Pct += p.rrPercentage?.tp || 0;
      executedPL_Pips += getVisualPoints(p.tpPips, p.symbol, false).forCalc;
    } else {
      // Jika Stop Loss (SL)
      executedPL_Pct -= p.rrPercentage?.sl || 0;
      executedPL_Pips -= getVisualPoints(p.slPips, p.symbol, false).forCalc;
    }
    executedPL_Dolar += tradeResult.profitLoss; // Ini sudah (positif/negatif)

    // Akumulasi RISIKO (hanya SL, untuk batas 'Sisa')
    executedRisk_Pct_ForLimit += p.rrPercentage?.sl || 0;
    executedRisk_Pips_ForLimit += getVisualPoints(
      p.slPips,
      p.symbol,
      false
    ).forCalc;

    // Akumulasi Lot
    executedLot_Today += p.lotSize || 0;
  });

  // 4. Hitung Total Akumulasi (P/L Selesai - Risiko Aktif - Risiko BARU)
  const totalAccumulatedPct =
    executedPL_Pct - runningRiskPct - newPlansRiskPct; // <-- PERBAIKAN
  const totalAccumulatedPips =
    executedPL_Pips - runningSlPips - newPlansSlPips; // <-- PERBAIKAN
  const totalAccumulatedDolar =
    executedPL_Dolar - runningNettSL_Risk - newPlansNettSL_Risk; // <-- PERBAIKAN
  const totalAccumulatedLot = runningLot + executedLot_Today + newPlansLot; // <-- PERBAIKAN

  // 5. Hitung Total RISIKO (untuk 'Sisa') (Risiko Aktif + Risiko Selesai Harian)
  // (Logika ini TIDAK DIUBAH, karena 'Sisa' terkait dengan 'checkAllTradeLimits')
  const totalDailyRiskPct_ForLimit = runningRiskPct + executedRisk_Pct_ForLimit;
  const totalDailySlPips_ForLimit = runningSlPips + executedRisk_Pips_ForLimit;

  // 6. Tentukan Batas (sesuai perbaikan terakhir Anda)
  const DAILY_RISK_PERCENT_LIMIT = 3.5;
  const DAILY_RISK_PIPS_LIMIT = 5000;

  // 7. Hitung Sisa (berdasarkan P/L Selesai Hari Ini)
  // (Logika ini TIDAK DIUBAH)
  const currentPercentLimit = Math.min(
    DAILY_RISK_PERCENT_LIMIT,
    DAILY_RISK_PERCENT_LIMIT + executedPL_Pct
  );
  const currentPipsLimit = Math.min(
    DAILY_RISK_PIPS_LIMIT,
    DAILY_RISK_PIPS_LIMIT + executedPL_Pips
  );
  // ▼▼▼ PERBAIKAN: Kurangi juga risiko dari Rencana BARU ▼▼▼
  const remainingPct = currentPercentLimit - runningRiskPct - newPlansRiskPct;
  const remainingPips = currentPipsLimit - runningSlPips - newPlansSlPips;
  // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

  // 8. Render ke UI
  percentageNowEl.textContent = `${formatNumber(executedPL_Pct, 2)}%`;
  applyColor(percentageNowEl, executedPL_Pct);
  // --- Presentase ---
  percentageEl.textContent = `${formatNumber(totalAccumulatedPct, 2)}%`;
  applyColor(percentageEl, totalAccumulatedPct); // Terapkan warna P/L
  percentageRemainingEl.textContent = `Sisa: ${formatNumber(remainingPct, 2)}%`;
  applyColor(percentageRemainingEl, remainingPct); // Sisa juga diwarnai (merah jika minus)

  pipsNowEl.textContent = `${formatNumber(executedPL_Pips, 0)}`;
  applyColor(pipsNowEl, executedPL_Pips);

  // --- Pips ---
  pipsEl.textContent = `${formatNumber(totalAccumulatedPips, 0)}`;
  applyColor(pipsEl, totalAccumulatedPips); // Terapkan warna P/L
  pipsRemainingEl.textContent = `Sisa: ${formatNumber(remainingPips, 0)}`;
  applyColor(pipsRemainingEl, remainingPips); // Sisa juga diwarnai (merah jika minus)

  // --- Dolar ---
  dolarEl.textContent = `${formatCurrency(totalAccumulatedDolar, "USD")}`;
  applyColor(dolarEl, totalAccumulatedDolar); // Terapkan warna P/L

  // --- Lot ---
  lotEl.textContent = `${formatNumber(totalAccumulatedLot, 2)}`;
  applyColor(lotEl, 1); // Lot selalu positif (hitam)
}
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 1 ▲▲▲

      /**
       * Fungsi helper baru untuk menerapkan kelas warna.
       * @param {HTMLElement} el Elemen DOM.
       * @param {number} value Nilai untuk dicek.
       */
      function applyColor(el, value) {
        if (!el) return;
        el.classList.remove("positive-value", "negative-value");
        if (value < 0) {
          el.classList.add("negative-value"); // .negative-value adalah MERAH
        } else {
          el.classList.add("positive-value"); // .positive-value adalah HITAM
        }
      }

      

      // ▼▼▼ GANTI SELURUH FUNGSI LAMA (baris 2938-3097) DENGAN INI ▼▼▼
/**
 * PERBAIKAN: Menghitung dan merender data untuk "Resiko Bulanan".
 * Logika baru: Menghitung (P/L Selesai) - (Risiko Aktif) - (Risiko Rencana Baru)
 * Sisa (Remaining) tetap dihitung berdasarkan risiko (Aktif + Selesai).
 */
function renderMonthlyRiskSummary() {
  // Ambil semua elemen DOM baru
  const percentageNowEl = document.getElementById("monthlyRiskPercentageNow");
  const percentageEl = document.getElementById("monthlyRiskPercentage");
  const percentageRemainingEl = document.getElementById(
    "monthlyRiskPercentageRemaining"
  );
  const pipsNowEl = document.getElementById("monthlyRiskPipsNow");
  const pipsEl = document.getElementById("monthlyRiskPips");
  const pipsRemainingEl = document.getElementById("monthlyRiskPipsRemaining");
  const dolarEl = document.getElementById("monthlyRiskDolar");
  const lotEl = document.getElementById("monthlyRiskLot");

  if (
    !percentageNowEl ||
    !percentageEl ||
    !percentageRemainingEl ||
    !pipsNowEl ||
    !pipsEl ||
    !pipsRemainingEl ||
    !dolarEl ||
    !lotEl
  ) {
    console.warn("Elemen DOM Risiko Bulanan tidak ditemukan. Dilewati.");
    return;
  }

  const now = new Date();
  const currentMonthKey = now.toISOString().slice(0, 7); // Format: YYYY-MM

  // 1. Ambil data eksekusi BULAN INI saja (TP atau SL)
  const executedThisMonth = executedPlansData.filter(
    (p) =>
      p.timestamp &&
      p.timestamp.startsWith(currentMonthKey) &&
      getTradeResult(p).isValid
  );

  // 2. Hitung total RISIKO (nilai positif) dari Rencana Aktif
  const runningRiskPct = runningPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const runningSlPips = runningPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const runningNettSL_Risk = runningPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const runningLot = runningPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );

  // ▼▼▼ PERBAIKAN: 2.5. Hitung total RISIKO dari Rencana Trading BARU ▼▼▼
  // (Data "Rencana Baru" dianggap bagian dari risiko bulanan saat ini)
  const newPlansRiskPct = calculatedPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const newPlansSlPips = calculatedPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const newPlansNettSL_Risk = calculatedPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const newPlansLot = calculatedPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );
  // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

  // 3. Hitung total P/L (bisa positif/negatif) dari Rencana Selesai BULAN INI
  let executedPL_Pct = 0;
  let executedPL_Pips = 0;
  let executedPL_Dolar = 0;
  let executedRisk_Pct_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedRisk_Pips_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedLot_ThisMonth = 0;

  executedThisMonth.forEach((p) => {
    const tradeResult = getTradeResult(p);

    if (tradeResult.isWin) {
      executedPL_Pct += p.rrPercentage?.tp || 0;
      executedPL_Pips += getVisualPoints(p.tpPips, p.symbol, false).forCalc;
    } else {
      executedPL_Pct -= p.rrPercentage?.sl || 0;
      executedPL_Pips -= getVisualPoints(p.slPips, p.symbol, false).forCalc;
    }
    executedPL_Dolar += tradeResult.profitLoss;

    executedRisk_Pct_ForLimit += p.rrPercentage?.sl || 0;
    executedRisk_Pips_ForLimit += getVisualPoints(
      p.slPips,
      p.symbol,
      false
    ).forCalc;
    executedLot_ThisMonth += p.lotSize || 0;
  });

  // 4. Hitung Total Akumulasi (P/L Selesai Bulanan - Risiko Aktif - Risiko BARU)
  const totalAccumulatedPct =
    executedPL_Pct - runningRiskPct - newPlansRiskPct; // <-- PERBAIKAN
  const totalAccumulatedPips =
    executedPL_Pips - runningSlPips - newPlansSlPips; // <-- PERBAIKAN
  const totalAccumulatedDolar =
    executedPL_Dolar - runningNettSL_Risk - newPlansNettSL_Risk; // <-- PERBAIKAN
  const totalAccumulatedLot =
    runningLot + executedLot_ThisMonth + newPlansLot; // <-- PERBAIKAN

  // 5. Hitung Total RISIKO (untuk 'Sisa') (Risiko Aktif + Risiko Selesai Bulanan)
  // (Logika ini TIDAK DIUBAH)
  const totalMonthlyRiskPct_ForLimit =
    runningRiskPct + executedRisk_Pct_ForLimit;
  const totalMonthlySlPips_ForLimit =
    runningSlPips + executedRisk_Pips_ForLimit;

  // 6. Tentukan Batas (sesuai perbaikan terakhir Anda)
  const MONTHLY_RISK_PERCENT_LIMIT = 5.0;
  const MONTHLY_RISK_PIPS_LIMIT = 8000;

  // 7. Hitung Sisa (berdasarkan P/L Selesai Hari Ini)
  // (Logika ini TIDAK DIUBAH)
  const currentPercentLimit = Math.min(
    MONTHLY_RISK_PERCENT_LIMIT,
    MONTHLY_RISK_PERCENT_LIMIT + executedPL_Pct
  );
  const currentPipsLimit = Math.min(
    MONTHLY_RISK_PIPS_LIMIT,
    MONTHLY_RISK_PIPS_LIMIT + executedPL_Pips
  );
  // ▼▼▼ PERBAIKAN: Kurangi juga risiko dari Rencana BARU ▼▼▼
  const remainingPct = currentPercentLimit - runningRiskPct - newPlansRiskPct;
  const remainingPips = currentPipsLimit - runningSlPips - newPlansSlPips;
  // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

  // 8. Render ke UI
  percentageNowEl.textContent = `${formatNumber(executedPL_Pct, 2)}%`;
  applyColor(percentageNowEl, executedPL_Pct);

  percentageEl.textContent = `${formatNumber(totalAccumulatedPct, 2)}%`;
  applyColor(percentageEl, totalAccumulatedPct);
  percentageRemainingEl.textContent = `Sisa: ${formatNumber(remainingPct, 2)}%`;
  applyColor(percentageRemainingEl, remainingPct);

  pipsNowEl.textContent = `${formatNumber(executedPL_Pips, 0)}`;
  applyColor(pipsNowEl, executedPL_Pips);

  pipsEl.textContent = `${formatNumber(totalAccumulatedPips, 0)}`;
  applyColor(pipsEl, totalAccumulatedPips);
  pipsRemainingEl.textContent = `Sisa: ${formatNumber(remainingPips, 0)}`;
  applyColor(pipsRemainingEl, remainingPips);

  dolarEl.textContent = `${formatCurrency(totalAccumulatedDolar, "USD")}`;
  applyColor(dolarEl, totalAccumulatedDolar);

  lotEl.textContent = `${formatNumber(totalAccumulatedLot, 2)}`;
  applyColor(lotEl, 1);
}

// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 2 ▲▲▲

// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 2 ▲▲▲

// ▼▼▼ TAMBAHKAN FUNGSI BARU INI (MAKSIMAL DRAWDOWN) ▼▼▼
/**
 * Salinan dari renderMonthlyRiskSummary, tetapi untuk Maksimal Drawdown (-7%).
 * Logika: Menghitung (P/L Selesai) - (Risiko Aktif) - (Risiko Rencana Baru)
 */
function renderMaxDrawdownRiskSummary() {
  // Ambil semua elemen DOM baru
  const percentageNowEl = document.getElementById("maxDrawdownRiskPercentageNow");
  const percentageEl = document.getElementById("maxDrawdownRiskPercentage");
  const percentageRemainingEl = document.getElementById(
    "maxDrawdownRiskPercentageRemaining"
  );
  const pipsNowEl = document.getElementById("maxDrawdownRiskPipsNow");
  const pipsEl = document.getElementById("maxDrawdownRiskPips");
  const pipsRemainingEl = document.getElementById("maxDrawdownRiskPipsRemaining");
  const dolarEl = document.getElementById("maxDrawdownRiskDolar");
  const lotEl = document.getElementById("maxDrawdownRiskLot");

  if (
    !percentageNowEl ||
    !percentageEl ||
    !percentageRemainingEl ||
    !pipsNowEl ||
    !pipsEl ||
    !pipsRemainingEl ||
    !dolarEl ||
    !lotEl
  ) {
    console.warn("Elemen DOM Risiko Maksimal Drawdown tidak ditemukan. Dilewati.");
    return;
  }

  const now = new Date();
  const currentMonthKey = now.toISOString().slice(0, 7); // Format: YYYY-MM

  // 1. Ambil data eksekusi BULAN INI saja (TP atau SL)
  const executedThisMonth = executedPlansData.filter(
    (p) =>
      p.timestamp &&
      p.timestamp.startsWith(currentMonthKey) &&
      getTradeResult(p).isValid
  );

  // 2. Hitung total RISIKO (nilai positif) dari Rencana Aktif
  const runningRiskPct = runningPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const runningSlPips = runningPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const runningNettSL_Risk = runningPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const runningLot = runningPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );

  // 2.5. Hitung total RISIKO dari Rencana Trading BARU
  const newPlansRiskPct = calculatedPlansData.reduce(
    (sum, p) => sum + (p.rrPercentage?.sl || 0),
    0
  );
  const newPlansSlPips = calculatedPlansData.reduce(
    (sum, p) => sum + getVisualPoints(p.slPips, p.symbol, false).forCalc,
    0
  );
  const newPlansNettSL_Risk = calculatedPlansData.reduce(
    (sum, p) => sum + Math.abs(p.nettSL || 0),
    0
  );
  const newPlansLot = calculatedPlansData.reduce(
    (sum, p) => sum + p.lotSize,
    0
  );

  // 3. Hitung total P/L (bisa positif/negatif) dari Rencana Selesai BULAN INI
  let executedPL_Pct = 0;
  let executedPL_Pips = 0;
  let executedPL_Dolar = 0;
  let executedRisk_Pct_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedRisk_Pips_ForLimit = 0; // Untuk hitung 'Sisa'
  let executedLot_ThisMonth = 0;

  executedThisMonth.forEach((p) => {
    const tradeResult = getTradeResult(p);

    if (tradeResult.isWin) {
      executedPL_Pct += p.rrPercentage?.tp || 0;
      executedPL_Pips += getVisualPoints(p.tpPips, p.symbol, false).forCalc;
    } else {
      executedPL_Pct -= p.rrPercentage?.sl || 0;
      executedPL_Pips -= getVisualPoints(p.slPips, p.symbol, false).forCalc;
    }
    executedPL_Dolar += tradeResult.profitLoss;

    executedRisk_Pct_ForLimit += p.rrPercentage?.sl || 0;
    executedRisk_Pips_ForLimit += getVisualPoints(
      p.slPips,
      p.symbol,
      false
    ).forCalc;
    executedLot_ThisMonth += p.lotSize || 0;
  });

  // 4. Hitung Total Akumulasi (P/L Selesai Bulanan - Risiko Aktif - Risiko BARU)
  const totalAccumulatedPct =
    executedPL_Pct - runningRiskPct - newPlansRiskPct; 
  const totalAccumulatedPips =
    executedPL_Pips - runningSlPips - newPlansSlPips;
  const totalAccumulatedDolar =
    executedPL_Dolar - runningNettSL_Risk - newPlansNettSL_Risk;
  const totalAccumulatedLot =
    runningLot + executedLot_ThisMonth + newPlansLot;

  // 5. Hitung Total RISIKO (untuk 'Sisa') (Risiko Aktif + Risiko Selesai Bulanan)
  const totalMonthlyRiskPct_ForLimit =
    runningRiskPct + executedRisk_Pct_ForLimit;
  const totalMonthlySlPips_ForLimit =
    runningSlPips + executedRisk_Pips_ForLimit;

  // 6. Tentukan Batas (PERBAIKAN: Ubah ke 7.0%)
  const MAX_DRAWDOWN_RISK_LIMIT = 7.0; // <-- PERBAIKAN
  const MONTHLY_RISK_PIPS_LIMIT = 10000; // PERBAIKAN: Diubah ke 1500

  // 7. Hitung Sisa
  const currentPercentLimit = Math.min(
    MAX_DRAWDOWN_RISK_LIMIT, // <-- PERBAIKAN
    MAX_DRAWDOWN_RISK_LIMIT + executedPL_Pct // <-- PERBAIKAN
  );
  const currentPipsLimit = Math.min(
    MONTHLY_RISK_PIPS_LIMIT,
    MONTHLY_RISK_PIPS_LIMIT + executedPL_Pips
  );
  const remainingPct = currentPercentLimit - runningRiskPct - newPlansRiskPct;
  const remainingPips = currentPipsLimit - runningSlPips - newPlansSlPips;

  // 8. Render ke UI
  percentageNowEl.textContent = `${formatNumber(executedPL_Pct, 2)}%`;
  applyColor(percentageNowEl, executedPL_Pct);

  percentageEl.textContent = `${formatNumber(totalAccumulatedPct, 2)}%`;
  applyColor(percentageEl, totalAccumulatedPct);
  percentageRemainingEl.textContent = `Sisa: ${formatNumber(remainingPct, 2)}%`;
  applyColor(percentageRemainingEl, remainingPct);

  pipsNowEl.textContent = `${formatNumber(executedPL_Pips, 0)}`;
  applyColor(pipsNowEl, executedPL_Pips);

  pipsEl.textContent = `${formatNumber(totalAccumulatedPips, 0)}`;
  applyColor(pipsEl, totalAccumulatedPips);
  pipsRemainingEl.textContent = `Sisa: ${formatNumber(remainingPips, 0)}`;
  applyColor(pipsRemainingEl, remainingPips);

  dolarEl.textContent = `${formatCurrency(totalAccumulatedDolar, "USD")}`;
  applyColor(dolarEl, totalAccumulatedDolar);

  lotEl.textContent = `${formatNumber(totalAccumulatedLot, 2)}`;
  applyColor(lotEl, 1);
}
function updateInterventionStatistics() {
          const intervEl = document.getElementById('totalInterventionValue');
          const nonIntervEl = document.getElementById('totalNonInterventionValue');
          
          if (!intervEl || !nonIntervEl) return;

          let totalIntervention = 0;     // Total Hasil Aktual (Intervensi Column)
          let totalNonIntervention = 0;  // Total Hasil Murni (Tidak Intervensi Column)

          executedPlansData.forEach(plan => {
              // Abaikan trade Cancel/Tes
              if (plan.outcome !== "Take Profit" && plan.outcome !== "Stop Loss") return;

              const origTP = plan.originalNettTP !== undefined ? plan.originalNettTP : plan.nettTP;
              const origSL = plan.originalNettSL !== undefined ? plan.originalNettSL : plan.nettSL;

              if (plan.outcome === "Take Profit") {
                  totalNonIntervention += origTP; // Selalu Original
                  totalIntervention += plan.nettTP; // Selalu Aktual (Edit atau Tidak)
              } else if (plan.outcome === "Stop Loss") {
                  totalNonIntervention += origSL; // Selalu Original
                  totalIntervention += plan.nettSL; // Selalu Aktual (Edit atau Tidak)
              }
          });

          // Render ke UI
          intervEl.textContent = formatCurrency(totalIntervention, "USD");
          intervEl.className = `text-lg font-bold ${totalIntervention >= 0 ? 'text-green-600' : 'text-red-600'}`;

          nonIntervEl.textContent = formatCurrency(totalNonIntervention, "USD");
          nonIntervEl.className = `text-lg font-bold ${totalNonIntervention >= 0 ? 'text-green-600' : 'text-red-600'}`;
      }

      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      function calculateAndRenderMonthlyPLSummary() {
        const summaryBody = document.getElementById("monthlyPLSummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter(
            (trade) => getTradeResult(trade).isValid && trade && trade.timestamp
          )
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          // Perbarui colspan menjadi 8
          summaryBody.innerHTML = `<tr><td colspan="8" class="py-4 text-center text-gray-500">Belum ada data trading yang selesai.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const monthlyData = {};
        const firstTradeWithBalance = relevantTrades.find(
          (t) => typeof t.balance === "number" && !isNaN(t.balance)
        );
        const initialBalance = firstTradeWithBalance
          ? firstTradeWithBalance.balance
          : 0;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          if (isNaN(tradeDate.getTime())) return;
          const monthKey = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
              tradeCount: 0,
              tpCount: 0,
              slCount: 0,
              monthlyPL: 0,
              totalTPValue: 0,
              totalSLValue: 0,
              monthName: tradeDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              }),
            };
          }

          const { isWin } = getTradeResult(trade);
          const profitLossAmount = isWin
            ? parseFloat(trade.nettTP)
            : parseFloat(trade.nettSL);

          monthlyData[monthKey].tradeCount++;
          monthlyData[monthKey].monthlyPL += profitLossAmount;
          if (isWin) {
            monthlyData[monthKey].tpCount++;
            monthlyData[monthKey].totalTPValue += parseFloat(trade.nettTP);
          } else {
            monthlyData[monthKey].slCount++;
            monthlyData[monthKey].totalSLValue += Math.abs(
              parseFloat(trade.nettSL)
            );
          }
        });

        const sortedMonthKeys = Object.keys(monthlyData).sort((a, b) => {
          const [yearA, monthA] = a.split("-");
          const [yearB, monthB] = b.split("-");
          return new Date(yearA, monthA) - new Date(yearB, monthB);
        });

        let cumulativePL = 0;
        let cumulativeBalance = initialBalance;

        for (const monthKey of sortedMonthKeys) {
          const month = monthlyData[monthKey];
          cumulativePL += month.monthlyPL;
          cumulativeBalance = initialBalance + cumulativePL;

          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
          const nettTP = month.totalTPValue - month.totalSLValue;

          // Kalkulasi baru untuk eksekusi bersih
          const netExecutions = month.tpCount - month.slCount;

          const percentageClass =
            cumulativePercentage >= 0 ? "positive-value" : "negative-value";
          const nettTPClass = nettTP >= 0 ? "positive-value" : "negative-value";
          const cumulativePLClass =
            cumulativePL >= 0 ? "positive-value" : "negative-value";
          const totalBalanceClass =
            cumulativeBalance >= initialBalance
              ? "positive-value"
              : "negative-value";
          // Kelas warna baru
          const netExecutionsClass =
            netExecutions >= 0 ? "positive-value" : "negative-value";

          // Tambahkan <td> baru untuk data eksekusi bersih
          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                          <tr>
                              <td class="py-3 px-4 text-center text-neutral-value">${
                                month.monthName
                              }</td>
                              <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(
              cumulativePercentage,
              2
            )}%</td>
                              <td class="py-3 px-4 text-center text-neutral-value">${
                                month.tradeCount
                              }</td>
                              <td class="py-3 px-4 text-center">
                                  <span class="positive-value">${
                                    month.tpCount
                                  }</span> / <span class="negative-value">${
              month.slCount
            }</span>
                              </td>
                              <td class="py-3 px-4 text-center ${netExecutionsClass}">${netExecutions}</td>
                              <td class="py-3 px-4 text-center ${nettTPClass}">${formatCurrency(
              nettTP,
              "USD"
            )}</td>
                              <td class="py-3 px-4 text-center ${cumulativePLClass}">${formatCurrency(
              cumulativePL,
              "USD"
            )}</td>
                              <td class="py-3 px-4 text-center ${totalBalanceClass}">${formatCurrency(
              cumulativeBalance,
              "USD"
            )}</td>
                          </tr>
                      `
          );
        }
      }

      // --- GANTI SEMUA FUNGSI RINGKASAN (HARIAN, MINGGUAN, BULANAN, TAHUNAN) DENGAN BLOK DI BAWAH INI ---

      function calculateAndRenderDailySummary() {
        const summaryBody = document.getElementById("newDailySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data harian.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const dailyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const dayKey = tradeDate.toISOString().slice(0, 10);

          if (!dailyData[dayKey]) {
            dailyData[dayKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              dayName: tradeDate.toLocaleDateString("id-ID", {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric",
              }),
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          dailyData[dayKey].pips += pointsForTrade;
          dailyData[dayKey].pl += tradeResult.profitLoss;
          dailyData[dayKey].tradeCount++;
        });

        const sortedDayKeys = Object.keys(dailyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const dayKey of sortedDayKeys) {
          const day = dailyData[dayKey];
          cumulativeTradeCount += day.tradeCount;
          cumulativePips += day.pips;
          cumulativePL += day.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${day.dayName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderWeeklySummary() {
        const summaryBody = document.getElementById("newWeeklySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data mingguan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const weeklyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const weekKey = `${tradeDate.getFullYear()}-W${String(
            getWeekNumber(tradeDate)
          ).padStart(2, "0")}`;

          if (!weeklyData[weekKey]) {
            weeklyData[weekKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              weekName: `Minggu ${getWeekNumber(
                tradeDate
              )}, ${tradeDate.getFullYear()}`,
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          weeklyData[weekKey].pips += pointsForTrade;
          weeklyData[weekKey].pl += tradeResult.profitLoss;
          weeklyData[weekKey].tradeCount++;
        });

        const sortedWeekKeys = Object.keys(weeklyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const weekKey of sortedWeekKeys) {
          const week = weeklyData[weekKey];
          cumulativeTradeCount += week.tradeCount;
          cumulativePips += week.pips;
          cumulativePL += week.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${week.weekName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderNewMonthlySummary() {
        const summaryBody = document.getElementById("newMonthlySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data bulanan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const monthlyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const monthKey = tradeDate.toISOString().slice(0, 7);

          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              monthName: tradeDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              }),
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          monthlyData[monthKey].pips += pointsForTrade;
          monthlyData[monthKey].pl += tradeResult.profitLoss;
          monthlyData[monthKey].tradeCount++;
        });

        const sortedMonthKeys = Object.keys(monthlyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const monthKey of sortedMonthKeys) {
          const month = monthlyData[monthKey];
          cumulativeTradeCount += month.tradeCount;
          cumulativePips += month.pips;
          cumulativePL += month.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${month.monthName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderYearlySummary() {
        const summaryBody = document.getElementById("newYearlySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data tahunan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const yearlyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const yearKey = `${tradeDate.getFullYear()}`;

          if (!yearlyData[yearKey]) {
            yearlyData[yearKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              yearName: yearKey,
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          yearlyData[yearKey].pips += pointsForTrade;
          yearlyData[yearKey].pl += tradeResult.profitLoss;
          yearlyData[yearKey].tradeCount++;
        });

        const sortedYearKeys = Object.keys(yearlyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const yearKey of sortedYearKeys) {
          const year = yearlyData[yearKey];
          cumulativeTradeCount += year.tradeCount;
          cumulativePips += year.pips;
          cumulativePL += year.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${year.yearName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      // --- TAMBAHKAN FUNGSI BARU INI ---
      function downloadMonthlyPLSummaryAsExcel(filename) {
        const summaryBody = document.getElementById("monthlyPLSummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan P/L bulanan untuk diunduh.",
            false
          );
          return;
        }
        // Perbarui header sesuai dengan tabel baru
        const headers = [
          "Bulan",
          "Presentase Akumulasi (%)",
          "Total Eksekusi",
          "TP / SL",
          "Total Eksekusi Bersih",
          "TP Bersih ($)",
          "Akumulasi Nett ($)",
          "Total Saldo ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";

        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map((cell) => {
            // Membersihkan data sebelum dimasukkan ke CSV
            let cellText = cell.textContent.replace(/[$,%]/g, "").trim();
            // Menangani format "TP / SL"
            if (cellText.includes("/")) {
              cellText = `"${cellText}"`; // Apit dengan kutip agar tidak dianggap pemisah
            }
            return cellText;
          });
          csvContent += rowData.join(",") + "\r\n";
        }

        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- TAMBAHKAN EVENT LISTENER BARU INI ---
      const downloadMonthlyPLBtn = document.getElementById(
        "downloadMonthlyPLSummaryBtn"
      );
      if (downloadMonthlyPLBtn) {
        downloadMonthlyPLBtn.addEventListener("click", () => {
          downloadMonthlyPLSummaryAsExcel(
            `Ringkasan_PL_Bulanan_${new Date().toISOString().slice(0, 10)}.csv`
          );
        });
      }

      
      // --- PASTIKAN FUNGSI updateAllDataAndRenderUI ANDA SEPERTI INI ---
      /**
       * Menggabungkan data baru (jika ada), mengurutkan semua array data,
       * menyimpan ke local storage, dan merender ulang seluruh UI.
       */
      function updateAllDataAndRenderUI(newCalculated = [], newRunning = [], newExecuted = []) {
        console.log("Updating all data and rendering UI...");

        // 1. GABUNGKAN DATA BARU (jika ada) ke array yang sesuai
        if (newCalculated.length > 0) calculatedPlansData.unshift(...newCalculated);
        if (newRunning.length > 0) runningPlansData.unshift(...newRunning);
        if (newExecuted.length > 0) executedPlansData.unshift(...newExecuted);

        // 2. HAPUS DUPLIKAT (berdasarkan entryTime)
        const uniqueEntries = (arr) => {
            const seen = new Set();
            // PERBAIKAN: Gunakan ID unik jika ada, fallback ke entryTime
            return arr.filter(item => {
                if (!item || (!item.id && !item.entryTime)) return false; // Abaikan item tidak valid
                const key = item.id || item.entryTime; // Prioritaskan ID unik
                if (seen.has(key)) return false; // Lewati jika sudah ada
                seen.add(key);
                return true;
            });
        };
        calculatedPlansData = uniqueEntries(calculatedPlansData);
        runningPlansData = uniqueEntries(runningPlansData);
        executedPlansData = uniqueEntries(executedPlansData);


        // 3. URUTKAN SEMUA ARRAY DATA (TERBARU DI ATAS)
        const sortByEntryTimeDesc = (a, b) => (new Date(b.entryTime).getTime() || 0) - (new Date(a.entryTime).getTime() || 0);
        calculatedPlansData.sort(sortByEntryTimeDesc);
        runningPlansData.sort(sortByEntryTimeDesc);
        executedPlansData.sort((a, b) => (new Date(b.timestamp).getTime() || 0) - (new Date(a.timestamp).getTime() || 0));

        // 4. Simpan state yang sudah diurutkan ke local storage
        saveDataToLocalStorage();

        // 5. Render ulang semua tabel
        renderCalculatedPlans();
        renderRunningPlans(); // Ini memanggil updateActivePlansSummary secara internal
        renderExecutedPlans();

        // 6. Hitung ulang semua statistik dan ringkasan tabel
        calculateSummaryStatistics();
        updateRiskRewardStatistics();
        calculateAndRenderMonthlyPLSummary();
        renderDailyRiskSummary();
        renderMonthlyRiskSummary();
        renderMaxDrawdownRiskSummary();
        calculateAndRenderDailySummary();
        calculateAndRenderWeeklySummary();
        calculateAndRenderNewMonthlySummary();
        calculateAndRenderYearlySummary();
        updateInterventionStatistics();
        fetchAndRenderGhostEquityChart(); // Render Grafik Ghost
        calculateAndRenderSQN();
        calculateAndRenderBBookProfile(); 

        // 7. Render ulang kalender DAN GRAFIK BULANAN
        // PASTIKAN BLOK IF INI ADA DAN TIDAK DIKOMENTARI
        if (calendarBody && monthYearDisplay && typeof currentCalendarDate !== 'undefined') {
             console.log("Calling renderCalendar from updateAllDataAndRenderUI..."); // Tambahkan log
             renderCalendar(currentCalendarDate); // Panggil render kalender & grafik bulan saat ini
        } else {
             console.warn("Calendar elements or currentCalendarDate not ready during updateAllDataAndRenderUI.");
        }

        // 8. Reset status render grafik lain & panggil observer
        Object.keys(chartSections).forEach(sectionId => {
             // Hindari mereset chart bulanan yang baru saja dirender oleh renderCalendar
             if (sectionId !== 'calendarSection' && chartSections[sectionId]) {
                 // Reset hasRendered agar observer bisa merender ulang saat discroll
                 chartSections[sectionId].hasRendered = false;
                 // Jika chart instance ada, hancurkan untuk memaksa render ulang
                 const chartInstance = chartSections[sectionId].chartInstance ? chartSections[sectionId].chartInstance() : null;
                 if (chartInstance) {
                     console.log(`Destroying chart for section: ${sectionId}`);
                     chartInstance.destroy();
                     if (chartSections[sectionId].setInstance) {
                         chartSections[sectionId].setInstance(null); // Reset instance global
                     }
                 }
             }
         });
        animateOnScroll(); // Panggil ulang observer untuk merender grafik yang terlihat

        console.log("UI and all data updated and sorted successfully.");
      }
      // --- AKHIR DARI FUNGSI updateAllDataAndRenderUI ---
      // --- AKHIR DARI FUNGSI updateAllDataAndRenderUI ---

      // --- AKHIR DARI BLOK PENGGANTIAN ---

      function downloadDailySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newDailySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan harian untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Tanggal",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadWeeklySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newWeeklySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan mingguan untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Minggu",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadYearlySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newYearlySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan tahunan untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Tahun",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadNewMonthlySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newMonthlySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan bulanan untuk diunduh.",
            false
          );
          return;
        }

        const headers = [
          "Bulan",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";

        for (const row of summaryBody.rows) {
          const rowData = [];
          for (const cell of row.cells) {
            let cellText = cell.textContent
              .replace(/[%$]/g, "")
              .replace(/,/g, "")
              .trim();
            if (cellText.includes(",")) {
              cellText = `"${cellText}"`;
            }
            rowData.push(cellText);
          }
          csvContent += rowData.join(",") + "\r\n";
        }

        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- CORE CALCULATOR LOGIC ---
      const getAssetData = (symbol) =>
        assetValues[symbol] || {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        };

      // Updated calculatePipsPoints to correctly handle different asset types
      function calculatePipsPoints(priceDiff, symbol) {
        const assetData = getAssetData(symbol);
        if (!assetData) return 0; // Handle unknown symbol

        if (assetData.type.includes("forex")) {
          // For 5-decimal forex pairs (e.g., EUR/USD), 1 pip = 0.0001 (multiplier 10000)
          // For 3-decimal forex pairs (e.g., USD/JPY), 1 pip = 0.01 (multiplier 100)
          const pipMultiplier = assetData.decimals === 5 ? 10000 : 100;
          return priceDiff * pipMultiplier;
        }
        // For other assets (indices, commodities, crypto), priceDiff is directly the "points"
        return priceDiff;
      }

      // --- LETAKKAN OBJEK INI DI LUAR FUNGSI RENDER CALENDAR (misalnya, di dekat variabel global lainnya) ---
      /**
       * Daftar Hari Libur Nasional Umum & Peristiwa Penting Indonesia (STATIS).
       * Kunci: YYYY-MM-DD
       * CATATAN PENTING: Daftar ini bersifat contoh dan MUNGKIN TIDAK LENGKAP ATAU AKURAT
       * untuk semua tahun atau perubahan cuti bersama. Memerlukan pembaruan manual.
       */
      const holidays = {
          "2025-01-01": "Tahun Baru Masehi",
          "2025-01-29": "Tahun Baru Imlek 2576", // Perkiraan, bisa berubah
          "2025-02-27": "Isra Mi'raj Nabi Muhammad SAW", // Perkiraan
          "2025-03-29": "Hari Suci Nyepi Tahun Baru Saka 1947", // Perkiraan
          "2025-03-31": "Idul Fitri 1446 H (Hari ke-1)", // Perkiraan
          "2025-04-01": "Idul Fitri 1446 H (Hari ke-2)", // Perkiraan
          "2025-04-18": "Wafat Isa Al Masih", // Perkiraan
          "2025-05-01": "Hari Buruh Internasional",
          "2025-05-12": "Hari Raya Waisak 2569 BE", // Perkiraan
          "2025-05-29": "Kenaikan Isa Al Masih", // Perkiraan
          "2025-06-01": "Hari Lahir Pancasila",
          "2025-06-07": "Idul Adha 1446 H", // Perkiraan
          "2025-06-27": "Tahun Baru Islam 1447 H", // Perkiraan
          "2025-08-17": "Hari Kemerdekaan Republik Indonesia",
          "2025-09-05": "Maulid Nabi Muhammad SAW", // Perkiraan
          "2025-10-28": "Hari Sumpah Pemuda", // Peristiwa Penting
          "2025-12-25": "Hari Raya Natal",
          // Tambahkan hari libur/penting lainnya sesuai kebutuhan
      };

      // ▼▼▼ FUNGSI BARU: NOTIFIKASI COMPOUNDING BULANAN ▼▼▼
      /**
       * Mengecek apakah ini bulan baru dan menampilkan saran Compounding jika target tercapai.
       */
      async function checkAndShowCompoundingNotification() {
        const now = new Date();
        // Kunci unik: "Tahun-Bulan" (Contoh: "2025-11"). 
        // Ini memastikan notifikasi hanya muncul 1x setiap bulan.
        const currentMonthKey = `${now.getFullYear()}-${now.getMonth() + 1}`; 
        const storedMonthKey = localStorage.getItem('compoundingNotificationShown');

        // Jika notifikasi untuk bulan ini sudah pernah ditampilkan, berhenti.
        if (storedMonthKey === currentMonthKey) {
            return; 
        }

        // Tentukan Bulan Lalu untuk evaluasi
        const prevMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const prevMonthIndex = prevMonthDate.getMonth();
        const prevMonthYear = prevMonthDate.getFullYear();

        // Ambil & Filter data trade yang selesai pada bulan lalu
        const prevMonthTrades = executedPlansData.filter(p => {
            if (!getTradeResult(p).isValid) return false;
            const d = new Date(p.timestamp);
            return d.getMonth() === prevMonthIndex && d.getFullYear() === prevMonthYear;
        }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        const title = "Pengingat Compounding ROI 3%";
        const monthName = prevMonthDate.toLocaleString('id-ID', { month: 'long', year: 'numeric' });

        // Jika tidak ada data bulan lalu
        if (prevMonthTrades.length === 0) {
            const msg = `
                <div class="text-center text-sm">
                    <p class="mb-3">Halo Trader! Selamat datang di bulan <strong>${new Date().toLocaleString('id-ID', { month: 'long' })}</strong>.</p>
                    <p class="text-gray-500 mb-2">Belum ada data trading yang tercatat untuk bulan lalu (${monthName}).</p>
                    <p class="font-bold text-blue-600 bg-blue-50 p-2 rounded border border-blue-100">Target Bulan Ini: ROI 3%</p>
                    <p class="text-xs text-gray-400 mt-2">"Konsistensi adalah kunci compounding."</p>
                </div>
            `;
            // Tampilkan info saja
            await showMessageBox(title, msg, false);
            // Tandai sudah dilihat
            localStorage.setItem('compoundingNotificationShown', currentMonthKey);
            return;
        }

        // Hitung Statistik Bulan Lalu
        // Asumsi: Balance awal bulan adalah balance dari trade pertama di bulan itu
        const initialBalancePrevMonth = prevMonthTrades[0].balance;
        
        let totalPL = 0;
        prevMonthTrades.forEach(t => totalPL += getTradeResult(t).profitLoss);
        
        // Persentase keuntungan bulan lalu
        const roiPercent = (initialBalancePrevMonth > 0) ? (totalPL / initialBalancePrevMonth) * 100 : 0;

        // Bangun HTML Pesan
        let messageHtml = `
            <div class="text-sm text-gray-700">
                <p class="mb-3 text-center font-medium">Laporan Kinerja Bulan <strong>${monthName}</strong>:</p>
                <div class="bg-gray-50 p-3 rounded border border-gray-200 mb-4 space-y-1 text-xs">
                    <div class="flex justify-between"><span>Modal Awal:</span> <span class="font-mono">${formatCurrency(initialBalancePrevMonth, "USD")}</span></div>
                    <div class="flex justify-between"><span>Total Profit/Loss:</span> <span class="font-mono ${totalPL >= 0 ? 'positive-value' : 'negative-value'}">${formatCurrency(totalPL, "USD")}</span></div>
                    <div class="flex justify-between font-bold border-t border-gray-300 pt-1 mt-1">
                        <span>ROI Aktual:</span> 
                        <span class="${roiPercent >= 3 ? 'text-green-600' : (roiPercent >= 0 ? 'text-blue-600' : 'text-red-600')}">
                            ${formatNumber(roiPercent, 2)}%
                        </span>
                    </div>
                </div>
        `;

        // LOGIKA UTAMA: Cek apakah ROI >= 3%
        if (roiPercent >= 3) {
            // Hitung Target Baru: Modal Awal Bulan Lalu + 3%
            // Contoh: 10.000 + (3%) = 10.300
            const compoundingTargetBalance = initialBalancePrevMonth * 1.03;
            
            messageHtml += `
                <div class="text-center">
                    <p class="text-green-600 font-bold mb-1">🎉 Target ROI 3% Tercapai!</p>
                    <p class="text-xs mb-2">Sesuai aturan compounding, modal yang disarankan untuk bulan ini:</p>
                    
                    <div class="bg-green-50 p-3 rounded border border-green-200 mb-3">
                        <span class="text-xl font-bold text-green-800">${formatCurrency(compoundingTargetBalance, "USD")}</span>
                        <p class="text-[10px] text-green-600 mt-1">(Modal Awal Bulan Lalu + 3%)</p>
                    </div>
                    
                    <p class="text-xs">Klik <strong>"Terapkan"</strong> untuk memperbarui Balance Akun di form input secara otomatis.</p>
                </div>
            </div>`;

            // Tampilkan Pop-up dengan tombol Konfirmasi (Terapkan)
            const result = await showMessageBox(title, messageHtml, true, { customButtonText: "Terapkan" });

            if (result.confirmed) {
                // AKSI: Update nilai input Balance
                const balanceInputs = document.querySelectorAll('input[name="balance"]');
                let updatedCount = 0;
                
                balanceInputs.forEach(input => {
                    input.value = compoundingTargetBalance.toFixed(2);
                    input.dispatchEvent(new Event('change')); // Trigger simpan otomatis
                    updatedCount++;
                });
                
                saveInputRowsToLocalStorage(); // Pastikan tersimpan
                
                if (updatedCount > 0) {
                    showMessageBox("Sukses", `Balance Akun berhasil diperbarui menjadi ${formatCurrency(compoundingTargetBalance, "USD")}.`, false);
                } else {
                    showMessageBox("Info", "Tidak ada baris input aktif. Silakan tambah baris input baru dengan balance tersebut.", false);
                }
            }

        } else {
            // Jika ROI < 3%
            messageHtml += `
                <div class="text-center">
                    <p class="text-amber-600 font-bold mb-1">Target 3% Belum Tercapai</p>
                    <p class="text-xs mb-3">Tidak ada saran penambahan modal (compounding) untuk bulan ini.</p>
                    
                    <div class="bg-amber-50 p-2 rounded border border-amber-100 text-xs text-amber-800 italic">
                        "Tetap disiplin pada trading plan. Jangan memaksakan compounding jika target belum terpenuhi."
                    </div>
                </div>
            </div>`;
            
            // Tampilkan Pop-up Info Saja (False = tombol OK saja)
            await showMessageBox(title, messageHtml, false);
        }

        // Tandai bahwa notifikasi bulan ini sudah selesai
        localStorage.setItem('compoundingNotificationShown', currentMonthKey);
      }
      // ▲▲▲ AKHIR FUNGSI BARU ▲▲▲
      // --- AKHIR DARI OBJEK HARI LIBUR ---


      // --- PASTIKAN FUNGSI renderCalendar ANDA SEPERTI INI ---
      /**
       * Merender kalender grid dan memicu render grafik persentase bulanan.
       * @param {Date} date - Objek Date yang mewakili bulan & tahun yang akan ditampilkan.
       */
      function renderCalendar(date) {
        // Validasi elemen kalender grid
        const calendarBodyEl = document.getElementById("calendarBody");
        const monthYearDisplayEl = document.getElementById("monthYearDisplay");
        if (!calendarBodyEl || !monthYearDisplayEl) {
          console.error("Elemen kalender grid tidak ditemukan.");
          return;
        }

        calendarBodyEl.innerHTML = ""; // Kosongkan isi kalender grid
        const year = date.getFullYear();
        const month = date.getMonth(); // 0 = Januari, 11 = Desember
        const today = new Date(); // Tanggal hari ini
        today.setHours(0, 0, 0, 0); // Nolkan waktu untuk perbandingan tanggal saja

        // Tampilkan Bulan dan Tahun di header kalender grid
        monthYearDisplayEl.textContent = new Date(year, month).toLocaleString(
          "id-ID",
          {
            month: "long",
            year: "numeric",
          }
        );

        // --- Render Kalender Grid ---
        const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0 = Minggu, 6 = Sabtu
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        // Hari dari bulan sebelumnya
        for (let i = firstDayOfMonth; i > 0; i--) {
          const day = daysInPrevMonth - i + 1;
          calendarBodyEl.innerHTML += `<div class="calendar-date prev-month">${day}</div>`;
        }

        // Hari dari bulan ini
        for (let i = 1; i <= daysInMonth; i++) {
          const currentDate = new Date(year, month, i);
          currentDate.setHours(0, 0, 0, 0); // Nolkan waktu
          const dayOfWeek = currentDate.getDay(); // 0 = Minggu, 6 = Sabtu
          const dateKey = `${year}-${String(month + 1).padStart(
            2,
            "0"
          )}-${String(i).padStart(2, "0")}`; // Format YYYY-MM-DD

          let classes = "calendar-date";
          let titleAttr = ""; // Atribut title untuk tooltip hari libur

          // Cek apakah hari ini
          if (currentDate.getTime() === today.getTime()) {
            classes += " today";
          }

          // Warnai Sabtu dan Minggu (Akhir Pekan)
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            classes += " text-red-500 font-semibold";
          }

          // Cek Hari Libur/Penting dari objek 'holidays'
          if (holidays[dateKey]) {
            classes += " relative holiday-indicator"; // Tambahkan kelas indikator jika ada CSS-nya
            titleAttr = ` title="${holidays[dateKey]}"`; // Tambahkan keterangan ke tooltip
          }

          // Tambahkan elemen tanggal ke kalender grid
          calendarBodyEl.innerHTML += `<div class="${classes}"${titleAttr}>${i}</div>`;
        }

        // Hari dari bulan berikutnya
        const totalCells = calendarBodyEl.children.length;
        const nextDays = (7 - (totalCells % 7)) % 7;
        for (let i = 1; i <= nextDays; i++) {
          calendarBodyEl.innerHTML += `<div class="calendar-date next-month">${i}</div>`;
        }

        // --- Panggil Render Grafik Bulanan ---
        renderMonthlyPercentageChart(year, month); // PASTIKAN BARIS INI ADA
      }
      // ▼▼▼ GANTI SELURUH FUNGSI LAMA (baris 2115-2233) DENGAN INI ▼▼▼
function renderMonthlyPercentageChart(year, month) {
  const chartConfig = {
    canvasId: "monthlyPercentageLineChart",
    loadingId: "monthlyPercentageLineChartLoading",
    errorId: "monthlyPercentageLineChartError",
    noDataId: "monthlyPercentageLineChartNoData",
  };
  const chartInstanceRef = {
    chart: monthlyPercentageLineChart,
    set chart(c) {
      monthlyPercentageLineChart = c;
    },
  };
  // Setup container (menangani loading/error/nodata)
  const { canvas, loading, error, noData } = setupChartContainer(
    chartConfig.canvasId,
    chartConfig.loadingId,
    chartConfig.errorId,
    chartConfig.noDataId
  );
  const chartTitleEl = document.getElementById("monthlyChartTitle");

  // Perbarui judul grafik
  const monthName = new Date(year, month).toLocaleString("id-ID", {
    month: "long",
    year: "numeric",
  });
  if (chartTitleEl) {
    chartTitleEl.textContent = `Pertumbuhan Persentase (${monthName})`;
  }

  try {
    // Filter data hanya untuk bulan & tahun yang dipilih, pastikan valid
    const tradesThisMonth = executedPlansData // Membaca dari data global
      .filter((trade) => {
        if (!trade.timestamp || !getTradeResult(trade).isValid)
          return false;
        const tradeDate = new Date(trade.timestamp);
        return (
          tradeDate.getFullYear() === year &&
          tradeDate.getMonth() === month
        );
      })
      .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); // Urutkan berdasarkan waktu

    if (tradesThisMonth.length === 0) {
      // Tampilkan pesan 'tidak ada data' jika tidak ada trade bulan ini
      handleChartData(
        { labels: [], datasets: [] }, // Kirim data kosong
        { canvas, loading, error, noData },
        chartInstanceRef,
        "line",
        {}
      );
      return; // Keluar dari fungsi
    }

    // Tentukan balance awal untuk perhitungan persentase bulan ini
    const initialBalanceThisMonth = tradesThisMonth[0].balance;

    const labels = [];
    const data = [];
    let cumulativePLThisMonth = 0;

    // Tambahkan titik awal (0%) sebelum trade pertama
    labels.push("Awal"); // Label titik awal
    data.push(0);

    // Hitung P/L kumulatif per hari (atau per trade)
    tradesThisMonth.forEach((trade) => {
      cumulativePLThisMonth += getTradeResult(trade).profitLoss;
      const currentPercentage =
        initialBalanceThisMonth > 0
          ? (cumulativePLThisMonth / initialBalanceThisMonth) * 100
          : 0;

      labels.push(
        new Date(trade.timestamp).toLocaleDateString("id-ID", {
          day: "numeric", // Hanya tanggal
        })
      );
      data.push(currentPercentage);
    });
    
    // ▼▼▼ PERBAIKAN: Kalkulasi Skala Y (Sumbu Kiri) ▼▼▼
    const MONTHLY_LIMIT = -5; // Batas risiko bulanan
    // 1. Tentukan rentang data, paksa menyertakan 0 dan batas limit
    const dataValues = [0, MONTHLY_LIMIT, ...data]; 
    const dataMin = Math.min(...dataValues);
    const dataMax = Math.max(...dataValues);
    // 2. Beri padding asimetris (RASIO BARU YANG LEBIH AGRESIIF)
    const range = dataMax - dataMin;
    const bottomPadding = range * 0.05 || 0.5; // Padding bawah 5% (SANGAT KECIL)
    const topPadding = range * 1.5 || 10;   // Padding atas 150% (SANGAT BESAR)
    
    const finalMin = dataMin - bottomPadding;
    const finalMax = dataMax + topPadding;
    // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

    // Tentukan warna garis berdasarkan hasil AKHIR bulan
    const finalPercentage = data[data.length - 1];
    const lineColor = finalPercentage >= 0 ? "#007bff" : "#dc3545"; // Biru jika profit/flat, Merah jika loss
    const backgroundColor =
      finalPercentage >= 0
        ? "rgba(0, 123, 255, 0.1)" // Biru transparan
        : "rgba(220, 53, 69, 0.1)"; // Merah transparan

    // Render grafik menggunakan handleChartData
    handleChartData(
      {
        labels: labels,
        datasets: [
          {
            label: "Persen Kumulatif", // Label dataset
            data: data,
            borderColor: lineColor,
            backgroundColor: backgroundColor,
            fill: true, // Beri area di bawah garis
            tension: 0.1, // Sedikit melengkung
            borderWidth: 1.5,
            pointRadius: 1.5, // Ukuran titik data
            pointHoverRadius: 4,
            pointBackgroundColor: lineColor,
          },
        ],
      },
      { canvas, loading, error, noData },
      chartInstanceRef,
      "line", // Tipe chart adalah line
      { // Opsi grafik (tooltip, skala, dll)
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              title: (context) => {
                if (context[0].dataIndex === 0) return "Awal Bulan";
                const tradeIndex = context[0].dataIndex - 1;
                if (tradeIndex >= 0 && tradeIndex < tradesThisMonth.length) {
                    return new Date(tradesThisMonth[tradeIndex].timestamp).toLocaleString("id-ID", {
                        day: 'numeric', month: 'short', year:'numeric', hour:'2-digit', minute:'2-digit'
                    });
                }
                return context[0].label;
              },
              label: (context) => {
                const value = context.raw || 0;
                return `${context.dataset.label}: ${formatNumber(value, 2)}%`;
              },
            },
          },
          annotation: {
            annotations: {
              limitLine: {
                type: 'line',
                yMin: -5, // <-- PERBAIKAN: Diubah ke -5
                yMax: -5, // <-- PERBAIKAN: Diubah ke -5
                borderColor: 'rgb(220, 53, 69)', // Warna merah
                borderWidth: 2,
                borderDash: [6, 6], // Garis putus-putus
                label: {
                  content: 'Batas Bulanan -5%', // <-- PERBAIKAN: Label diubah
                  enabled: true,
                  position: 'end',
                  backgroundColor: 'rgba(220, 53, 69, 0.8)',
                  color: 'white',
                  font: { size: 9, family: "Inter", style: 'normal' },
                  padding: 4,
                  yAdjust: -10
                }
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              font: { size: 9, family: "Inter" },
              maxRotation: 0,
              autoSkip: true,
              maxTicksLimit: 8,
               padding: 5,
            },
            grid: { display: false }
          },
          y: {
            position: 'left',
            beginAtZero: false,
            ticks: {
              callback: (value) => `${formatNumber(value, 1)}%`,
              font: { size: 9, family: "Inter" },
              padding: 5,
              maxTicksLimit: 6, // <-- PERBAIKAN: Batasi jumlah label Y
            },
            grid: {
               color: '#f0f0f0',
               drawBorder: false,
               drawTicks: false,
            },
            title: { display: false },
            // ▼▼▼ PERBAIKAN: Gunakan min/max baru ▼▼▼
            suggestedMin: finalMin,
            suggestedMax: finalMax
            // ▲▲▲ AKHIR PERBAIKAN ▲▲▲
          },
        },
      }
    );
  } catch (err) {
    console.error("Error rendering monthly percentage chart:", err);
    loading.classList.add("hidden");
    error.textContent =
      "Gagal memuat data grafik bulanan: " + err.message;
    error.classList.remove("hidden");
    canvas.style.display = "none";
  }
}
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 1 ▲▲▲
// ▲▲▲ AKHIR DARI BLOK PENGGANTIAN 2 ▲▲▲
      // --- AKHIR DARI FUNGSI renderMonthlyPercentageChart ---
      // --- AKHIR DARI FUNGSI renderMonthlyPercentageChart ---

      /**
       * FUNGSI BANTUAN BARU: Mengonversi data dari <tbody> tabel HTML menjadi format Array of Arrays.
       * @param {HTMLElement} tableBodyElement - Elemen <tbody> dari tabel yang akan dibaca.
       * @param {Array<string>} headers - Array berisi string header untuk baris pertama.
       * @returns {Array<Array<string>>} Data tabel dalam format AoA.
       */
      function tableToAoA(tableBodyElement, headers) {
        const data = [headers]; // Mulai dengan baris header
        if (tableBodyElement && tableBodyElement.rows.length > 0) {
          // Cek jika baris pertama adalah pesan "tidak ada data"
          if (tableBodyElement.rows[0].cells.length <= 1) {
            return data; // Kembalikan hanya header jika tidak ada data
          }
          for (const row of tableBodyElement.rows) {
            const rowData = Array.from(row.cells).map((cell) => {
              // Bersihkan teks dari karakter mata uang, persen, dan koma ribuan
              return cell.textContent.replace(/[$,%]/g, "").trim();
            });
            data.push(rowData);
          }
        }
        return data;
      }

      // --- GANTI SELURUH FUNGSI LAMA DI BAWAH INI DENGAN VERSI BARU ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN UTAMA: Logika kalkulasi diubah total sesuai permintaan.
       * Nett SL/TP sekarang dihitung berdasarkan: Lot Size * Visual Pips * Pip Value.
       * Lot Size dihitung dari risiko yang ditentukan pengguna.
       */
      function calculateRow(rowId) {
        const rowElement = document.getElementById(`inputRow-${rowId}`);
        if (!rowElement) return null;
        const tradeType = rowElement
          .querySelector(`#buyBtn-${rowId}`)
          .classList.contains("active")
          ? "BUY"
          : "SELL";
        const inputs = [
          "symbol",
          "balance",
          "riskPercent",
          "priceNow",
          "openPrice",
          "slPrice",
          "tpPrice",
          "note",
        ].reduce(
          (acc, id) => ({
            ...acc,
            [id]: rowElement.querySelector(`#${id}-${rowId}`),
          }),
          {}
        );

        // 1. Validasi input dasar
        const selectedSymbol = inputs.symbol.value;
        const balance = parseFloat(inputs.balance.value);
        const riskPercent = parseFloat(inputs.riskPercent.value);
        const priceNow = parseFloat(inputs.priceNow.value);
        const openPrice = parseFloat(inputs.openPrice.value);
        const slPrice = parseFloat(inputs.slPrice.value);
        const tpPrice = parseFloat(inputs.tpPrice.value);
        const note = inputs.note.value.trim();

        // (Bagian validasi input tidak berubah, jadi kita lewati untuk keringkasan)
        let isValid = true;
        // ... (kode validasi isNaN, dll. tetap sama)
        if (
          !selectedSymbol ||
          isNaN(balance) ||
          isNaN(riskPercent) ||
          isNaN(openPrice) ||
          isNaN(slPrice) ||
          isNaN(tpPrice)
        ) {
          // (Logika untuk menandai input yang salah tetap sama)
          return { error: true };
        }

        const assetData = getAssetData(selectedSymbol);

        // 2. Hitung Pips/Points Presisi (untuk rasio) dan Visual (untuk tampilan & kalkulasi Nett)
        const priceDiffSL =
          tradeType === "BUY" ? openPrice - slPrice : slPrice - openPrice;
        const priceDiffTP =
          tradeType === "BUY" ? tpPrice - openPrice : openPrice - tpPrice;
        const priceDiffPending =
          tradeType === "BUY" ? priceNow - openPrice : openPrice - priceNow;

        if (priceDiffSL <= 0 || priceDiffTP <= 0) return { error: true }; // Validasi SL/TP tetap

        const slPipsPrecise = calculatePipsPoints(priceDiffSL, selectedSymbol);
        const tpPipsPrecise = calculatePipsPoints(priceDiffTP, selectedSymbol);
        const pendingPipsPrecise = calculatePipsPoints(
          priceDiffPending,
          selectedSymbol
        );

        // Nilai visual yang akan ditampilkan di tabel
        const visualSLPoints = getVisualPoints(
          slPipsPrecise,
          selectedSymbol
        ).forCalc;
        const visualTPPoints = getVisualPoints(
          tpPipsPrecise,
          selectedSymbol
        ).forCalc;

        // 3. Kalkulasi Lot Size (berdasarkan risiko yang ditentukan)
        const riskAmount = balance * (riskPercent / 100);
        const { pipValue, minLotIncrement } = assetData;

        // Rumus baru untuk lot size: Lot = Risk Amount / (Visual SL Pips * Pip Value)
        const rawLotSize =
          visualSLPoints > 0 && pipValue > 0
            ? riskAmount / (visualSLPoints * pipValue)
            : 0;

        // Sesuaikan dengan kenaikan lot minimum
        let finalLotSize =
          Math.floor(rawLotSize / minLotIncrement) * minLotIncrement;
        if (finalLotSize === 0 && rawLotSize > 0)
          finalLotSize = minLotIncrement;

        // 4. Kalkulasi Nett SL dan Nett TP (berdasarkan rumus baru)
        const finalNettSL = -(finalLotSize * visualSLPoints * pipValue);
        const finalNettTP = finalLotSize * visualTPPoints * pipValue;

        // 5. Kalkulasi R:R dan Persentase
        const rrPips = slPipsPrecise > 0 ? tpPipsPrecise / slPipsPrecise : 0;
        const [percentageSL, percentageTP] =
          balance > 0
            ? [
                (Math.abs(finalNettSL) / balance) * 100,
                (finalNettTP / balance) * 100,
              ]
            : [0, 0];

        // 6. Kembalikan hasil
        return {
          rowId,
          symbol: selectedSymbol,
          tradeType,
          balance,
          entryTime: new Date().toISOString(),
          openPrice,
          slPrice,
          tpPrice,
          priceNow,
          pendingPips: pendingPipsPrecise,
          slPips: slPipsPrecise,
          tpPips: tpPipsPrecise,
          rrPips,
          rrPercentage: { sl: percentageSL, tp: percentageTP },
          lotSize: finalLotSize,
          nettSL: finalNettSL,
          nettTP: finalNettTP,
          error: false,
          assetData,
          riskPercent: riskPercent,
          note,
        };
      }

      function displayCalculationDetails(result) {
        calculationDetailsContainer.innerHTML = "";
        // This section is now hidden by default and might be used for single-plan details if needed in the future
        // For now, it won't display anything unless explicitly made visible and populated.
      }

      // ▼▼▼ KODE BARU 3: GANTI SELURUH FUNGSI calculateAllRows DENGAN INI ▼▼▼
      async function calculateAllRows() {
    console.log("Calculating all rows...");

    // 1. Cek Limit Resiko Akun (Harian/Bulanan)
    const limitStatus = checkAllTradeLimits();
    if (limitStatus.isLocked) {
        showMessageBox("Perhitungan Diblokir", limitStatus.reason, false);
        return;
    }

    const allInputRows = document.querySelectorAll(".input-row");
    const newCalculatedPlans = [];
    let hasBlockingError = false; 

    // Loop async
    for (const row of allInputRows) {
        const rowId = row.id.split("-")[1];
        
        // Hitung TP & Result
        autoCalculateTpPrice(rowId); 
        const result = calculateRow(rowId);

        if (result && !result.error) {
            
            // ============================================================
            // 1. CEK BATAS SL PIPS (VALIDASI)
            // ============================================================
            if (ASSET_SL_LIMITS[result.symbol]) {
                const limit = ASSET_SL_LIMITS[result.symbol];
                const currentVisualPips = getVisualPoints(result.slPips, result.symbol).forCalc;

                if (currentVisualPips > limit) {
                    hasBlockingError = true; 

                    let multiplier = 10; 
                    if (result.symbol === "XAG/USD") multiplier = 100; 

                    const allowedPriceDistance = limit / multiplier;
                    let suggestedSLPrice = (result.tradeType === "BUY") 
                        ? result.openPrice - allowedPriceDistance
                        : result.openPrice + allowedPriceDistance;

                    const confirmFix = await showMessageBox(
                        "Batas SL Pips Terlampaui!",
                        `Aset <strong>${result.symbol}</strong> melebihi batas aman.<br>Saran SL: <strong>${suggestedSLPrice.toFixed(result.assetData.decimals)}</strong>`,
                        true, 
                        { customButtonText: "Terapkan" } 
                    );

                    if (confirmFix.confirmed) {
                        const slInput = document.getElementById(`slPrice-${rowId}`);
                        if (slInput) {
                            // Ganti nilai input UI
                            slInput.value = suggestedSLPrice.toFixed(result.assetData.decimals);
                            
                            // Simpan perubahan INPUT ke LocalStorage (Bukan ke DB dulu)
                            // saveInputRowsToLocalStorage(); 
                            
                            // Return agar user menekan tombol "Hitung" sekali lagi 
                            // untuk memastikan angka final benar-benar valid
                            return; 
                        }
                    }
                    return; // Stop jika batal
                }
            }
            // ============================================================
            // AKHIR VALIDASI
            // ============================================================

            // 2. SIMPAN KE DATABASE (Hanya jika lolos validasi di atas)
            // Ini bagian yang hilang di kodemu sebelumnya
            try {
                await addDataToDatabase(result); 

                
                // Siapkan data untuk tampilan sementara (agar langsung muncul tanpa refresh)
                result.id = `local-${Date.now()}-${rowId}`; 
                newCalculatedPlans.unshift(result);
            } catch (err) {
                console.error("Gagal save DB:", err);
            }
        }
    }
    
    // 3. UPDATE TAMPILAN (RENDER)
    // Jika tidak ada error blocking, update tabel UI
    if (!hasBlockingError && newCalculatedPlans.length > 0) {
        
        // Update variable global data
        // Kita gabungkan data baru di paling atas, lalu data lama
        if (typeof calculatedPlansData !== 'undefined') {
            calculatedPlansData = [...newCalculatedPlans, ...calculatedPlansData];
        }

        // Simpan ke LocalStorage agar data aman jika user refresh manual nanti
        saveDataToLocalStorage(); 

        // Render ulang tabel tanpa refresh halaman
        renderCalculatedPlans();
        
        // Scroll otomatis ke tabel hasil
        const resultSection = document.getElementById("newTradingPlansSection");
        if (resultSection) {
            resultSection.scrollIntoView({ behavior: "smooth" });
        }
    }
}

      async function addDataToDatabase(result) {
        await fetch("https://leodra.fiqrianandahakin.my.id/api/trade", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            rowId: result.rowId,
            symbol: result.symbol,
            tradeType: result.tradeType,
            balance: result.balance,
            entryTime: result.entryTime,
            openPrice: result.openPrice,
            slPrice: result.slPrice,
            tpPrice: result.tpPrice,
            priceNow: result.priceNow,
            pendingPips: result.pendingPips,
            slPips: result.slPips,
            tpPips: result.tpPips,
            rrPips: result.rrPips,
            rrPercentage: result.rrPercentage,
            lotSize: result.lotSize,
            nettSL: result.nettSL,
            nettTP: result.nettTP,
            error: result.error,
            assetData: result.assetData,
            riskPercent: result.riskPercent,
            note: result.note,
          }),
        });
      }

// ▼▼▼ FUNGSI RENDER PLANS DIPERBARUI (FIX TOTAL) ▼▼▼
      function renderPlans(plans, bodyElement, colSpan, emptyMsg, isCalc, isRun) {
         bodyElement.innerHTML = "";
         
         if (plans.length === 0) {
           // Update colspan + 1 karena ada kolom Foto baru (Total 24 kolom untuk Executed)
           const actualColSpan = (!isCalc && !isRun) ? 24 : colSpan + 1; 
           bodyElement.innerHTML = `<tr><td colspan="${actualColSpan}" class="py-4 text-center text-gray-500">${emptyMsg}</td></tr>`;
           return;
         }

         plans.forEach((plan, i) => {
            const timeStr = formatDateAndTimeForExport(plan.entryTime);
            const isExecuted = !isCalc && !isRun; 

            // Data Visual & Kalkulasi Standard
            const visualSL = getVisualPoints(plan.slPips, plan.symbol).display;
            const visualTP = getVisualPoints(plan.tpPips, plan.symbol).display;
            const visualPending = getVisualPoints(plan.pendingPips, plan.symbol, isExecuted).display;
            const rrPipsDisplay = plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : "N/A";
            
            let rrPercentageHtml = '<span class="neutral-value">N/A</span>';
            if (plan.rrPercentage) {
                 rrPercentageHtml = `<span class="negative-value">-${formatNumber(plan.rrPercentage.sl, 2)}%</span> : <span class="positive-value">${formatNumber(plan.rrPercentage.tp, 2)}%</span>`;
            }

            let durationHtml = "";
            if (isRun) {
                durationHtml = `<br><span class="running-timer text-xs font-mono text-blue-600 bg-blue-50 px-1 rounded mt-1 inline-block" data-entry="${plan.entryTime}">Memuat...</span>`;
            }

            // Tampilan Nett SL/TP (Coretan jika diedit)
            let displayNettSL = `<span class="negative-value">${formatCurrency(plan.nettSL)}</span>`;
            if (isExecuted && plan.originalNettSL !== undefined && plan.originalNettSL !== null && Math.abs(plan.originalNettSL - plan.nettSL) > 0.01) {
                displayNettSL = `
                    <div class="flex flex-col items-center justify-center leading-tight">
                        <span class="line-through text-gray-400 text-[10px] decoration-gray-400">${formatCurrency(plan.originalNettSL)}</span>
                        <span class="negative-value font-bold">${formatCurrency(plan.nettSL)}</span>
                    </div>
                `;
            }

            let displayNettTP = `<span class="positive-value">${formatCurrency(plan.nettTP)}</span>`;
            if (isExecuted && plan.originalNettTP !== undefined && plan.originalNettTP !== null && Math.abs(plan.originalNettTP - plan.nettTP) > 0.01) {
                displayNettTP = `
                    <div class="flex flex-col items-center justify-center leading-tight">
                        <span class="line-through text-gray-400 text-[10px] decoration-gray-400">${formatCurrency(plan.originalNettTP)}</span>
                        <span class="positive-value font-bold">${formatCurrency(plan.nettTP)}</span>
                    </div>
                `;
            }

            // ▼▼▼ PERBAIKAN LOGIKA INTERVENSI (STEP 1: LOGIKA RENDER UI) ▼▼▼
            let interventionCellHtml = "";
            let nonInterventionCellHtml = "";

            if (isExecuted) {
                // 1. Tentukan Nilai Original & Final berdasarkan Outcome (TP/SL)
                let finalVal = 0; // Nilai Akhir (Yang tampil di Result Intervensi)
                let origVal = 0;  // Nilai Asli (Yang tampil di Result Tidak Intervensi)
                let isIntervened = false; // Status apakah user mengedit nilai

                if (plan.outcome === "Take Profit") {
                    // Ambil original TP jika ada, jika tidak pakai nettTP saat ini
                    origVal = plan.originalNettTP !== undefined ? plan.originalNettTP : plan.nettTP;
                    finalVal = plan.nettTP;
                } else if (plan.outcome === "Stop Loss") {
                    // Ambil original SL jika ada, jika tidak pakai nettSL saat ini
                    origVal = plan.originalNettSL !== undefined ? plan.originalNettSL : plan.nettSL;
                    finalVal = plan.nettSL;
                }

                // Cek apakah ada perbedaan nilai (toleransi 0.01 untuk floating point)
                if (Math.abs(finalVal - origVal) > 0.01) {
                    isIntervened = true;
                }

                // 2. Render Kolom "Result Intervensi" (KOLOM KIRI)
                if (plan.outcome === "Take Profit" || plan.outcome === "Stop Loss") {
                    const finalColorClass = finalVal >= 0 ? 'positive-value font-bold' : 'negative-value font-bold';
                    let finalDisplay = formatCurrency(finalVal, "USD");
                    let cellClass = "text-center align-middle bg-yellow-50/30";

                    // JIKA DIEDIT (INTERVENSI): Beri Kurung & List Merah
                    if (isIntervened) {
                        finalDisplay = `( ${finalDisplay} )`; // Tambah Kurung
                        cellClass = "text-center align-middle intervened-cell"; // Tambah Class List Merah
                    }

                    interventionCellHtml = `<td class="${cellClass}"><span class="${finalColorClass}">${finalDisplay}</span></td>`;
                } else {
                    // Jika Cancel/Tes
                    interventionCellHtml = `<td class="text-center text-gray-400 bg-yellow-50/30 align-middle">-</td>`;
                }

                // 3. Render Kolom "Result Tidak Intervensi" (KOLOM KANAN)
                // Selalu tampilkan nilai ORIGINAL tanpa tanda kurung/merah
                if (plan.outcome === "Take Profit" || plan.outcome === "Stop Loss") {
                    const origColorClass = origVal >= 0 ? 'positive-value' : 'negative-value';
                    nonInterventionCellHtml = `<td class="text-center bg-blue-50/30 align-middle"><span class="${origColorClass}">${formatCurrency(origVal, "USD")}</span></td>`;
                } else {
                    nonInterventionCellHtml = `<td class="text-center text-gray-400 bg-blue-50/30 align-middle">-</td>`;
                }
            }
            // ▲▲▲ AKHIR PERBAIKAN LOGIKA ▲▲▲

            // Logika Kolom Foto (Lihat)
            let photoColumnContent = "";
            if (isCalc) {
                if (plan.images && plan.images.length > 0 ) {
                    photoColumnContent = `
                        <div class="flex flex-col items-center gap-1">
                            <button class="action-button-small bg-blue-600 border-blue-600 hover:bg-blue-700 w-full" data-action="view-photo" data-id="${plan.id}" data-entry-time="${plan.entryTime}">Lihat</button>
                            <button class="text-[9px] text-gray-500 underline cursor-pointer" data-action="upload-photo" data-id="${plan.id}" data-entry-time="${plan.entryTime}">Ganti</button>
                        </div>`;
                } else {
                    photoColumnContent = `
                        <button class="action-button-small bg-gray-200 text-gray-700 border-gray-300 hover:bg-gray-300 w-full flex items-center justify-center gap-1" data-action="upload-photo" data-id="${plan.id}" data-entry-time="${plan.entryTime}">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg> Uploads
                        </button>`;
                }
            } else {
                if (plan.images.length > 0 ) {
                    photoColumnContent = `<button class="action-button-small bg-blue-600 text-white border-blue-600 hover:bg-blue-700 w-full" data-action="view-photo" data-entry-time="${plan.entryTime}">Pratinjau</button>`;
                } else {
                    photoColumnContent = `<span class="text-xs text-gray-400 italic">No Img</span>`;
                }
            }

            // Logika Tombol Aksi
            let col19Content = ""; 
            let col20Content = ""; 
            
            if (isCalc) {
                const formattedTime = new Date(plan.entryTime).toLocaleTimeString('id-ID', { hour:'2-digit', minute:'2-digit', second:'2-digit' }).replace(/\./g,':');
                col19Content = `
                <div class="flex flex-row justify-center items-center gap-1">
                  <button class="action-button-small" data-from-section="calculated" data-outcome="Running" data-id="${plan.id}" data-entry-time="${plan.entryTime}">Run <span class="text-gray-400 font-mono text-xs ml-1">(${formattedTime})</span></button>
                  <button class="action-button-small bg-red-100 text-red-700 border-red-300 hover:bg-red-200" data-from-section="calculated" data-outcome="Hapus" data-id="${plan.id}" data-entry-time="${plan.entryTime}" title="Hapus">Hapus</button>
                </div>`;
            } else if (isRun) {
                const actionBtnClass = "action-button-small px-2 py-1"; 
                col19Content = `
                 <div class="flex flex-row justify-center items-center gap-1 whitespace-nowrap">
                     <button class="${actionBtnClass}" data-from-section="running" data-id="${plan.id}" data-outcome="Take Profit" data-entry-time="${plan.entryTime}">TP</button>
                     <button class="${actionBtnClass}" data-from-section="running" data-id="${plan.id}" data-outcome="Stop Loss" data-entry-time="${plan.entryTime}">SL</button>
                     <button class="${actionBtnClass}" data-from-section="running" data-id="${plan.id}" data-outcome="Tes" data-entry-time="${plan.entryTime}">Tes</button>
                     <button class="${actionBtnClass}" data-from-section="running" data-id="${plan.id}" data-outcome="Cancel" data-entry-time="${plan.entryTime}">Batal</button>
                     <button class="${actionBtnClass}" data-from-section="running" data-id="${plan.id}" data-outcome="Edit" data-entry-time="${plan.entryTime}">Edit</button>
                 </div>`;
            } else {
                col19Content = `<span class="font-semibold">${plan.outcome || '-'}</span>`;
                col20Content = plan.hasBeenEdited ? '<span class="text-xs text-gray-400 italic">Edited</span>' : `<button class="action-button-small bg-white text-gray-600 border border-gray-300 hover:bg-gray-50" data-from-section="executed" data-id="${plan.id}" data-outcome="Revisi" data-entry-time="${plan.entryTime}">Revisi</button>`;
            }

            // Susun Sel Tengah (Sesuai Permintaan: Intervensi -> Tidak Intervensi -> Catatan -> Lihat)
            let dynamicMiddleCells = "";
            if (isExecuted) {
                dynamicMiddleCells = `
                    ${interventionCellHtml}
                    ${nonInterventionCellHtml}
                    <td class="text-center max-w-xs truncate align-middle" title="${plan.note || ''}">${plan.note || '-'}</td>
                    <td class="text-center align-middle px-2">${photoColumnContent}</td>
                `;
            } else {
                // Rencana Baru & Aktif: Catatan -> Foto (Lihat)
                dynamicMiddleCells = `
                    <td class="text-center max-w-xs truncate align-middle" title="${plan.note || ''}">${plan.note || '-'}</td>
                    <td class="text-center align-middle px-2">${photoColumnContent}</td>
                `;
            }

            let rowHtml = `
              <tr class="hover:bg-gray-50 align-middle"> 
                <td class="text-center align-middle">${i+1}</td>
                <td class="text-center align-middle">${plan.symbol}</td>
                <td class="text-center font-semibold align-middle ${plan.tradeType === 'BUY' ? 'positive-value' : 'negative-value'}">${plan.tradeType}</td>
                <td class="text-center align-middle">${formatCurrency(plan.balance)}</td>
                <td class="text-center align-middle">
                    ${timeStr}
                    ${durationHtml}
                </td>
                <td class="text-center align-middle">${plan.priceNow}</td>
                <td class="text-center align-middle">${plan.openPrice}</td>
                <td class="text-center align-middle">${plan.slPrice}</td>
                <td class="text-center align-middle">${plan.tpPrice}</td>
                <td class="text-center align-middle ${plan.pendingPips >= 0 ? 'positive-value' : 'negative-value'}">${visualPending}</td>
                <td class="text-center align-middle neutral-value">${visualSL}</td>
                <td class="text-center align-middle positive-value">${visualTP}</td>
                <td class="text-center align-middle">${rrPipsDisplay}</td>
                <td class="text-center align-middle">${rrPercentageHtml}</td>
                <td class="text-center align-middle ${plan.lotSize === 0 ? 'negative-value' : 'neutral-value'}">${formatNumber(plan.lotSize, 2)}</td>
                <td class="text-center align-middle">${displayNettSL}</td>
                <td class="text-center align-middle">${displayNettTP}</td>
                
                ${dynamicMiddleCells}

                <td class="text-center align-middle"><div class="action-buttons-cell w-full justify-center">${col19Content}</div></td>
                <td class="text-center align-middle">${col20Content}</td>
            `;

            if (isExecuted) {
                rowHtml += `<td class="text-center align-middle">${plan.timestamp ? formatDateAndTimeForExport(plan.timestamp) : ''}</td>`;
            }

            rowHtml += `</tr>`;
            bodyElement.insertAdjacentHTML("beforeend", rowHtml);
         });
      
      // ▲▲▲ AKHIR FUNGSI PERBAIKAN ▲▲▲
      
      // ▲▲▲ AKHIR FUNGSI PERBAIKAN ▲▲▲
      
      
        // --- INI BAGIAN PERBAIKAN ---
        // Event listener sekarang dipasang dengan benar untuk memanggil fungsi yang sudah ada.
        bodyElement
          .querySelectorAll(".action-button-small")
          .forEach((button) => {
            button.addEventListener("click", (event) => {
              // --- PERBAIKAN UTAMA: Menggunakan data-entry-time ---
              const { rowId, outcome, fromSection, entryTime } =
                event.target.closest(".action-button-small").dataset;

              if (fromSection === "calculated") {
                setRunning(rowId);
              } else if (fromSection === "running") {
                const entryTime = button.dataset.entryTime;
                const outcome = button.dataset.outcome;

                const planToConfirm = runningPlansData.find(
                  (p) => p.entryTime === entryTime
                );

                if (!planToConfirm) {
                  console.error(
                    "Tidak dapat menemukan detail trade untuk konfirmasi:",
                    entryTime
                  );
                  showMessageBox(
                    "Gagal",
                    "Tidak dapat menemukan detail trade. Coba muat ulang halaman.",
                    false
                  );
                  return;
                }

                // --- PERBAIKAN UTAMA: Memperbarui isi notifikasi agar lebih detail ---
                const rrPipsFormatted =
                  planToConfirm.rrPips > 0
                    ? "1:" + formatNumber(planToConfirm.rrPips, 1, false)
                    : "N/A";
                let rrPercentageHtml = "N/A";
                if (planToConfirm.rrPercentage) {
                  rrPercentageHtml = `<span class="negative-value">-${formatNumber(
                    planToConfirm.rrPercentage.sl,
                    2
                  )}%</span> : <span class="positive-value">${formatNumber(
                    planToConfirm.rrPercentage.tp,
                    2
                  )}%</span>`;
                }

                // Membuat HTML detail yang baru dan lengkap
                const detailsHtml = `
              <div class="text-left text-xs space-y-1 bg-gray-50 p-4 rounded-lg border border-gray-200 grid grid-cols-2 gap-x-4 gap-y-2">
                  <p><strong>Aset:</strong></p> <p>${planToConfirm.symbol}</p>
                  <p><strong>Tipe Trade:</strong></p> <p><span class="${
                    planToConfirm.tradeType === "BUY"
                      ? "positive-value"
                      : "negative-value"
                  } font-semibold">${planToConfirm.tradeType}</span></p>
                  <p><strong>Balance Akun:</strong></p> <p>${formatCurrency(
                    planToConfirm.balance,
                    "USD"
                  )}</p>
                  <p><strong>Waktu Masuk:</strong></p> <p>${formatDateAndTimeForExport(
                    planToConfirm.entryTime
                  )}</p>
                  <p><strong>Open Price:</strong></p> <p>${formatNumber(
                    planToConfirm.openPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>SL Price:</strong></p> <p>${formatNumber(
                    planToConfirm.slPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>TP Price:</strong></p> <p>${formatNumber(
                    planToConfirm.tpPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>Pending Pips:</strong></p> <p>${
                    getVisualPoints(
                      planToConfirm.pendingPips,
                      planToConfirm.symbol
                    ).display
                  }</p>
                  <p><strong>SL Pips:</strong></p> <p>${
                    getVisualPoints(planToConfirm.slPips, planToConfirm.symbol)
                      .display
                  }</p>
                  <p><strong>TP Pips:</strong></p> <p>${
                    getVisualPoints(planToConfirm.tpPips, planToConfirm.symbol)
                      .display
                  }</p>
                  <p><strong>R:R Pips:</strong></p> <p>${rrPipsFormatted}</p>
                  <p><strong>R:R %:</strong></p> <div>${rrPercentageHtml}</div>
                  <p><strong>Lot/Units:</strong></p> <p>${formatNumber(
                    planToConfirm.lotSize,
                    2
                  )}</p>
                  <p><strong>Nett SL:</strong></p> <p class="negative-value">${formatCurrency(
                    planToConfirm.nettSL,
                    "USD"
                  )}</p>
                  <p><strong>Nett TP:</strong></p> <p class="positive-value">${formatCurrency(
                    planToConfirm.nettTP,
                    "USD"
                  )}</p>
                  <p><strong>Catatan:</strong></p> <p>${
                    planToConfirm.note || "-"
                  }</p>
              </div>
              <hr class="my-4">
          `;
                // --- AKHIR PERBAIKAN ---

                if (outcome === "Edit") {
                  const confirmationMessage = `<p class="text-sm text-center">Yakin ingin <strong>MENGEDIT</strong> trade ini? Rencana akan kembali ke formulir input.</p>`;
                  showMessageBox(
                    "Konfirmasi: Edit",
                    detailsHtml + confirmationMessage,
                    true
                  ).then((result) => {
                    if (result.confirmed) editRunningPlan(entryTime);
                  });
                } else {
                  const actionText =
                    outcome === "Cancel"
                      ? "MEMBATALKAN"
                      : outcome.toUpperCase();
                  const confirmationMessage = `<p class="text-sm text-center">Yakin ingin menyelesaikan trade ini dengan hasil <strong>${actionText}</strong>?</p>`;

                  showMessageBox(
                    `Konfirmasi: ${outcome}`,
                    detailsHtml + confirmationMessage,
                    true,
                    { editableNettValues: true, plan: planToConfirm }
                  ).then((result) => {
                    if (result.confirmed) {
                      completeTrade(entryTime, outcome, fromSection, result);
                    }
                  });
                }
              }
            });
          });
      }

// ▼▼▼ FUNGSI REVERT EXECUTED PLAN (FIX REVISI BERSIH) ▼▼▼
      async function revertExecutedPlan(id, entryTime) {
          console.log(`Mengembalikan trade (Waktu: ${entryTime}) ke status Aktif.`);

          // 1. Cari indeks plan
          const index = executedPlansData.findIndex(plan => plan.entryTime === entryTime);

          if (index === -1) {
              console.error(`Gagal menemukan data selesai untuk direvisi.`);
              showMessageBox("Gagal", "Data tidak ditemukan.", false);
              return;
          }

          // 2. Pindahkan data
          const planToRevert = executedPlansData.splice(index, 1)[0];

          // 3. Tambahkan flag bahwa sudah pernah diedit
          planToRevert.hasBeenEdited = true;

          // 4. BERSIHKAN DATA LAMA (BAGIAN PENTING!)
          // Hapus hasil eksekusi sebelumnya
          delete planToRevert.outcome;
          delete planToRevert.timestamp; 
          
          // Hapus data "Original" lama agar saat diselesaikan nanti,
          // sistem membuat "Original" baru berdasarkan data hasil revisi.
          delete planToRevert.originalNettSL;
          delete planToRevert.originalNettTP;
          delete planToRevert.originalTpPrice;
          delete planToRevert.originalSlPips;
          delete planToRevert.originalTpPips;
          delete planToRevert.originalRrPips;
          delete planToRevert.originalrrSlPercentage;
          delete planToRevert.originalrrTpPercentage;

          // 5. Kembalikan ke array Running
          runningPlansData.unshift(planToRevert);

          // 6. Update status di backend
          try {
              // Kirim status RUNNING dan null untuk mereset data di DB
              await saveRunningPlan(
                  id, "RUNNING", null, null, 
                  null, null, null, null, null, null, null, null
              );
          } catch (error) {
              console.error("Gagal mengupdate status backend saat revert:", error);
          }

          // 7. Simpan & Render
          saveDataToLocalStorage();
          
          console.log("Rendering ulang tabel...");
          renderRunningPlans();    
          renderExecutedPlans();   

          // Hitung ulang semua statistik
          calculateSummaryStatistics();
          updateRiskRewardStatistics();
          calculateAndRenderMonthlyPLSummary();
          renderDailyRiskSummary();
          renderMonthlyRiskSummary();
          renderMaxDrawdownRiskSummary();
          calculateAndRenderDailySummary();
          calculateAndRenderWeeklySummary();
          calculateAndRenderNewMonthlySummary();
          calculateAndRenderYearlySummary();
          updateInterventionStatistics();
          fetchAndRenderGhostEquityChart();
          
          if (typeof renderCalendar === 'function' && typeof currentCalendarDate !== 'undefined') {
               renderCalendar(currentCalendarDate);
          }
          animateOnScroll();

          console.log(`Trade berhasil direvisi dan dibersihkan.`);
      }
      // --- AKHIR DARI FUNGSI revertExecutedPlan ---
      // --- AKHIR DARI FUNGSI revertExecutedPlan ---
      // --- AKHIR DARI FUNGSI revertExecutedPlan ---

      function renderCalculatedPlans() {
        console.log(
          "Rendering calculated plans. Data length:",
          calculatedPlansData.length
        );
        renderPlans(
          calculatedPlansData,
          calculatedPlansBody,
          18,
          "Belum ada rencana trading baru.",
          true,
          false
        );
      }

      function renderRunningPlans() {
        console.log(
          "Rendering running plans. Data length:",
          runningPlansData.length
        );
        
        // Render tabel dengan flag isRun = true
        renderPlans(
          runningPlansData,
          runningPlansBody,
          18,
          "Belum ada rencana trading aktif.",
          false,
          true 
        );
        
        // Update ringkasan di atas tabel
        updateActivePlansSummary();

        // ▼▼▼ PERBAIKAN: JALANKAN TIMER SETELAH TABEL DIBUAT ▼▼▼
        if (typeof startActiveTimers === 'function') {
            startActiveTimers();
        }
        // ▲▲▲ AKHIR PERBAIKAN ▲▲▲
      }

      async function renderExecutedPlans() {
        console.log(
          "Rendering executed plans. Data length:",
          executedPlansData.length
        );
        renderPlans(
          executedPlansData,
          executedPlansBody,
          19,
          "Belum ada rencana trading yang selesai."
        );
        updateRiskRewardStatistics();
      }

      /**
       * FUNGSI BANTUAN BARU: Mengatur skala grafik agar responsif.
       * @param {Array} labels - Daftar semua label untuk sumbu-X.
       * @param {string} yAxisTitle - Judul untuk sumbu-Y.
       * @param {Function} yTickCallback - Fungsi untuk memformat label sumbu-Y.
       * @param {boolean} yBeginAtZero - Apakah sumbu-Y harus dimulai dari nol.
       * @returns {Object} Konfigurasi skala untuk Chart.js.
       */
      function getResponsiveChartScales(
        labels,
        yAxisTitle,
        yTickCallback,
        yBeginAtZero = false
      ) {
        const isMobile = window.innerWidth <= 768;
        const totalLabels = labels.length;

        // Tentukan indeks yang akan ditampilkan di mobile
        const indicesToShow = new Set();
        if (totalLabels > 0) {
          indicesToShow.add(0); // Selalu tampilkan yang pertama
          indicesToShow.add(Math.floor((totalLabels - 1) / 2)); // Tampilkan yang tengah
          indicesToShow.add(totalLabels - 1); // Selalu tampilkan yang terakhir
        }

        return {
          x: {
            title: {
              display: true,
              text: "Tanggal & Waktu Trade",
              color: "#555",
              font: { family: "Inter", size: 8, weight: "bold" },
            },
            ticks: {
              color: "#555",
              font: { family: "Inter", size: 7 },
              callback: function (value, index, ticks) {
                // Di mobile, hanya tampilkan label pada indeks yang telah ditentukan
                if (isMobile && totalLabels > 3) {
                  // Terapkan hanya jika ada lebih dari 3 data
                  if (indicesToShow.has(index)) {
                    // Mengambil label asli dari array `labels`
                    return labels[index];
                  }
                  return null; // Sembunyikan label lainnya
                }
                // Di desktop, tampilkan semua label
                return labels[index];
              },
              autoSkip: false, // Wajib untuk memastikan callback kita berjalan untuk semua label
            },
          },
          y: {
            beginAtZero: yBeginAtZero,
            title: {
              display: true,
              text: yAxisTitle,
              color: "#555",
              font: { family: "Inter", size: 8, weight: "bold" },
            },
            ticks: {
              callback: yTickCallback,
              color: "#555",
              font: { family: "Inter", size: 7 },
            },
          },
        };
      }

      // ▼▼▼ FUNGSI BARU: CEK LIMIT LOSS BERTURUT-TURUT (10x) ▼▼▼
      function getReadableDuration(ms) {
        const days = Math.floor(ms / (24 * 60 * 60 * 1000));
        const hours = Math.floor((ms % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
        const minutes = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
        return `${days} Hari, ${hours} Jam, ${minutes} Menit`;
      }

      function checkConsecutiveLossLimit() {
        const MAX_CONSECUTIVE_LOSS = 10;
        const LOCK_DURATION_DAYS = 7; // Durasi hukuman 1 Minggu
        const LOCK_DURATION_MS = LOCK_DURATION_DAYS * 24 * 60 * 60 * 1000;

        // 1. Ambil data trade yang valid (TP/SL) & urutkan dari terbaru
        // Kita perlu menyalin array dulu [...executedPlansData] agar urutan asli tidak berubah
        const validTrades = [...executedPlansData]
            .filter(p => p.outcome === "Take Profit" || p.outcome === "Stop Loss")
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // 2. Hitung streak loss saat ini (dihitung dari yang terbaru)
        let currentLossStreak = 0;
        for (const trade of validTrades) {
            if (trade.outcome === "Stop Loss") {
                currentLossStreak++;
            } else {
                break; // Streak terputus jika ketemu TP
            }
        }

        // 3. Cek apakah streak mencapai batas
        if (currentLossStreak >= MAX_CONSECUTIVE_LOSS) {
            // Kunci dihitung sejak trade loss TERAKHIR (paling baru) terjadi
            // Karena itu adalah titik di mana trader mencapai batas kesalahannya
            const lastLossTime = new Date(validTrades[0].timestamp).getTime();
            const unlockTime = lastLossTime + LOCK_DURATION_MS;
            const now = Date.now();

            if (now < unlockTime) {
                return {
                    isLocked: true,
                    streak: currentLossStreak,
                    unlockTime: unlockTime,
                    remainingMs: unlockTime - now
                };
            }
        }

        return { isLocked: false };
      }
      // ▲▲▲ AKHIR FUNGSI BARU ▲▲▲

      // ▼▼▼ FUNGSI BARU: CEK BATAS JUMLAH TRADE BULANAN ▼▼▼
      function checkMonthlyTradeLimit() {
        const now = new Date();
        const currentMonthKey = now.toISOString().slice(0, 7); // Format: YYYY-MM (Misal: 2025-11)
        const MAX_TRADES_PER_MONTH = 24;

        // Hitung trade yang sudah SELESAI bulan ini (Hanya TP dan SL)
        // Abaikan 'Cancel' atau 'Tes'
        const monthlyValidTrades = executedPlansData.filter(plan => {
            if (!plan.timestamp) return false;
            const isThisMonth = plan.timestamp.startsWith(currentMonthKey);
            const isValidOutcome = plan.outcome === "Take Profit" || plan.outcome === "Stop Loss";
            return isThisMonth && isValidOutcome;
        });

        const currentCount = monthlyValidTrades.length;

        if (currentCount >= MAX_TRADES_PER_MONTH) {
            return {
                isLocked: true,
                count: currentCount,
                reason: `
                    <div class="text-center">
                        <p class="text-red-600 font-bold text-lg mb-2">Batas Trade Bulanan Tercapai!</p>
                        <p class="text-sm text-gray-700 mb-3">
                            Anda telah menyelesaikan <strong>${currentCount}</strong> trade valid (TP/SL) bulan ini.
                            Batas maksimal adalah <strong>${MAX_TRADES_PER_MONTH}</strong> trade.
                        </p>
                        <div class="bg-red-50 p-3 rounded border border-red-200 text-xs text-red-800">
                            <strong>Aturan Disiplin:</strong><br>
                            Sistem memblokir eksekusi "Run" baru untuk mencegah <em>overtrading</em>.
                            Silakan kembali melakukan eksekusi di awal bulan depan.
                        </div>
                    </div>
                `
            };
        }

        return { isLocked: false, count: currentCount };
      }
      // ▲▲▲ AKHIR FUNGSI BARU ▲▲▲

      // ▼▼▼ GANTI SELURUH FUNGSI LAMA (baris 2938-3223) DENGAN INI ▼▼▼
// ▼▼▼ PERBAIKAN LOGIKA LOCK (HANYA PERSENTASE) ▼▼▼
      function checkAllTradeLimits() {
        const now = new Date();
        const currentMonthIdentifier = `${now.getFullYear()}-${now.getMonth()}`; 
        const todayDateString = now.toISOString().slice(0, 10); 
        const currentMonthKeyISO = now.toISOString().slice(0, 7); 

        // ... (KODE BAGIAN 1: PERSIAPAN DATA & HITUNGAN TETAP SAMA SEPERTI SEBELUMNYA) ...
        // ... (PASTIKAN ANDA MENYALIN BAGIAN HITUNGAN DARI KODE SEBELUMNYA ATAU BIARKAN SAMA) ...
        // ... Saya asumsikan bagian hitungan variabel (executedPL_Pct_Daily, dll) sudah ada di kode Anda ...
        // Agar tidak kepanjangan, saya fokus ke bagian LOGIKA RETURN DI BAWAH INI:

        // --- 1. Persiapan Data (SALIN DARI FUNGSI SEBELUMNYA) ---
        const executedToday = executedPlansData.filter(
          (p) =>
            p.timestamp &&
            p.timestamp.startsWith(todayDateString) &&
            getTradeResult(p).isValid
        );
        const tradesThisMonth = executedPlansData.filter(
          (p) =>
            p.timestamp &&
            p.timestamp.startsWith(currentMonthKeyISO) &&
            getTradeResult(p).isValid
        );
        
        const runningRiskPct = runningPlansData.reduce(
          (sum, p) => sum + (p.rrPercentage?.sl || 0),
          0
        );
        
        const newPlansRiskPct = calculatedPlansData.reduce(
          (sum, p) => sum + (p.rrPercentage?.sl || 0),
          0
        );

        let executedPL_Pct_Daily = 0;
        executedToday.forEach((p) => {
          const tradeResult = getTradeResult(p);
          if (tradeResult.isWin) {
            executedPL_Pct_Daily += p.rrPercentage?.tp || 0;
          } else {
            executedPL_Pct_Daily -= p.rrPercentage?.sl || 0;
          }
        });

        let executedPL_Pct_Monthly = 0;
        tradesThisMonth.forEach((p) => {
          const tradeResult = getTradeResult(p);
          if (tradeResult.isWin) {
            executedPL_Pct_Monthly += p.rrPercentage?.tp || 0;
          } else {
            executedPL_Pct_Monthly -= p.rrPercentage?.sl || 0;
          }
        });

        // --- 2. Hitung Nilai Akumulasi ---
        const totalAccumulatedPct_Daily = executedPL_Pct_Daily - runningRiskPct - newPlansRiskPct;
        const totalAccumulatedPct_Monthly = executedPL_Pct_Monthly - runningRiskPct - newPlansRiskPct;

        // --- 3. Tentukan Batas ---
        const DAILY_NET_LIMIT_PCT = -3.5;
        const MONTHLY_NET_LIMIT_PCT = -5.0;
        const MAX_DD_NET_LIMIT_PCT = -7.0;

        // --- 4. LOGIKA PENGUNCIAN BARU (DENGAN KUIS) ---
        let isBreached = false;
        let breachReason = "";

        if (totalAccumulatedPct_Daily <= DAILY_NET_LIMIT_PCT) {
            isBreached = true;
            breachReason = `Batas Harian (${DAILY_NET_LIMIT_PCT}%) Tercapai.`;
        } else if (totalAccumulatedPct_Monthly <= MONTHLY_NET_LIMIT_PCT) {
            isBreached = true;
            breachReason = `Batas Bulanan (${MONTHLY_NET_LIMIT_PCT}%) Tercapai.`;
        } else if (totalAccumulatedPct_Monthly <= MAX_DD_NET_LIMIT_PCT) {
            isBreached = true;
            breachReason = `Max Drawdown (${MAX_DD_NET_LIMIT_PCT}%) Tercapai.`;
        }

        // Cek apakah kuis lockout sudah diselesaikan HARI INI
        const lockoutPassedDate = localStorage.getItem('lockoutQuizPassedDate');
        const isQuizPassedToday = lockoutPassedDate === todayDateString;

        if (isBreached) {
            if (!isQuizPassedToday) {
                // JIKA BELUM LULUS KUIS: Tampilkan Modal & Kunci
                // Cek agar modal tidak muncul berulang-ulang setiap milidetik (deboucing sederhana)
                const modal = document.getElementById('lockoutQuizModal');
                if (modal && !modal.classList.contains('show')) {
                    showLockoutQuizModal(); 
                }
                return { isLocked: true, reason: breachReason + " Selesaikan kuis introspeksi!" };
            } else {
                // JIKA SUDAH LULUS KUIS: Tetap kunci (karena limit tercapai), tapi tidak muncul pop-up lagi
                // Atau, jika Anda ingin memperbolehkan trading setelah kuis (soft lock), ubah return ini.
                // Tapi biasanya limit harian sifatnya Hard Lock.
                return { isLocked: true, reason: breachReason + " (Kuis Selesai, Istirahatlah)." };
            }
        }

        // --- 5. Hapus Kunci Lokal jika TIDAK ADA VIOLASI ---
        localStorage.removeItem("tradingLockoutDate");
        // ... (hapus kunci lain seperti kode sebelumnya) ...

        return { isLocked: false, reason: "" };
      }


      function checkPerformanceAndNotify(completedTrade) {
        const now = new Date();
        // Ambil semua trade yang valid di bulan ini, termasuk yang baru saja selesai
        const tradesThisMonth = executedPlansData
          .filter(
            (t) =>
              getTradeResult(t).isValid &&
              new Date(t.timestamp).getMonth() === now.getMonth() &&
              new Date(t.timestamp).getFullYear() === now.getFullYear()
          )
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (tradesThisMonth.length === 0) return; // Keluar jika tidak ada data

        // Tentukan balance awal untuk bulan ini dari trade pertama di bulan tersebut
        const initialBalanceThisMonth = tradesThisMonth[0].balance;

        // Hitung total Profit/Loss setelah trade ini selesai
        const totalPLAfter = tradesThisMonth.reduce(
          (sum, t) => sum + getTradeResult(t).profitLoss,
          0
        );

        // Hitung total Profit/Loss SEBELUM trade ini (untuk perbandingan)
        const totalPLBefore =
          totalPLAfter - getTradeResult(completedTrade).profitLoss;

        const percentageAfter =
          initialBalanceThisMonth > 0
            ? (totalPLAfter / initialBalanceThisMonth) * 100
            : 0;
        const percentageBefore =
          initialBalanceThisMonth > 0
            ? (totalPLBefore / initialBalanceThisMonth) * 100
            : 0;

        // --- PERBAIKAN: Aturan notifikasi "Overconfident" ditambahkan untuk semua tingkatan ---
        const milestones = [5, 8, 10, 15, 20];
        milestones.forEach((milestone) => {
          if (percentageAfter >= milestone && percentageBefore < milestone) {
            setTimeout(
              () =>
                showMessageBox(
                  `Pencapaian ${milestone}% Tercapai!`,
                  `Selamat, Anda telah mencapai profit bulanan ${milestone}%! Jangan menjadi terlalu percaya diri (OVERCONFIDENT) dan tetap jaga psikologi trading Anda.`,
                  false
                ),
              500
            );
          }
        });
        // --- AKHIR PERBAIKAN ---
      }
// ▼▼▼ FUNGSI COMPLETE TRADE (FIX PENYIMPANAN ORIGINAL) ▼▼▼
      async function completeTrade(id, entryTime, outcome, fromSection, result = {}) {
        console.log(`Menyelesaikan trade (Waktu: ${entryTime}) hasil: ${outcome}`, result);

        const index = runningPlansData.findIndex((plan) => plan.entryTime === entryTime);
        if (index === -1) {
          showMessageBox("Gagal", `Rencana aktif tidak ditemukan.`, false);
          renderRunningPlans();
          return;
        }

        const planToExecute = { ...runningPlansData[index] };
        if (!planToExecute.assetData) { 
            planToExecute.assetData = getAssetData(planToExecute.symbol); 
        }

        // 1. Tentukan Nilai Original (Snapshot Data Saat Ini)
        // Jika belum ada (karena baru direvisi/dibuat), jadikan nilai saat ini sebagai Original
        if (planToExecute.originalNettSL === undefined) planToExecute.originalNettSL = planToExecute.nettSL;
        if (planToExecute.originalNettTP === undefined) planToExecute.originalNettTP = planToExecute.nettTP;
        if (planToExecute.originalTpPrice === undefined) planToExecute.originalTpPrice = planToExecute.tpPrice;
        
        // Simpan juga original persentase dan pips untuk kelengkapan data
        if (planToExecute.originalrrSlPercentage === undefined && planToExecute.rrPercentage) {
            planToExecute.originalrrSlPercentage = planToExecute.rrPercentage.sl;
            planToExecute.originalrrTpPercentage = planToExecute.rrPercentage.tp;
        }
        if (planToExecute.originalSlPips === undefined) planToExecute.originalSlPips = planToExecute.slPips;
        if (planToExecute.originalTpPips === undefined) planToExecute.originalTpPips = planToExecute.tpPips;

        // 2. Update Data Aktual (Intervensi) jika User Mengedit
        if (typeof result.editedTpPrice === "number" && outcome === "Take Profit") {
             planToExecute.tpPrice = result.editedTpPrice;
             const priceDiffTP = planToExecute.tradeType === "BUY" ? planToExecute.tpPrice - planToExecute.openPrice : planToExecute.openPrice - planToExecute.tpPrice;
             planToExecute.tpPips = calculatePipsPoints(priceDiffTP, planToExecute.symbol);
             planToExecute.rrPips = planToExecute.slPips > 0 ? planToExecute.tpPips / planToExecute.slPips : 0;
             const visualTPPoints = getVisualPoints(planToExecute.tpPips, planToExecute.symbol, true).forCalc;
             const pipValue = planToExecute.assetData.pipValue;
             planToExecute.nettTP = planToExecute.lotSize * visualTPPoints * pipValue;
        } else {
             if (typeof result.editedNettSL === 'number') planToExecute.nettSL = result.editedNettSL;
             if (typeof result.editedNettTP === 'number') planToExecute.nettTP = result.editedNettTP;
        }

        if (planToExecute.balance > 0) {
             planToExecute.rrPercentage.sl = (Math.abs(planToExecute.nettSL) / planToExecute.balance) * 100;
             planToExecute.rrPercentage.tp = (planToExecute.nettTP / planToExecute.balance) * 100;
        }

        // 3. Pindah ke Executed
        runningPlansData.splice(index, 1);
        const now = new Date();
        planToExecute.outcome = outcome;
        planToExecute.timestamp = now.toISOString();
        if (outcome === "Tes") planToExecute.note = "Tes selesai.";
        
        executedPlansData.unshift(planToExecute);

        // 4. SIMPAN KE BACKEND (FIX: Kirim Data Original Juga)
        try {
            // A. Update Status & Simpan Snapshot Original ke DB
            await saveRunningPlan(
                id, 
                "EXECUTED", 
                outcome, 
                now.toISOString(),
                planToExecute.originalTpPrice,
                planToExecute.originalNettSL,
                planToExecute.originalNettTP,
                planToExecute.originalrrSlPercentage,
                planToExecute.originalrrTpPercentage,
                planToExecute.originalRrPips, // Asumsi ada field ini
                planToExecute.originalTpPips,
                planToExecute.originalSlPips
            );

            // B. Update Data Harga/Intervensi Terbaru
            await updatePrice(
                 id, 
                 planToExecute.tpPrice,           
                 planToExecute.nettSL,            
                 planToExecute.nettTP,            
                 planToExecute.rrPercentage.sl,   
                 planToExecute.rrPercentage.tp,   
                 planToExecute.rrPips,            
                 planToExecute.tpPips,            
                 planToExecute.slPips             
            );
            
        } catch (err) {
            console.error("Gagal menyimpan ke backend:", err);
        }

        // 5. Simpan Lokal & Update UI
        saveDataToLocalStorage();
        checkPerformanceAndNotify(planToExecute);
        updateAllDataAndRenderUI(); 
        
        console.log(`Trade (Waktu: ${entryTime}) selesai. Data Original & Intervensi tersimpan.`);
      }

      
 // ▼▼▼ UPDATE FUNGSI SET RUNNING (DENGAN CEK LOSS STREAK) ▼▼▼
      async function setRunning(id, entryTime) {
        
        // 1. CEK LOSS STREAK 10x (RULE BARU - PRIORITAS UTAMA)
        const lossLimitCheck = checkConsecutiveLossLimit();
        if (lossLimitCheck.isLocked) {
            const remainingStr = getReadableDuration(lossLimitCheck.remainingMs);
            const unlockDate = new Date(lossLimitCheck.unlockTime).toLocaleString('id-ID', { dateStyle: 'full', timeStyle: 'short' });
            
            showMessageBox(
                "🛑 Trading Dibekukan (Cooling Down)",
                `
                <div class="text-center">
                    <p class="text-red-600 font-bold text-lg mb-2">Terdeteksi ${lossLimitCheck.streak}x Loss Berturut-turut!</p>
                    <p class="text-sm text-gray-700 mb-4">
                        Sesuai aturan disiplin ketat, akun Anda dibekukan sementara untuk mencegah <em>emotional trading</em> setelah mengalami kekalahan beruntun.
                    </p>
                    <div class="bg-red-50 p-4 rounded-lg border border-red-200 text-left text-xs text-gray-800 space-y-2">
                        <p><strong>Status:</strong> <span class="text-red-600 font-bold">LOCKED</span></p>
                        <p><strong>Alasan:</strong> Mencapai batas 10x SL berturut-turut.</p>
                        <p><strong>Sisa Waktu:</strong> <span class="font-mono font-bold text-red-700 text-sm">${remainingStr}</span></p>
                        <p><strong>Dibuka Kembali:</strong> ${unlockDate}</p>
                    </div>
                    <p class="text-xs text-gray-500 mt-4 italic">"Pasar akan selalu ada minggu depan. Gunakan waktu ini untuk evaluasi strategi."</p>
                </div>
                `,
                false
            );
            return; // STOP PROSES DISINI
        }

        // 2. CEK BATAS JUMLAH TRADE BULANAN (RULE LAMA)
        const limitCheck = checkMonthlyTradeLimit();
        if (limitCheck.isLocked) {
            showMessageBox("Akses Diblokir", limitCheck.reason, false);
            return; 
        }

        // Cari berdasarkan 'entryTime'
        const index = calculatedPlansData.findIndex(
          (plan) => plan.entryTime === entryTime
        );

        if (index === -1) {
          console.warn(
            `Plan (Waktu: ${entryTime}) tidak ditemukan di Calculated Plans.`
          );
          showMessageBox(
            "Gagal",
            `Rencana (Waktu: ${entryTime}) tidak ditemukan. Mungkin sudah diproses?`,
            false
          );
          renderCalculatedPlans();
          return;
        }
        const planToRun = calculatedPlansData[index]; 
        
        // Validasi risiko aktif
        const currentActiveRisk = runningPlansData.reduce(
          (total, plan) => total + (plan.rrPercentage?.sl || 0),
          0
        );
        const newTotalActiveRisk =
          currentActiveRisk + (planToRun.rrPercentage?.sl || 0);
          
        if (newTotalActiveRisk > MAX_ACTIVE_RISK_PERCENT) {
          showMessageBox(
            "Batas Risiko Tercapai",
            `Total risiko aktif akan menjadi ${formatNumber(
              newTotalActiveRisk,
              2
            )}%, melebihi batas ${MAX_ACTIVE_RISK_PERCENT}%.`,
            false
          );
          return;
        }

        // Pindahkan data
        calculatedPlansData.splice(index, 1);
        runningPlansData.unshift(planToRun);

        // Update Backend
        try {
            await saveRunningPlan(id, "RUNNING", null, null);
        } catch (error) {
            console.error("Gagal mengupdate status backend:", error);
        }
        
        // Simpan lokal
        saveDataToLocalStorage(); 

        // Render ulang
        renderCalculatedPlans();
        renderRunningPlans();
        renderDailyRiskSummary();
        renderMonthlyRiskSummary();
        renderMaxDrawdownRiskSummary();
        
        showMessageBox(
          "Berhasil",
          "Data sukses diteruskan ke Rencana Trading Aktif.",
          false
        );

        console.log(`Trade (Waktu: ${entryTime}) moved to Running.`);
      }
      // ▲▲▲ AKHIR UPDATE FUNGSI SET RUNNING ▲▲▲
      // ▲▲▲ AKHIR UPDATE FUNGSI ▲▲▲


      async function editRunningPlan(id, entryTime) { // Terima 'id' (untuk backend) DAN 'entryTime' (untuk logika UI)
        console.log(`Mengedit trade aktif (Waktu: ${entryTime})`);

        // ▼▼▼ PERBAIKAN: Cari berdasarkan 'entryTime' ▼▼▼
        const index = runningPlansData.findIndex((plan) => plan.entryTime === entryTime); // Gunakan entryTime
        // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

        if (index !== -1) {
          const planToEdit = runningPlansData.splice(index, 1)[0]; // Hapus dari running

          // Hapus dari backend (tetap pakai 'id' unik)
          await deleteRunningPlan(userId, id);
          saveDataToLocalStorage(); // Simpan perubahan lokal

          // ▼▼▼ PERBAIKAN: Tambahkan kembali ke AWAL formulir input ▼▼▼
          // Kita panggil addInputRow tanpa argumen untuk baris baru,
          // lalu isi nilainya secara manual agar muncul di atas.
          addInputRow(); // Tambah baris kosong baru di akhir (akan digeser)
          const lastRow = inputRowsContainer.lastElementChild;
          if (lastRow) {
              // Pindahkan baris baru ke paling atas
              inputRowsContainer.insertBefore(lastRow, inputRowsContainer.firstElementChild);
              // Isi nilai dari planToEdit ke baris baru ini (manual)
              const newRowId = lastRow.id.split('-')[1];
              lastRow.querySelector(`#symbol-${newRowId}`).value = planToEdit.symbol;
              if (planToEdit.tradeType === 'BUY') {
                  lastRow.querySelector(`#buyBtn-${newRowId}`).classList.add('active');
                  lastRow.querySelector(`#sellBtn-${newRowId}`).classList.remove('active');
              } else {
                  lastRow.querySelector(`#sellBtn-${newRowId}`).classList.add('active');
                  lastRow.querySelector(`#buyBtn-${newRowId}`).classList.remove('active');
              }
              lastRow.querySelector(`#balance-${newRowId}`).value = planToEdit.balance;
              lastRow.querySelector(`#riskPercent-${newRowId}`).value = planToEdit.riskPercent; // Asumsi ada riskPercent
              lastRow.querySelector(`#priceNow-${newRowId}`).value = planToEdit.priceNow;
              lastRow.querySelector(`#openPrice-${newRowId}`).value = planToEdit.openPrice;
              lastRow.querySelector(`#slPrice-${newRowId}`).value = planToEdit.slPrice;
              lastRow.querySelector(`#tpPrice-${newRowId}`).value = planToEdit.tpPrice;
              lastRow.querySelector(`#note-${newRowId}`).value = planToEdit.note || '';
              // Update step & format harga
              const symbolSelect = lastRow.querySelector(`#symbol-${newRowId}`);
              const priceInputs = lastRow.querySelectorAll('input[type="number"][step]');
              const assetData = getAssetData(planToEdit.symbol);
              const stepValue = getStepValue(assetData.decimals);
              priceInputs.forEach(input => {
                  input.step = stepValue;
                  if (input.value) {
                     input.value = parseFloat(input.value).toFixed(assetData.decimals);
                  }
              });
          }
          saveInputRowsToLocalStorage(); // Simpan urutan input baru
          // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

          renderRunningPlans(); // Render ulang tabel running
          console.log(`Trade (Waktu: ${entryTime}) moved back to input form (top).`);
        } else {
          console.warn(`Trade (Waktu: ${entryTime}) tidak ditemukan di Running Plans.`);
          showMessageBox("Gagal", `Rencana aktif (Waktu: ${entryTime}) tidak ditemukan.`, false);
          renderRunningPlans();
        }
      }

      function autoCalculateTpPrice(rowId) {

        const rowElement = document.getElementById(`inputRow-${rowId}`);

        if (!rowElement) return;



        try {

          const openPriceInput = rowElement.querySelector(`#openPrice-${rowId}`);

          const slPriceInput = rowElement.querySelector(`#slPrice-${rowId}`);

          const tpPriceInput = rowElement.querySelector(`#tpPrice-${rowId}`);

          const buyBtn = rowElement.querySelector(`#buyBtn-${rowId}`);

          const symbolSelect = rowElement.querySelector(`#symbol-${rowId}`);



          const openPrice = parseFloat(openPriceInput.value);

          const slPrice = parseFloat(slPriceInput.value);



          // Hanya hitung jika kedua nilai valid dan tidak nol

          if (isNaN(openPrice) || isNaN(slPrice) || openPrice === 0 || slPrice === 0) {

            return; 

          }



          const isBuy = buyBtn.classList.contains("active");

          

          // 1. Hitung Jarak Risiko (Risk Distance) - Jarak antara Open dan SL

          const riskDistance = Math.abs(openPrice - slPrice);



          // 2. Hitung Jarak Imbalan (Reward Distance) -> DIKALI 2 UNTUK RASIO 1:2

          const rewardDistance = riskDistance * 2; 



          let newTpPrice;

          if (isBuy) {

            // BUY: TP = Open + Reward (Harga Naik)

            newTpPrice = openPrice + rewardDistance;

          } else {

            // SELL: TP = Open - Reward (Harga Turun)

            newTpPrice = openPrice - rewardDistance;

          }



          // Format Tampilan Sesuai Desimal Aset agar rapi

          const assetData = getAssetData(symbolSelect.value);

          const decimals = assetData ? assetData.decimals : 5;

          const formattedTpPrice = newTpPrice.toFixed(decimals);



          // Masukkan nilai ke kolom input TP secara otomatis

          tpPriceInput.value = formattedTpPrice;

        } catch (e) {

          console.error("Gagal menghitung TP otomatis:", e);

        }

      }
      // --- AKHIR DARI FUNGSI editRunningPlan ---
      // --- AKHIR DARI FUNGSI editRunningPlan ---

      // --- DYNAMIC INPUT ROW MANAGEMENT ---
      function addInputRow(initialData = {}) {
        rowCounter++;
        const newRowId = `inputRow-${rowCounter}`;
        const groupedAssets = {
          "Forex Mayor": [],
          "Forex Cross Rate": [],
          "Forex Eksotis": [],
          Komoditas: [],
          Indeks: [],
          Kripto: [],
        };
        Object.keys(assetValues).forEach((symbol) => {
          const asset = assetValues[symbol];
          let categoryLabel;
          switch (asset.type) {
            case "forexMajor":
              categoryLabel = "Forex Mayor";
              break;
            case "forexCross":
              categoryLabel = "Forex Cross Rate";
              break;
            case "forexExotic":
              categoryLabel = "Forex Eksotis";
              break;
            case "commodity":
              categoryLabel = "Komoditas";
              break;
            case "index":
              categoryLabel = "Indeks";
              break;
            case "crypto":
              categoryLabel = "Kripto";
              break;
            default:
              categoryLabel = "Lainnya";
          }
          if (!groupedAssets[categoryLabel]) groupedAssets[categoryLabel] = [];
          groupedAssets[categoryLabel].push(symbol);
        });
        let symbolsOptions =
          '<option value="" disabled selected>Pilih Aset</option>'; // Added default option
        const categoryOrder = [
          "Forex Mayor",
          "Forex Cross Rate",
          "Forex Eksotis",
          "Komoditas",
          "Indeks",
          "Kripto",
          "Lainnya",
        ];
        categoryOrder.forEach((category) => {
          if (groupedAssets[category] && groupedAssets[category].length > 0) {
            symbolsOptions += `<optgroup label="${category}">`;
            groupedAssets[category].sort().forEach((symbol) => {
              symbolsOptions += `<option value="${symbol}">${symbol}</option>`;
            });
            symbolsOptions += `</optgroup>`;
          }
        });
        const rowHtml = `
                      <div id="${newRowId}" class="input-row bg-white p-6 rounded-lg border border-gray-200 relative">
                          <button type="button" class="delete-row-btn absolute top-3 right-3"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
                          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-y-4 gap-x-6">
                              <div><label for="symbol-${rowCounter}" class="block text-sm input-label mb-1">Aset</label><select id="symbol-${rowCounter}" name="symbol" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-gray-300 focus:border-gray-300 sm:text-sm select-field">${symbolsOptions}</select></div>
                              <div><label for="tradeType-${rowCounter}" class="block text-sm input-label mb-1">Tipe Trade</label><div class="flex rounded-md shadow-sm"><button type="button" id="buyBtn-${rowCounter}" class="buy-button w-1/2 py-2 px-4 rounded-l-md border text-center font-medium">BUY</button><button type="button" id="sellBtn-${rowCounter}" class="sell-button w-1/2 py-2 px-4 rounded-r-md border text-center font-medium">SELL</button></div></div>
                              <div><label for="balance-${rowCounter}" class="block text-sm input-label mb-1">Balance Akun ($)</label><input type="number" id="balance-${rowCounter}" name="balance" step="0.01" value="${
          initialData.balance !== undefined ? initialData.balance : ""
        }" placeholder="Cth: 10000" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div class="input-group-percent"><label for="riskPercent-${rowCounter}" class="block text-sm input-label mb-1">Risiko (%)</label><div class="flex mt-1"><input type="number" id="riskPercent-${rowCounter}" name="riskPercent" step="0.01" value="${
          initialData.riskPercent !== undefined ? initialData.riskPercent : ""
        }" placeholder="Cth: 0.2" class="block w-full border rounded-l-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"><span class="inline-flex items-center px-3 border border-l-0 rounded-r-md text-sm font-medium"> % </span></div><p id="riskLimitNote-${rowCounter}" class="text-red-500 text-xs mt-1 hidden">Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%</p></div>
                              <div><label for="priceNow-${rowCounter}" class="block text-sm input-label mb-1">Price Now</label><input type="number" id="priceNow-${rowCounter}" name="priceNow" step="any" value="${
          initialData.priceNow !== undefined ? initialData.priceNow : ""
        }" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="openPrice-${rowCounter}" class="block text-sm input-label mb-1">Open Price</label><input type="number" id="openPrice-${rowCounter}" name="openPrice" step="any" value="${
          initialData.openPrice !== undefined ? initialData.openPrice : ""
        }" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field">
                              </div>
                              <div><label for="slPrice-${rowCounter}" class="block text-sm input-label mb-1">SL Price</label><input type="number" id="slPrice-${rowCounter}" name="slPrice" step="any" value="${
          initialData.slPrice !== undefined ? initialData.slPrice : ""
        }" placeholder="Cth: 1.07000 / 34900.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="tpPrice-${rowCounter}" class="block text-sm input-label mb-1">TP Price</label><input type="number" id="tpPrice-${rowCounter}" name="tpPrice" step="any" value="${
          initialData.tpPrice !== undefined ? initialData.tpPrice : ""
        }" placeholder="Cth: 1.09000 / 35500.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="note-${rowCounter}" class="block text-sm input-label mb-1">Catatan (Opsional)</label><input type="text" id="note-${rowCounter}" name="note" value="${
          initialData.note !== undefined ? initialData.note : ""
        }" placeholder="Cth: Breakout strategy" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                          </div>
                      </div>
                  `;
        inputRowsContainer.insertAdjacentHTML("beforeend", rowHtml);

        // Attach event listeners to all inputs in the new row to save data automatically
        const newRowElement = document.getElementById(newRowId);
        newRowElement.querySelectorAll("input, select").forEach((input) => {
          input.addEventListener("change", saveInputRowsToLocalStorage);
        });
        const buyBtn = newRowElement.querySelector(`#buyBtn-${rowCounter}`);
        const sellBtn = newRowElement.querySelector(`#sellBtn-${rowCounter}`);

        buyBtn.addEventListener("click", () => {
          buyBtn.classList.add("active");
          sellBtn.classList.remove("active");
          autoCalculateTpPrice(rowCounter); // <-- PERBAIKAN: Hitung Ulang TP
          saveInputRowsToLocalStorage();
        });
        sellBtn.addEventListener("click", () => {
          sellBtn.classList.add("active");
          buyBtn.classList.remove("active");
          autoCalculateTpPrice(rowCounter); // <-- PERBAIKAN: Hitung Ulang TP
          saveInputRowsToLocalStorage();
        });

        newRowElement
          .querySelector(".delete-row-btn")
          .addEventListener("click", () => {
            newRowElement.remove();
            saveInputRowsToLocalStorage();
          });

        const symbolSelect = document.getElementById(`symbol-${rowCounter}`);
        const priceNowInput = document.getElementById(`priceNow-${rowCounter}`);
        const openPriceInput = document.getElementById(
          `openPrice-${rowCounter}`
        );
        const slPriceInput = document.getElementById(`slPrice-${rowCounter}`);
        const tpPriceInput = document.getElementById(`tpPrice-${rowCounter}`);

        openPriceInput.addEventListener("input", () => {
          autoCalculateTpPrice(rowCounter);
          saveInputRowsToLocalStorage(); // Simpan setelah TP dihitung
        });
        slPriceInput.addEventListener("input", () => {
          autoCalculateTpPrice(rowCounter);
          saveInputRowsToLocalStorage(); // Simpan setelah TP dihitung
        });

        const updatePriceInputStepsAndFormat = (selectedSymbol) => {
          const assetData = getAssetData(selectedSymbol);
          const decimals = assetData ? assetData.decimals : 5;
          const stepValue = getStepValue(decimals);

          [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(
            (input) => {
              if (input) {
                // Add null check here
                input.setAttribute("step", stepValue);
                if (input.value !== "") {
                  // Only format the value if it's not empty, to avoid changing user's partial input
                  input.value = parseFloat(input.value).toFixed(decimals);
                }
              }
            }
          );
        };

        if (symbolSelect) {
          // Add null check here
          symbolSelect.addEventListener("change", (event) => {
            updatePriceInputStepsAndFormat(event.target.value);
          });
        }

        // Apply formatting on blur for price inputs
        [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(
          (input) => {
            if (input) {
              // Add null check here
              input.addEventListener("blur", (event) => {
                if (symbolSelect && event.target.value !== "") {
                  // Add null check and empty string check
                  const assetData = getAssetData(symbolSelect.value);
                  const decimals = assetData ? assetData.decimals : 5;
                  event.target.value = parseFloat(event.target.value).toFixed(
                    decimals
                  );
                }
              });
            }
          }
        );

        if (initialData.tradeType === "BUY") {
          if (buyBtn) buyBtn.classList.add("active");
          if (sellBtn) sellBtn.classList.remove("active");
        } else if (initialData.tradeType === "SELL") {
          if (sellBtn) sellBtn.classList.add("active");
          if (buyBtn) buyBtn.classList.remove("active");
        } else {
          if (buyBtn) buyBtn.classList.add("active");
          if (sellBtn) sellBtn.classList.remove("active");
        }

        if (initialData.symbol && symbolSelect) {
          // Add null check here
          symbolSelect.value = initialData.symbol;
          // Pastikan pemformatan awal dan pengaturan langkah untuk data yang dimuat
          updatePriceInputStepsAndFormat(initialData.symbol);
        }

        const riskPercentInput = document.getElementById(
          `riskPercent-${rowCounter}`
        );
        const riskLimitNote = document.getElementById(
          `riskLimitNote-${rowCounter}`
        );
        if (riskPercentInput) {
          // Add null check here
          riskPercentInput.addEventListener("input", () => {
            let value = parseFloat(riskPercentInput.value);
            if (isNaN(value)) {
              if (riskLimitNote) riskLimitNote.classList.add("hidden");
              return;
            }
            if (value > MAX_RISK_PER_TRADE) {
              riskPercentInput.value = MAX_RISK_PER_TRADE;
              if (riskLimitNote) riskLimitNote.classList.remove("hidden");
            } else {
              if (riskLimitNote) riskLimitNote.classList.add("hidden");
            }
          });
        }
        if (newRowElement) {
          // Add null check here
          newRowElement.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
          });
        }
        console.log("Baris input ditambahkan:", newRowId);
      }

      /*
      /**
       * FUNGSI PERBAIKAN: Mengonversi array data menjadi string CSV dan memicu unduhan.
       * Fungsi ini memastikan semua data diformat dengan benar agar tidak rusak saat dibuka di Excel.
       * @param {string} filename - Nama file yang akan diunduh.
       * @param {Array<Object>} dataArray - Array berisi objek data.
       * @param {Array<string>} headers - Array berisi header untuk kolom CSV.
       */
      function downloadAsExcel(filename, dataArray, headers) {
        if (!dataArray || dataArray.length === 0) {
          showMessageBox("Informasi", "Tidak ada data untuk diunduh.", false);
          return;
        }

        // Fungsi bantuan untuk memformat setiap sel agar sesuai dengan standar CSV
        const formatCsvCell = (value) => {
          let valueStr =
            value !== undefined && value !== null ? String(value) : "";

          // Jika nilai mengandung karakter yang perlu "dilindungi" (kutip, koma, atau baris baru)
          if (valueStr.search(/("|,|\n)/g) >= 0) {
            // 1. Ganti setiap tanda kutip (") di dalam nilai menjadi dua tanda kutip ("")
            valueStr = valueStr.replace(/"/g, '""');
            // 2. Apit seluruh nilai dengan sepasang tanda kutip
            valueStr = `"${valueStr}"`;
          }
          return valueStr;
        };

        // Buat baris header
        const headerRow = headers
          .map((header) => formatCsvCell(header))
          .join(",");

        // Buat semua baris data
        const dataRows = dataArray.map((row) => {
          // Ambil nilai dari objek 'row' sesuai urutan di 'headers'
          return headers
            .map((header) => {
              const value = row[header];
              // Kolom "R:R %" memiliki format khusus yang sudah diberi kutip, jadi kita tangani secara spesifik
              // untuk menghindari kutip ganda yang salah.
              if (
                header === "R:R %" &&
                typeof value === "string" &&
                value.startsWith('"') &&
                value.endsWith('"')
              ) {
                return formatCsvCell(value.substring(1, value.length - 1));
              }
              return formatCsvCell(value);
            })
            .join(",");
        });

        // Gabungkan header dan baris data
        const csvContent = [headerRow, ...dataRows].join("\r\n");

        // Buat file dan picu unduhan (dengan BOM untuk kompatibilitas Excel)
        const blob = new Blob(
          [new Uint8Array([0xef, 0xbb, 0xbf]), csvContent],
          { type: "text/csv;charset=utf-8;" }
        );
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

     // --- GANTI FUNGSI preparePlanForExport DENGAN INI ---

      function preparePlanForExport(plan, status) {
        const currentAssetData = plan.assetData || getAssetData(plan.symbol);
        const rrPercentageString = plan.rrPercentage
          ? `${-formatNumber(plan.rrPercentage.sl, 2)}% : ${formatNumber(plan.rrPercentage.tp, 2)}%`
          : "N/A";
        
        const isForExecutedTable = status === "Selesai";

        // Logic Result Intervensi (Sesuai Tabel UI)
        let resultIntervensi = "-";
        let resultTidakIntervensi = "-";

        if (isForExecutedTable) {
            // Tentukan Nilai
            let finalVal = 0;
            let origVal = 0;
            let isIntervened = false;

            if (plan.outcome === "Take Profit") {
                origVal = plan.originalNettTP !== undefined ? plan.originalNettTP : plan.nettTP;
                finalVal = plan.nettTP;
            } else if (plan.outcome === "Stop Loss") {
                origVal = plan.originalNettSL !== undefined ? plan.originalNettSL : plan.nettSL;
                finalVal = plan.nettSL;
            }

            // Cek Edit
            if (Math.abs(finalVal - origVal) > 0.01) {
                isIntervened = true;
            }

            if (plan.outcome === "Take Profit" || plan.outcome === "Stop Loss") {
                // Tidak Intervensi: Selalu Original
                resultTidakIntervensi = formatCurrency(origVal, "USD");
                
                // Intervensi: Nilai Akhir
                resultIntervensi = formatCurrency(finalVal, "USD");
                
                // Jika diedit, bungkus dengan kurung untuk Excel/PDF
                if (isIntervened) {
                    resultIntervensi = `( ${resultIntervensi} )`; 
                }
            }
        }

        return {
          Status: status,
          Aset: plan.symbol || "N/A",
          Trade: plan.tradeType,
          "Balance Akun": plan.balance,
          "Waktu Masuk": formatDateAndTimeForExport(plan.entryTime),
          "Price Now": formatNumber(plan.priceNow, currentAssetData.decimals, false),
          "Open Price": formatNumber(plan.openPrice, currentAssetData.decimals, false),
          "SL Price": formatNumber(plan.slPrice, currentAssetData.decimals, false),
          "TP Price": formatNumber(plan.tpPrice, currentAssetData.decimals, false),
          "Pending Pips/Points": getVisualPoints(plan.pendingPips, plan.symbol, isForExecutedTable).display,
          "SL Pips/Points": getVisualPoints(plan.slPips, plan.symbol, isForExecutedTable).display,
          "TP Pips/Points": getVisualPoints(plan.tpPips, plan.symbol, isForExecutedTable).display,
          "R:R Pips": plan.rrPips > 0 ? `1:${formatNumber(plan.rrPips, 1, false)}` : "N/A",
          "R:R %": rrPercentageString,
          "Lot/Units": formatNumber(plan.lotSize, 2),
          "Nett SL": plan.nettSL,
          "Nett TP": plan.nettTP,
          
          OriginalNettSL: plan.originalNettSL,
          OriginalNettTP: plan.originalNettTP,
          
          "Result Intervensi ($)": resultIntervensi,       // Sudah diperbaiki
          "Result Tidak Intervensi ($)": resultTidakIntervensi, // Sudah diperbaiki

          Catatan: plan.note || "-",
          Hasil: plan.outcome || "N/A",
          "Waktu Keluar": formatDateAndTimeForExport(plan.timestamp),
        };
      }
      // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

      if (downloadExecutedExcelBtn) {
        downloadExecutedExcelBtn.addEventListener("click", () => {
          // PERBAIKAN: Header disesuaikan dengan permintaan, termasuk "Price Now" dan lainnya.
          const headers = [
            "Status", "Aset", "Trade", "Balance Akun", "Waktu Masuk", "Price Now",
            "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points",
            "TP Pips/Points", "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP",
            "Result Intervensi ($)", "Result Tidak Intervensi ($)", // <-- TAMBAHKAN
            "OriginalNettSL", "OriginalNettTP",
            "Catatan", "Hasil", "Waktu Keluar",
          ];

          const dataToExport = executedPlansData.map((plan) =>
            preparePlanForExport(plan, "Selesai")
          );
          downloadAsExcel(
            `Rencana_Trading_Selesai_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`,
            dataToExport,
            headers
          );
        });
      }

      // --- GANTI SELURUH BLOK FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      if (deleteAndExportDataBtn) {
        deleteAndExportDataBtn.addEventListener("click", async () => {
          if (executedPlansData.length === 0) {
            showMessageBox(
              "Informasi",
              "Tidak ada data untuk diunduh atau dihapus.",
              false
            );
            return;
          }

          const confirmed = await showMessageBox(
            "Unduh & Hapus Data Selesai?",
            'Anda akan mengunduh semua data dari "Rencana Trading Selesai", lalu menghapusnya secara permanen. Lanjutkan?',
            true
          );

          if (!confirmed) {
            showMessageBox("Dibatalkan", "Proses dibatalkan.", false);
            return;
          }

          try {
            // PERBAIKAN: Header disesuaikan dengan permintaan, termasuk "Price Now" dan lainnya.
            const headers = [
              "Status", "Aset", "Trade", "Balance Akun", "Waktu Masuk", "Price Now",
              "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points",
              "TP Pips/Points", "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP",
              "Result Intervensi ($)", "Result Tidak Intervensi ($)", // <-- TAMBAHKAN
              "OriginalNettSL", "OriginalNettTP",
              "Catatan", "Hasil", "Waktu Keluar",
            ];
            const dataToExport = executedPlansData.map((plan) =>
              preparePlanForExport(plan, "Selesai")
            );
            downloadAsExcel(
              `ARSIP_Rencana_Trading_Selesai_${new Date()
                .toISOString()
                .slice(0, 10)}.csv`,
              dataToExport,
              headers
            );

            await deleteAllExecutedPlans();

            executedPlansData = [];
            await initializeAppFromLocalStorage();

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Gagal saat proses unduh & hapus:", error);
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat proses unduh & hapus. Data tidak dihapus.",
              false
            );
          }
        });
      }

      async function exportToPdf(elementId, filename) {
        const element = document.getElementById(elementId);
        if (!element) {
          console.log("Elemen tidak ditemukan untuk diunduh PDF.");
          return;
        }
        const loadingDiv = document.createElement("div");
        loadingDiv.style.cssText =
          "position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.7);color:white;padding:20px;border-radius:10px;z-index:1000;";
        loadingDiv.textContent = "Membuat PDF...";
        document.body.appendChild(loadingDiv);
        try {
          const canvas = await html2canvas(element, { scale: 2 });
          const imgData = canvas.toDataURL("image/png");
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF("p", "mm", "a4");
          const imgWidth = 210;
          const pageHeight = 297;
          const imgHeight = (canvas.height * imgWidth) / canvas.width;
          let heightLeft = imgHeight;
          let position = 0;
          pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
          heightLeft -= pageHeight;
          while (heightLeft >= 0) {
            position = heightLeft - imgHeight;
            pdf.addPage();
            pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
            heightLeft -= pageHeight;
          }
          pdf.save(filename);
        } catch (error) {
          console.error("Error generating PDF:", error);
          console.log("Gagal membuat PDF: " + error.message);
        } finally {
          document.body.removeChild(loadingDiv);
        }
      }

      /**
       * FUNGSI BANTUAN BARU: Memaksa semua bagian (terutama grafik) untuk dirender
       * sebelum diekspor ke PDF, mengatasi masalah lazy loading dan animasi.
       */
      async function renderAllSectionsForExport() {
        console.log("Force-rendering all sections for PDF export...");
        const renderPromises = [];
        // Loop melalui semua bagian yang terdaftar di chartSections
        for (const sectionId in chartSections) {
          const chartInfo = chartSections[sectionId];
          // Jika bagian tersebut memiliki fungsi render, jalankan
          if (chartInfo && typeof chartInfo.render === "function") {
            renderPromises.push(chartInfo.render());
          }
        }
        // Tunggu semua proses render selesai
        await Promise.all(renderPromises);
        console.log("All sections rendered for export.");
      }

      /**
       * MEMPERBAIKI FUNGSI INI SECARA KESELURUHAN
       * Membuat dan mengunduh file Excel komprehensif yang berisi semua data trading dan statistik,
       * memastikan isinya sama persis dengan data tabel di unduhan PDF.
       * @param {string} filename - Nama file yang akan diunduh.
       */
      async function downloadAllDataAsExcel(filename) {
        if (
          executedPlansData.length === 0 &&
          runningPlansData.length === 0 &&
          calculatedPlansData.length === 0
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data trading untuk diunduh.",
            false
          );
          return;
        }

        try {
          const wb = XLSX.utils.book_new();

          // --- (Bagian Statistik & Ringkasan tidak berubah) ---
          const { summaryStats, riskStats } = getDetailedStatisticsForExport();
          // ... (Kode untuk membuat sheet 1 - 8) ...

          // --- PERBAIKAN: Header Excel Lengkap ---
          const planHeaders = [
            "Status",
            "Aset",
            "Trade",
            "Balance Akun",
            "Waktu Masuk",
            "Price Now",
            "Open Price",
            "SL Price",
            "TP Price",
            "Pending Pips/Points",
            "SL Pips/Points",
            "TP Pips/Points",
            "R:R Pips",
            "R:R %",
            "Lot/Units",
            "Nett SL",
            "Nett TP",
            "Result Intervensi ($)",       // <-- BARU
            "Result Tidak Intervensi ($)", // <-- BARU
            "OriginalNettSL",
            "OriginalNettTP",
            "Catatan",
            "Hasil",
            "Waktu Keluar",
          ];
          
          // Sesuaikan lebar kolom (tambahkan 2 entri untuk kolom baru)
          const tradeDataColWidths = [
            { wch: 10 }, { wch: 15 }, { wch: 8 }, { wch: 15 }, { wch: 20 },
            { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 18 },
            { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 18 }, { wch: 12 },
            { wch: 15 }, { wch: 15 }, 
            { wch: 20 }, { wch: 25 }, // Lebar untuk Result Intervensi & Tidak Intervensi
            { wch: 15 }, { wch: 15 }, { wch: 25 }, { wch: 15 }, { wch: 20 },
          ];

          const convertPlansToAoA = (plans, status) => {
            return plans.map((p) => {
              const formattedPlan = preparePlanForExport(p, status);
              return planHeaders.map((header) => formattedPlan[header]);
            });
          };

          if (calculatedPlansData.length > 0) {
            const body = convertPlansToAoA(calculatedPlansData, "Baru");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "9. Rencana Trading Baru");
          }

          if (runningPlansData.length > 0) {
            const body = convertPlansToAoA(runningPlansData, "Aktif");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "10. Rencana Trading Aktif");
          }

          if (executedPlansData.length > 0) {
            const body = convertPlansToAoA(executedPlansData, "Selesai");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "11. Rencana Trading Selesai");
          }
          // --- AKHIR PERBAIKAN ---

          XLSX.writeFile(wb, filename);
          showMessageBox(
            "Berhasil",
            "File Excel yang komprehensif telah berhasil diunduh.",
            false
          );
        } catch (error) {
          console.error("Gagal membuat file Excel:", error);
          showMessageBox(
            "Gagal Mengunduh",
            "Terjadi kesalahan saat menyiapkan data untuk diunduh.",
            false
          );
        }
      }
      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      async function downloadAllDataAsPdf(filename) {
        const initialScrollY = window.scrollY;
        const loadingDiv = document.createElement("div");
        loadingDiv.style.cssText =
          'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.85); color:white; padding:25px; border-radius:10px; z-index:1001; font-family: "Inter", sans-serif; text-align: center;';
        const progressText = document.createElement("div");
        loadingDiv.appendChild(progressText);
        document.body.appendChild(loadingDiv);

        if (scrollObserver) scrollObserver.disconnect();
        document
          .querySelectorAll(".scroll-animate-section")
          .forEach((section) => section.classList.add("scrolled-into-view"));

        Chart.defaults.animation = false;
        progressText.textContent = "Merender semua grafik...";
        await renderAllSectionsForExport();
        const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        try {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
          const pageHeight = pdf.internal.pageSize.getHeight();
          let finalY = 10;

          const addSectionTitle = (title, estimatedContentHeight = 20) => {
            if (finalY + estimatedContentHeight > pageHeight - 15) {
              pdf.addPage();
              finalY = 10;
            }
            pdf.setFontSize(10);
            pdf.setTextColor(42, 42, 42);
            pdf.text(title, 10, finalY);
            finalY += 3;
          };

          const captureVisibleElement = async (elementId, title) => {
            progressText.textContent = `Mengambil gambar: ${title}...`;
            await delay(100);
            const element = document.getElementById(elementId);
            if (!element) {
              console.warn(`Elemen tidak ditemukan untuk PDF: ${elementId}`);
              return;
            }

            const canvas = await html2canvas(element, {
              scale: 3,
              useCORS: true,
            });
            const imgData = canvas.toDataURL("image/png", 1.0);
            const imgWidth = 190;
            const imgHeight = (canvas.height * imgWidth) / canvas.width;

            addSectionTitle(title, imgHeight + 10);
            pdf.addImage(imgData, "PNG", 10, finalY + 5, imgWidth, imgHeight);
            finalY += imgHeight + 15;
          };

          progressText.textContent = "Membangun tabel...";
          pdf.setFontSize(15);
          pdf.text("Laporan Analisis Kinerja Trading Lengkap", 105, finalY, {
            align: "center",
          });
          finalY += 10;

          // ... (kode awal fungsi tetap sama) ...

          const planHeadersFull = [
            "Aset", "Trade", "Balance", "Waktu Masuk", "Price Now", "Open", "SL", "TP",
            "Pending", "SL Pips", "TP Pips", "R:R Pips", "R:R %", "Lot",
            "Nett SL", "Nett TP", "Catatan", "Hasil/Aksi"
          ];

          // Header khusus untuk Rencana Selesai (lebih lebar/banyak kolom)
          const executedPlanHeadersFull = [
            "Aset", "Trade", "Balance", "Waktu Masuk", "Price Now", "Open", "SL", "TP",
            "Lot", "Nett SL", "Nett TP", 
            "Res. Intervensi", "Res. Non-Intv", // <-- KOLOM BARU DI PDF
            "Catatan", "Hasil", "Waktu Keluar"
          ];

          // Fungsi Mapping Data (Diperbarui)
          const mapPlanToFullArray = (p, status) => {
            const currentAssetData = p.assetData || getAssetData(p.symbol);
            const rrPercentageString = p.rrPercentage
              ? `${-formatNumber(p.rrPercentage.sl, 2)}%:${formatNumber(p.rrPercentage.tp, 2)}%`
              : "N/A";
            const isForExecutedTable = status === "Selesai";

            // Data Dasar (Common)
            const commonData = [
              p.symbol,
              p.tradeType,
              formatCurrency(p.balance),
              formatDateAndTimeForExport(p.entryTime),
              formatNumber(p.priceNow, currentAssetData.decimals, false),
              formatNumber(p.openPrice, currentAssetData.decimals, false),
              formatNumber(p.slPrice, currentAssetData.decimals, false),
              formatNumber(p.tpPrice, currentAssetData.decimals, false),
            ];

            if (isForExecutedTable) {
                // LOGIKA KHUSUS UNTUK TABEL SELESAI (PDF)
                let resIntv = "-";
                let resNonIntv = "-";
                const origTP = p.originalNettTP !== undefined ? p.originalNettTP : p.nettTP;
                const origSL = p.originalNettSL !== undefined ? p.originalNettSL : p.nettSL;

                if (p.outcome === "Take Profit") {
                    resNonIntv = formatCurrency(origTP);
                    if (Math.abs(p.nettTP - origTP) > 0.01) resIntv = formatCurrency(p.nettTP);
                } else if (p.outcome === "Stop Loss") {
                    resNonIntv = formatCurrency(origSL);
                    if (Math.abs(p.nettSL - origSL) > 0.01) resIntv = formatCurrency(p.nettSL);
                }

                return [
                    ...commonData,
                    formatNumber(p.lotSize, 2),
                    formatCurrency(p.nettSL),
                    formatCurrency(p.nettTP),
                    resIntv,      // Result Intervensi
                    resNonIntv,   // Result Tidak Intervensi
                    p.note || "-",
                    p.outcome,
                    formatDateAndTimeForExport(p.timestamp)
                ];
            } else {
                // LOGIKA UNTUK BARU & AKTIF (PDF)
                return [
                    ...commonData,
                    getVisualPoints(p.pendingPips, p.symbol, false).display,
                    getVisualPoints(p.slPips, p.symbol, false).display,
                    getVisualPoints(p.tpPips, p.symbol, false).display,
                    p.rrPips > 0 ? `1:${formatNumber(p.rrPips, 1)}` : "N/A",
                    rrPercentageString,
                    formatNumber(p.lotSize, 2),
                    formatCurrency(p.nettSL),
                    formatCurrency(p.nettTP),
                    p.note || "-",
                    status // Hasil/Aksi
                ];
            }
          };

          const tableStyles = { fontSize: 4, cellPadding: 0.7 };
          const summaryTableStyles = { fontSize: 6, cellPadding: 1.2 };

          if (calculatedPlansData.length > 0) {
            const body = calculatedPlansData.map((p) =>
              mapPlanToFullArray(p, "Baru").slice(0, 17)
            );
            addSectionTitle("Rencana Trading Baru", body.length * 3 + 10);
            pdf.autoTable({
              startY: finalY,
              head: [planHeadersFull],
              body: body,
              theme: "grid",
              headStyles: { fillColor: [22, 160, 133] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;
          }

          if (runningPlansData.length > 0) {
            const body = runningPlansData.map((p) =>
              mapPlanToFullArray(p, "Aktif").slice(0, 17)
            );
            addSectionTitle("Rencana Trading Aktif", body.length * 3 + 10);
            pdf.autoTable({
              startY: finalY,
              head: [planHeadersFull],
              body: body,
              theme: "grid",
              headStyles: { fillColor: [243, 156, 18] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;
          }

          if (executedPlansData.length > 0) {
            const executedBody = executedPlansData.map((p) =>
              mapPlanToFullArray(p, "Selesai")
            );
            addSectionTitle(
              "Rencana Trading Selesai",
              executedBody.length * 3 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [executedPlanHeadersFull],
              body: executedBody,
              theme: "grid",
              headStyles: { fillColor: [41, 128, 185] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            const { summaryStats, riskStats } =
              getDetailedStatisticsForExport();

            addSectionTitle(
              "Statistik Ringkasan Keseluruhan",
              summaryStats.length * 4 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [["Metrik", "Nilai"]],
              body: summaryStats,
              theme: "grid",
              styles: summaryTableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            addSectionTitle(
              "Statistik Risiko dan Imbalan",
              riskStats.length * 4 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [["Metrik", "Nilai"]],
              body: riskStats,
              theme: "grid",
              styles: summaryTableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            const plHeaders = [
              "Bulan",
              "Presentase Akumulasi",
              "Total Eksekusi",
              "TP / SL",
              "Total Eksekusi Bersih",
              "TP Bersih ($)",
              "Akumulasi Nett ($)",
              "Total Saldo ($)",
            ];
            const plAoA = tableToAoA(
              document.getElementById("monthlyPLSummaryBody"),
              plHeaders
            ).slice(1);
            if (plAoA.length > 0) {
              addSectionTitle("Ringkasan P/L Bulanan", plAoA.length * 4 + 10);
              pdf.autoTable({
                startY: finalY,
                head: [plHeaders],
                body: plAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            // --- PERBAIKAN UTAMA DIMULAI DI SINI ---
            const summaryHeaders = [
              "Periode",
              "Presentase Kumulatif",
              "Pips Kumulatif",
              "Total Trade",
              "Saldo Akhir",
            ];

            const dailyAoA = tableToAoA(
              document.getElementById("newDailySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (dailyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Harian Kumulatif",
                dailyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: dailyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const weeklyAoA = tableToAoA(
              document.getElementById("newWeeklySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (weeklyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Mingguan Kumulatif",
                weeklyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: weeklyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const monthlyAoA = tableToAoA(
              document.getElementById("newMonthlySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (monthlyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Bulanan Kumulatif",
                monthlyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: monthlyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const yearlyAoA = tableToAoA(
              document.getElementById("newYearlySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (yearlyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Tahunan Kumulatif",
                yearlyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: yearlyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }
            // --- AKHIR DARI BLOK PERBAIKAN ---

            const chartIdsInOrder = [
              { containerId: "calendarSection", title: "Kalender Bulanan" },
              {
                containerId: "outcomeStatisticsSection",
                title: "Ringkasan Hasil Eksekusi",
              },
              {
                containerId: "assetSuccessStatisticsSection",
                title: "Statistik Keberhasilan Aset",
              },
              {
                containerId: "dailyLineStatisticsSection",
                title: "Statistik Persentase Harian",
              },
              {
                containerId: "monthlyBarStatisticsSection",
                title: "Statistik Persentase Bulanan (Diagram Batang)",
              },
              {
                containerId: "overallPercentageCumulativeStatisticsSection",
                title: "Statistik Persentase Kumulatif Keseluruhan",
              },
              {
                containerId: "overallBalanceCumulativeStatisticsSection",
                title: "Statistik Saldo Akun Kumulatif Keseluruhan",
              },
              {
                containerId: "overallPipsCumulativeStatisticsSection",
                title: "Statistik Pips/Points Kumulatif Keseluruhan",
              },
              {
                containerId: "combinedCumulativeStatisticsSection",
                title: "Statistik Gabungan Kumulatif",
              },
              {
                containerId: "combinedSummaryBarStatisticsSection",
                title: "Ringkasan Akumulasi Gabungan (Diagram Batang)",
              },
              {
                containerId: "balanceFrequencyStatisticsSection",
                title: "Frekuensi Balance per Aset",
              },
              {
                containerId: "percentageFrequencyStatisticsSection",
                title: "Frekuensi Persentase per Aset",
              },
              {
                containerId: "pipsFrequencyStatisticsSection",
                title: "Frekuensi Pips/Points per Aset",
              },
              {
                containerId: "executionFrequencyStatisticsSection",
                title: "Frekuensi Eksekusi per Aset (BUY vs SELL)",
              },
              {
                containerId: "assetExecutionCountStatisticsSection",
                title: "Frekuensi Aset Selesai Dieksekusi",
              },
              {
                containerId: "tradeFrequencyStatisticsSection",
                title: "Frekuensi Eksekusi Trade per Aset",
              },
            ];

            for (const chart of chartIdsInOrder) {
              await captureVisibleElement(chart.containerId, chart.title);
            }
          }

          progressText.textContent = "Menyelesaikan Laporan...";
          const pageCount = pdf.internal.getNumberOfPages();
          for (let i = 1; i <= pageCount; i++) {
            pdf.setPage(i);
            pdf.setFontSize(6);
            pdf.setTextColor(150);
            pdf.text(`Halaman ${i} dari ${pageCount}`, 105, pageHeight - 5, {
              align: "center",
            });
          }

          pdf.save(filename);
          showMessageBox(
            "Berhasil",
            "Laporan PDF komprehensif telah berhasil dibuat.",
            false
          );
        } catch (error) {
          console.error("Gagal membuat PDF:", error);
          showMessageBox(
            "Gagal",
            `Terjadi kesalahan saat membuat file PDF: ${error.message}. Silakan coba lagi.`,
            false
          );
        } finally {
          Chart.defaults.animation = true;
          document.body.removeChild(loadingDiv);
          window.scrollTo({ top: initialScrollY, behavior: "auto" });
          animateOnScroll();
        }
      }
      // --- EVENT LISTENERS (REVISED & CONSOLIDATED) ---
      document.addEventListener("DOMContentLoaded", async () => {
        // ... (kode yang sudah ada) ...

        const downloadPdfBtn = document.getElementById("downloadAllPdfBtn");
        if (downloadPdfBtn) {
          // ... (kode yang sudah ada) ...
        }

        // ▼▼▼ LETAKKAN KODE BARU DI SINI ▼▼▼
        const showPercentageDetailsBtn = document.getElementById(
          "showPercentageDetailsBtn"
        );
        if (showPercentageDetailsBtn) {
          showPercentageDetailsBtn.addEventListener("click", () => {
            const sortedTrades = [...executedPlansData]
              .filter((t) => getTradeResult(t).isValid)
              .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (sortedTrades.length === 0) {
              showMessageBox(
                "Informasi",
                "Belum ada data trading yang selesai untuk ditampilkan.",
                false
              );
              return;
            }

            // 1. Kelompokkan data berdasarkan bulan
            const monthlyData = {};
            sortedTrades.forEach((trade) => {
              const monthKey = new Date(trade.timestamp)
                .toISOString()
                .slice(0, 7); // Format: YYYY-MM
              if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = [];
              }
              monthlyData[monthKey].push(trade);
            });

            const sortedMonthKeys = Object.keys(monthlyData).sort();

            // 2. Bangun struktur HTML modal yang lebih profesional
            // Menggunakan grid untuk tata letak yang lebih baik dan scroll vertikal jika perlu
            let modalContentHtml = `
                  <div id="monthlyDetailContainer" class="max-h-[70vh] overflow-y-auto p-2 bg-gray-100 rounded-lg space-y-6">
                      <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
              `;

            const initialBalance = sortedTrades[0].balance;
            let lastMonthCumulativePL = 0;
            let lastMonthBalance = initialBalance;

            sortedMonthKeys.forEach((monthKey) => {
              const tradesForMonth = monthlyData[monthKey];
              const monthDate = new Date(monthKey + "-02T00:00:00"); // Trik parsing tanggal
              const monthName = monthDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              });

              // --- Kalkulasi Data Statistik Baru untuk Bulan Ini ---
              const totalTradesThisMonth = tradesForMonth.length;
              const assetsThisMonth = [
                ...new Set(tradesForMonth.map((t) => t.symbol)),
              ].join(", ");

              const monthlyPL = tradesForMonth.reduce((sum, trade) => {
                return (
                  sum +
                  (getTradeResult(trade).isWin ? trade.nettTP : trade.nettSL)
                );
              }, 0);

              const startOfMonthBalance = lastMonthBalance;
              const endOfMonthBalance = startOfMonthBalance + monthlyPL;

              const monthlyPercentageGain =
                startOfMonthBalance > 0
                  ? (monthlyPL / startOfMonthBalance) * 100
                  : 0;
              const percentageClass =
                monthlyPercentageGain >= 0
                  ? "positive-value"
                  : "negative-value";

              // --- Akhir Kalkulasi ---

              // Membuat "Kartu" untuk setiap bulan
              modalContentHtml += `
                      <div class="flex flex-col bg-white p-4 rounded-xl shadow-md border border-gray-200">
                          <h4 class="text-base font-semibold text-center text-gray-800 mb-3 pb-2 border-b">${monthName}</h4>

                          <!-- Bagian Statistik -->
                          <div class="text-xs space-y-2 mb-3 text-gray-600">
                              <div class="flex justify-between">
                                  <span class="font-medium">Total Eksekusi:</span>
                                  <span class="font-bold text-gray-800">${totalTradesThisMonth} Trade</span>
                              </div>
                              <div class="flex justify-between">
                                  <span class="font-medium">Presentase Bulan Ini:</span>
                                  <span class="font-bold text-base ${percentageClass}">${formatNumber(
                monthlyPercentageGain,
                2
              )}%</span>
                              </div>
                               <div class="flex justify-between items-start">
                                  <span class="font-medium flex-shrink-0 mr-2">Aset:</span>
                                  <span class="text-right text-gray-500">${
                                    assetsThisMonth || "N/A"
                                  }</span>
                              </div>
                          </div>

                          <!-- Bagian Grafik -->
                          <div class="flex-grow h-48 mt-auto">
                              <canvas id="popupChart-${monthKey}"></canvas>
                          </div>
                      </div>
                  `;

              // Update nilai untuk bulan berikutnya
              lastMonthCumulativePL += monthlyPL;
              lastMonthBalance = endOfMonthBalance;
            });

            modalContentHtml += `</div></div>`;

            // Tampilkan modal dengan struktur baru
            showMessageBox(
              "Detail Performa Bulanan (Persentase Kumulatif)",
              modalContentHtml,
              false
            );

            // 3. Render grafik untuk setiap kanvas setelah modal muncul
            setTimeout(() => {
              let lastMonthCumulativePL_forChart = 0;

              sortedMonthKeys.forEach((monthKey) => {
                const popupCanvas = document.getElementById(
                  `popupChart-${monthKey}`
                );
                const tradesForMonth = monthlyData[monthKey];
                if (
                  !popupCanvas ||
                  !tradesForMonth ||
                  tradesForMonth.length === 0
                )
                  return;

                const labels = [],
                  data = [];
                let currentMonthCumulativePL = 0;

                // Titik awal grafik adalah nilai akhir persentase dari bulan sebelumnya
                labels.push("Mulai");
                const startingPercentage =
                  initialBalance > 0
                    ? (lastMonthCumulativePL_forChart / initialBalance) * 100
                    : 0;
                data.push(startingPercentage);

                // Hitung progres di dalam bulan ini
                tradesForMonth.forEach((trade) => {
                  currentMonthCumulativePL += getTradeResult(trade).isWin
                    ? trade.nettTP
                    : trade.nettSL;
                  const totalCumulativePL =
                    lastMonthCumulativePL_forChart + currentMonthCumulativePL;

                  labels.push(
                    new Date(trade.timestamp).toLocaleDateString("id-ID", {
                      day: "2-digit",
                    })
                  );
                  const currentPercentage =
                    initialBalance > 0
                      ? (totalCumulativePL / initialBalance) * 100
                      : 0;
                  data.push(currentPercentage);
                });

                // Simpan nilai akhir bulan ini untuk bulan berikutnya
                lastMonthCumulativePL_forChart += currentMonthCumulativePL;

                // Render grafik
                new Chart(popupCanvas.getContext("2d"), {
                  type: "line",
                  data: {
                    labels: labels,
                    datasets: [
                      {
                        label: "Persentase Kumulatif",
                        data: data,
                        borderColor: "#2a2a2a",
                        backgroundColor: "rgba(42, 42, 42, 0.1)",
                        fill: true,
                        tension: 0.4,
                        borderWidth: 1.5,
                        pointRadius: 1.5,
                        pointHoverRadius: 4,
                        pointBackgroundColor: "#2a2a2a",
                      },
                    ],
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                      y: {
                        ticks: {
                          font: { size: 9, family: "Inter" },
                          callback: (val) => `${val.toFixed(1)}%`,
                        },
                        grid: {
                          drawTicks: false,
                          color: "#f0f0f0",
                        },
                      },
                      x: {
                        ticks: {
                          font: { size: 9, family: "Inter" },
                          maxRotation: 0,
                          minRotation: 0,
                        },
                        grid: {
                          display: false,
                        },
                      },
                    },
                  },
                });
              });
            }, 150); // Beri jeda agar DOM modal siap dirender
          });
        }

        // --- LETAKKAN KODE BARU DI SINI (di dalam DOMContentLoaded) ---
        if (prevMonthBtn && nextMonthBtn) {
          prevMonthBtn.addEventListener("click", () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar(currentCalendarDate);
          });

          nextMonthBtn.addEventListener("click", () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar(currentCalendarDate);
          });

          // Render kalender saat pertama kali halaman dimuat
          renderCalendar(currentCalendarDate);
        }
        // ▲▲▲ AKHIR DARI BLOK KODE BARU ▲▲▲

        // Other event listeners
        animateOnScroll();
        startBannerAutoslide();
        console.log("Application initialization complete.");
      });

      // --- Photo Upload & Crop Functions ---
      /**
       * Draws an image onto a canvas, ensuring it covers the canvas area
       * while maintaining aspect ratio, effectively cropping it to 1:1.
       * @param {CanvasRenderingContext2D} ctx The canvas rendering context.
       * @param {HTMLImageElement} img The image to draw.
       * @param {number} canvasWidth The width of the canvas.
       * @param {number} canvasHeight The height of the canvas.
       */
      function drawImageCover(ctx, img, canvasWidth, canvasHeight) {
        const imgAspectRatio = img.width / img.height;
        const canvasAspectRatio = 1 / 1; // Target aspect ratio

        let sx, sy, sWidth, sHeight;

        // Calculate the source rectangle (the part of the image to crop)
        if (imgAspectRatio > canvasAspectRatio) {
          // Image is wider than 1:1, crop from the sides
          sHeight = img.height;
          sWidth = sHeight * canvasAspectRatio;
          sx = (img.width - sWidth) / 2;
          sy = 0;
        } else {
          // Image is taller than 1:1, crop from top and bottom
          sWidth = img.width;
          sHeight = sWidth / canvasAspectRatio;
          sx = 0;
          sy = (img.height - sHeight) / 2;
        }

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(
          img,
          sx,
          sy,
          sWidth,
          sHeight,
          0,
          0,
          canvasWidth,
          canvasHeight
        );
      }

      function renderPhotoGallery() {
        if (!photoSlides) {
          console.error("photoSlides is null. Cannot render photo gallery.");
          return;
        }
        photoSlides.innerHTML = ""; // Clear existing images

        if (userPhotos.length === 0) {
          photoSlides.innerHTML =
            '<img src="https://placehold.co/600x600/cccccc/ffffff?text=Add+Photos+1:1" alt="Placeholder" class="w-full h-full object-cover flex-shrink-0">';
          if (prevPhotoBtn) prevPhotoBtn.classList.add("hidden");
          if (nextPhotoBtn) nextPhotoBtn.classList.add("hidden");
          if (photoCounter) photoCounter.classList.add("hidden");
          return;
        }

        userPhotos.forEach((photoUrl, index) => {
          const img = document.createElement("img");
          img.src = photoUrl;
          img.alt = `User Photo ${index + 1}`;
          img.className = "w-full h-full object-cover flex-shrink-0";
          photoSlides.appendChild(img);
        });

        if (photoSlides)
          photoSlides.style.transform = `translateX(-${
            currentPhotoIndex * 100
          }%)`;
        if (prevPhotoBtn)
          prevPhotoBtn.classList.toggle(
            "hidden",
            userPhotos.length <= 1 || currentPhotoIndex === 0
          );
        if (nextPhotoBtn)
          nextPhotoBtn.classList.toggle(
            "hidden",
            userPhotos.length <= 1 ||
              currentPhotoIndex === userPhotos.length - 1
          );
        if (photoCounter)
          photoCounter.classList.toggle("hidden", userPhotos.length === 0);
        if (photoCounter)
          photoCounter.textContent = `${currentPhotoIndex + 1} / ${
            userPhotos.length
          }`;
      }

      function showNextPhoto() {
        if (currentPhotoIndex < userPhotos.length - 1) {
          currentPhotoIndex++;
          renderPhotoGallery();
        }
      }

      function showPrevPhoto() {
        if (currentPhotoIndex > 0) {
          currentPhotoIndex--;
          renderPhotoGallery();
        }
      }

      // Long press variables
      let longPressTimer;
      let isLongPress = false;
      const LONG_PRESS_THRESHOLD = 500; // milliseconds
      const MOVE_THRESHOLD = 10; // pixels
      let startX, startY;

      // --- REFACTORED PHOTO EVENT LISTENERS ---
      const photoGalleryContainer = document.querySelector(
        ".photo-gallery-container"
      );
      if (photoGalleryContainer) {
        photoGalleryContainer.addEventListener("mousedown", (e) => {
          if (e.target.tagName === "BUTTON" || e.target.closest("button"))
            return; // Ignore clicks on nav buttons
          if (e.button !== 0) return; // Only left click
          startX = e.clientX;
          startY = e.clientY;
          isLongPress = false;
          longPressTimer = setTimeout(async () => {
            isLongPress = true;
            if (userPhotos.length > 0) {
              const confirmed = await showMessageBox(
                "Hapus Foto?",
                "Apakah Anda yakin ingin menghapus foto ini?",
                true
              );
              if (confirmed) {
                const indexToDelete = currentPhotoIndex;
                if (db && userId !== "anonymous") {
                  await deleteProfilePicture(userId, indexToDelete);
                } else {
                  userPhotos.splice(indexToDelete, 1);
                  savePhotosToLocalStorage();
                }
                if (
                  currentPhotoIndex >= userPhotos.length &&
                  userPhotos.length > 0
                ) {
                  currentPhotoIndex = userPhotos.length - 1;
                } else if (userPhotos.length === 0) {
                  currentPhotoIndex = 0;
                }
                renderPhotoGallery();
                showMessageBox("Berhasil", "Foto berhasil dihapus.", false);
              }
            }
          }, LONG_PRESS_THRESHOLD);
        });

        photoGalleryContainer.addEventListener("mouseup", (e) => {
          if (e.target.tagName === "BUTTON" || e.target.closest("button"))
            return;
          clearTimeout(longPressTimer);
          if (isLongPress) {
            e.preventDefault(); // Prevent the label from triggering file input on long press release
          }
          isLongPress = false;
        });

        photoGalleryContainer.addEventListener("touchend", (e) => {
          clearTimeout(longPressTimer);
          if (isLongPress) {
            e.preventDefault(); // Prevent the label click after a long press
          }
          isLongPress = false;
        });

        photoGalleryContainer.addEventListener("touchmove", (e) => {
          if (
            longPressTimer &&
            (Math.abs(e.touches[0].clientX - startX) > MOVE_THRESHOLD ||
              Math.abs(e.touches[0].clientY - startY) > MOVE_THRESHOLD)
          ) {
            clearTimeout(longPressTimer);
          }
        });
      }

      if (imageInput) {
        imageInput.addEventListener("change", (event) => {
          // Check if the upload is allowed
          if (userPhotos.length >= MAX_PHOTOS) {
            showMessageBox(
              "Batas Unggahan Tercapai",
              `Anda hanya dapat mengunggah maksimal ${MAX_PHOTOS} foto.`,
              false
            );
            event.target.value = ""; // Reset file input
            return;
          }

          const files = event.target.files;
          if (files.length === 0) return;

          const file = files[0];
          if (file && file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = (e) => {
              currentImageToCrop = new Image();
              currentImageToCrop.onload = () => {
                if (photoUploadModal) showModal(photoUploadModal);

                const canvasSize = 500;
                imageCanvas.width = canvasSize;
                imageCanvas.height = canvasSize;

                drawImageCover(ctx, currentImageToCrop, canvasSize, canvasSize);
              };
              currentImageToCrop.src = e.target.result;
            };
            reader.readAsDataURL(file);
          } else {
            showMessageBox(
              "Gagal",
              "Silakan pilih file gambar yang valid.",
              false
            );
          }
          event.target.value = ""; // Reset file input to allow re-uploading the same file
        });
      }

      if (cropAndSaveBtn) {
        cropAndSaveBtn.addEventListener("click", async () => {
          if (currentImageToCrop && imageCanvas) {
            const imageDataUrl = imageCanvas.toDataURL("image/png");
            const targetIndex = userPhotos.length;
            if (db && userId !== "anonymous") {
              await saveProfilePicture(userId, imageDataUrl, targetIndex);
            } else {
              userPhotos.push(imageDataUrl);
              savePhotosToLocalStorage();
              showMessageBox(
                "Berhasil",
                "Foto profil berhasil disimpan.",
                false
              );
            }
            currentPhotoIndex = targetIndex;
            renderPhotoGallery();
            if (photoUploadModal) hideModal(photoUploadModal);
            currentImageToCrop = null;
          }
        });
      }

      if (cancelPhotoBtn)
        cancelPhotoBtn.addEventListener("click", () => {
          if (photoUploadModal) hideModal(photoUploadModal);
          currentImageToCrop = null;
        });

      if (prevPhotoBtn)
        prevPhotoBtn.addEventListener("click", (e) => {
          e.preventDefault(); // Prevent label click
          e.stopPropagation(); // Stop event from bubbling up
          showPrevPhoto();
        });
      if (nextPhotoBtn)
        nextPhotoBtn.addEventListener("click", (e) => {
          e.preventDefault(); // Prevent label click
          e.stopPropagation(); // Stop event from bubbling up
          showNextPhoto();
        });

      // --- Limit Checking Logic (Refactored for single pass) ---
      function checkTradeLimits() {
        let overallInitialBalance = null,
          overallCurrentBalance = null,
          monthlyInitialBalance = null,
          monthlyCurrentBalance = null,
          dailyInitialBalance = null,
          dailyCurrentBalance = null;
        const now = new Date();
        const currentMonthYearIdentifier = `${now.getFullYear()}-${now.getMonth()}`;
        const todayStart = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          0,
          0,
          0
        ).getTime();

        executedPlansData.forEach((trade) => {
          if (trade.outcome === "Cancel") {
            console.log("Skipping cancelled trade:", trade);
            return;
          }
          const profitLossAmount =
            trade.outcome === "Take Profit"
              ? trade.nettTP
              : trade.outcome === "Stop Loss"
              ? trade.nettSL
              : 0;
          const tradeDate = new Date(trade.timestamp);
          const tradeTimestamp = tradeDate.getTime();
          const tradeMonthYearIdentifier = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

          // Overall balance calculation
          if (overallInitialBalance === null) {
            overallInitialBalance = trade.balance;
            overallCurrentBalance = trade.balance;
          }
          overallCurrentBalance += profitLossAmount;

          // Monthly balance calculation
          if (tradeMonthYearIdentifier === currentMonthYearIdentifier) {
            if (monthlyInitialBalance === null) {
              monthlyInitialBalance = trade.balance;
              monthlyCurrentBalance = trade.balance;
            }
            monthlyCurrentBalance += profitLossAmount;
          }
          // Daily balance calculation
          if (tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime()) {
            if (dailyInitialBalance === null) {
              dailyInitialBalance = trade.balance;
              dailyCurrentBalance = trade.balance;
            }
            dailyCurrentBalance += profitLossAmount;
          }
        });

        const overallCumulativePercentageLoss =
          overallInitialBalance !== null && overallInitialBalance !== 0
            ? ((overallCurrentBalance - overallInitialBalance) /
                overallInitialBalance) *
              100
            : 0;
        const currentMonthPercentageLoss =
          monthlyInitialBalance !== null && monthlyInitialBalance !== 0
            ? ((monthlyCurrentBalance - monthlyInitialBalance) /
                monthlyInitialBalance) *
              100
            : 0;
        const currentDailyPercentageLoss =
          dailyInitialBalance !== null && dailyInitialBalance !== 0
            ? ((dailyCurrentBalance - dailyInitialBalance) /
                dailyInitialBalance) *
              100
            : 0;

        const lastOverallLossBreachMonth = localStorage.getItem(
          "lastOverallLossBreachMonth"
        );
        if (overallCumulativePercentageLoss <= OVERALL_MAX_LOSS_LIMIT) {
          if (lastOverallLossBreachMonth === currentMonthYearIdentifier) {
            limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(
              OVERALL_MAX_LOSS_LIMIT
            )}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
            return false;
          } else {
            localStorage.setItem(
              "lastOverallLossBreachMonth",
              currentMonthYearIdentifier
            );
            limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(
              OVERALL_MAX_LOSS_LIMIT
            )}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
            return false;
          }
        } else {
          if (lastOverallLossBreachMonth === currentMonthYearIdentifier)
            localStorage.removeItem("lastOverallLossBreachMonth");
        }
        if (currentMonthPercentageLoss <= MONTHLY_LOSS_LIMIT) {
          limitNotificationMessage = `Anda telah mencapai batas kerugian bulanan maksimum (-${Math.abs(
            MONTHLY_LOSS_LIMIT
          )}%). Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
          return false;
        }
        if (currentDailyPercentageLoss <= DAILY_LOSS_LIMIT) {
          limitNotificationMessage = `Anda telah mencapai batas kerugian harian (-${Math.abs(
            DAILY_LOSS_LIMIT
          )}%). Input data akan diaktifkan kembali pada hari berikutnya.`;
          return false;
        }
        limitNotificationMessage = "";
        return true;
      }

      function displayLimitNotification(message) {
        const notificationDiv = document.getElementById("limitNotification");
        if (notificationDiv) {
          // Add null check here
          if (message) {
            notificationDiv.textContent = message;
            notificationDiv.classList.remove("hidden", "error-message");
            notificationDiv.classList.add("error-message");
          } else {
            notificationDiv.textContent = "";
            notificationDiv.classList.add("hidden");
            notificationDiv.classList.remove("error-message");
          }
        }
      }

      const calculateAllBtn = document.getElementById("calculateAllBtn");
      if (calculateAllBtn) {
        // Add null check here
        calculateAllBtn.addEventListener("click", () => {
          calculateAllRows();
          
        });
      }

      // --- LETAKKAN SEMUA KODE DI BAWAH INI SEBELUM EVENT LISTENER downloadNewMonthlySummaryBtn ---

      const downloadDailySummaryBtn = document.getElementById(
        "downloadNewDailySummaryBtn"
      );
      if (downloadDailySummaryBtn) {
        downloadDailySummaryBtn.addEventListener("click", () => {
          downloadDailySummaryAsExcel(
            `Ringkasan_Harian_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      const downloadWeeklySummaryBtn = document.getElementById(
        "downloadNewWeeklySummaryBtn"
      );
      if (downloadWeeklySummaryBtn) {
        downloadWeeklySummaryBtn.addEventListener("click", () => {
          downloadWeeklySummaryAsExcel(
            `Ringkasan_Mingguan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      const downloadYearlySummaryBtn = document.getElementById(
        "downloadNewYearlySummaryBtn"
      );
      if (downloadYearlySummaryBtn) {
        downloadYearlySummaryBtn.addEventListener("click", () => {
          downloadYearlySummaryAsExcel(
            `Ringkasan_Tahunan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      // --- AKHIR DARI BLOK KODE BARU ---
      // --- PENAMBAHAN: Event listener untuk tombol unduh ringkasan bulanan ---
      const downloadMonthlySummaryBtn = document.getElementById(
        "downloadNewMonthlySummaryBtn"
      );
      if (downloadMonthlySummaryBtn) {
        downloadMonthlySummaryBtn.addEventListener("click", () => {
          downloadNewMonthlySummaryAsExcel(
            `Ringkasan_Bulanan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      // --- DELETE AND EXPORT DATA FUNCTIONALITY ---
      if (deleteAndExportDataBtn) {
        deleteAndExportDataBtn.addEventListener("click", async () => {
          if (executedPlansData.length === 0) {
            showMessageBox(
              "Informasi",
              "Tidak ada data untuk diunduh atau dihapus.",
              false
            );
            return;
          }

          const confirmed = await showMessageBox(
            "Unduh & Hapus Data?",
            "Anda akan mengunduh semua data trading yang telah selesai, lalu menghapusnya secara permanen. Lanjutkan?",
            true
          );

          if (!confirmed) {
            showMessageBox("Dibatalkan", "Proses dibatalkan.", false);
            return;
          }

          // --- Langkah 1: Siapkan dan Unduh Data ---
          try {
            // Langkah 1: Siapkan dan Unduh Data dengan format yang benar
            // ... kode sebelumnya ...
                      const headers = [
                          "No.", "Aset", "Trade", "Balance Akun", "Waktu Masuk", "Price Now",
                          "Open Price", "SL Price", "TP Price", "Pending Pips/Points", "SL Pips/Points", "TP Pips/Points",
                          "R:R Pips", "R:R %", "Lot/Units", "Nett SL", "Nett TP", 
                          "Result Intervensi ($)", "Result Tidak Intervensi ($)", // <-- TAMBAHKAN INI
                          "Catatan", "Hasil", "Waktu Keluar"
                      ];
                      
                      // Update lebar kolom (opsional)
                      const dataColWidths = [
                          { wch: 5 }, { wch: 15 }, { wch: 8 }, { wch: 15 }, { wch: 20 }, { wch: 15 },
                          { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 18 }, { wch: 15 }, { wch: 15 },
                          { wch: 12 }, { wch: 18 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, 
                          { wch: 20 }, { wch: 20 }, // Lebar kolom baru
                          { wch: 25 }, { wch: 15 }, { wch: 20 }
                      ];

                      const bodyData = executedPlansData.map((plan, index) => {
                          const formattedPlan = preparePlanForExport(plan, "Selesai");
                          return [ 
                              index + 1,
                              formattedPlan.Aset, formattedPlan.Trade, formattedPlan["Balance Akun"], formattedPlan["Waktu Masuk"], formattedPlan["Price Now"],
                              formattedPlan["Open Price"], formattedPlan["SL Price"], formattedPlan["TP Price"], formattedPlan["Pending Pips/Points"],
                              formattedPlan["SL Pips/Points"], formattedPlan["TP Pips/Points"], formattedPlan["R:R Pips"], formattedPlan["R:R %"],
                              formattedPlan["Lot/Units"], formattedPlan["Nett SL"], formattedPlan["Nett TP"], 
                              formattedPlan["Result Intervensi ($)"], formattedPlan["Result Tidak Intervensi ($)"], // <-- DATA BARU
                              formattedPlan.Catatan,
                              formattedPlan.Hasil, formattedPlan["Waktu Keluar"]
                          ];
                      });
                      // ... kode setelahnya ...
            downloadAsExcel(
              `ARSIP_Rencana_Trading_Selesai_${new Date()
                .toISOString()
                .slice(0, 10)}.csv`,
              dataToExport,
              headers
            );

            // Langkah 2: Hapus Data setelah unduhan dimulai
            await deleteAllExecutedPlans();

            executedPlansData = []; // Hapus hanya data yang selesai
            saveDataToLocalStorage();

            // Langkah 3: Render ulang semua komponen yang terpengaruh
            await initializeAppFromLocalStorage(); // Cara termudah untuk me-reset seluruh UI dengan benar

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Gagal saat proses unduh & hapus:", error);
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat proses unduh & hapus. Data tidak dihapus.",
              false
            );
            return; // Batalkan proses jika unduhan gagal
          }

          // --- Langkah 2: Hapus Data Setelah Unduhan Dimulai ---
          try {
            // Hapus dari Firestore
            await deleteAllExecutedPlans(userId);

            // Hapus dari state lokal dan localStorage
            executedPlansData = [];
            localStorage.removeItem("lastOverallLossBreachMonth");
            saveDataToLocalStorage();

            // Render ulang semua komponen yang terpengaruh
            renderExecutedPlans();
            calculateSummaryStatistics();
            updateRiskRewardStatistics();
            calculateAndRenderMonthlyPLSummary();
            renderDailyRiskSummary();
            renderMonthlyRiskSummary();
            calculateAndRenderDailySummary();
            calculateAndRenderWeeklySummary();
            calculateAndRenderNewMonthlySummary();
            calculateAndRenderYearlySummary();

            // Reset semua grafik
            for (const sectionId in chartSections) {
              const chartInfo = chartSections[sectionId];
              if (chartInfo.chartInstance && chartInfo.chartInstance()) {
                chartInfo.chartInstance().destroy();
                chartInfo.setInstance(null);
                chartInfo.hasRendered = false;
              }
            }

            checkTradeLimits();
            displayLimitNotification(limitNotificationMessage);

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Error during data deletion:", error);
            showMessageBox(
              "Gagal Menghapus",
              "Data berhasil diunduh, tetapi terjadi kesalahan saat menghapus data dari aplikasi.",
              false
            );
            return;
          }
        });
      }

      // ... kode yang sudah ada ...

      // --- UPLOAD DATA FUNCTIONALITY ---
      const hiddenFileInput = document.createElement("input");
      hiddenFileInput.type = "file";
      // PERBAIKAN: Menerima file .xlsx dan .csv
      hiddenFileInput.accept =
        ".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel";
      hiddenFileInput.style.display = "none";
      document.body.appendChild(hiddenFileInput);

      if (uploadDataBtn) {
        uploadDataBtn.addEventListener("click", async () => {
          const confirmed = await showMessageBox(
            "Unggah & Tambah Data?",
            "Tindakan ini akan <strong>MENAMBAHKAN</strong> data dari file ke data yang sudah ada. Mengunggah file yang sama dua kali akan menyebabkan duplikasi data. Lanjutkan?",
            true
          );
          if (confirmed) {
            hiddenFileInput.click();
          }
        });
      }

      // --- GANTI SELURUH BLOK EVENT LISTENER DI BAWAH INI ---
      hiddenFileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) {
          hiddenFileInput.value = "";
          return;
        }

        const reader = new FileReader();

        reader.onload = async (e) => {
          showMessageBox(
            "Memproses File...",
            "Harap tunggu, data sedang diimpor...",
            false
          );

          try {
            let csvString;
            if (file.name.toLowerCase().endsWith(".xlsx")) {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: "array" });
              const firstSheetName = workbook.SheetNames[0];
              const worksheet = workbook.Sheets[firstSheetName];
              csvString = XLSX.utils.sheet_to_csv(worksheet);
            } else {
              csvString = e.target.result;
            }

            const parsedResult = parseAllPlansFromCSV(csvString);

            // Panggil fungsi import yang sudah diperbaiki
            await importAllPlans(parsedResult);

            // Hapus notifikasi loading (pesan sukses akan ditampilkan oleh importAllPlans)
            const existingModal = document.querySelector(".message-box-modal");
            if (
              existingModal &&
              existingModal
                .querySelector("h3")
                .textContent.includes("Memproses")
            ) {
              existingModal.remove();
            }
          } catch (error) {
            console.error("Gagal mem-parsing atau mengimpor file:", error);
            document.querySelector(".message-box-modal")?.remove();
            showMessageBox(
              "Gagal Unggah",
              `Terjadi kesalahan. Pastikan format file Anda benar. Error: ${error.message}`,
              false
            );
          } finally {
            hiddenFileInput.value = "";
          }
        };

        if (file.name.toLowerCase().endsWith(".xlsx")) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
      });
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // ... sisa kode Anda ...

      // --- AKHIR DARI BLOK PENGGANTIAN ---
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI SELURUH FUNGSI PARSING DENGAN KODE INI ---
      function parseAllPlansFromCSV(csvString) {
        const lines = csvString.trim().replace(/\r/g, "").split("\n");
        if (lines.length < 2) return { successful: [], failedCount: 0 };

        const headers = lines[0]
          .split(",")
          .map((h) => h.trim().toLowerCase().replace(/"/g, ""));
        const dataRows = lines.slice(1);

        const successful = [];
        let failedCount = 0;

        const headerMapping = {
          symbol: ["aset", "symbol", "pair"],
          tradeType: ["trade", "tipe", "type"],
          balance: ["balance akun", "balance", "saldo"],
          entryTime: ["waktu masuk", "entry time", "open time"],
          priceNow: ["price now", "harga sekarang"],
          openPrice: ["open price", "harga buka"],
          slPrice: ["sl price", "stop loss"],
          tpPrice: ["tp price", "take profit"],
          originalTpPrice: ["originaltpprice"],
          pendingPipsPoints: ["pending pips/points", "pending"],
          slPipsPoints: ["sl pips/points"],
          tpPipsPoints: ["tp pips/points"],
          originalTpPipsPoints: ["originaltppips"],
          originalRrPips: ["originalrrpips"],
          originalRrPercentage: ["originalrrpercentage"],
          nettSL: ["nett sl", "netsl"],
          nettTP: ["nett tp", "nettp"],
          originalNettSL: ["originalnettsl"],
          originalNettTP: ["originalnettp"],
          note: ["catatan", "note", "notes"],
          outcome: ["hasil", "outcome", "result"],
          timestamp: ["waktu keluar", "exit time", "close time"],
          lotSize: ["lot/units", "lot", "size", "volume"],
          rrPercentage: ["r:r %", "rr %", "risk:reward %"],
        };

        const findHeaderIndex = (key) => {
          const possibleNames = headerMapping[key];
          if (!possibleNames) return -1;
          for (const name of possibleNames) {
            const index = headers.indexOf(name);
            if (index !== -1) return index;
          }
          return -1;
        };

        const unquoteCsvField = (field) => {
          if (typeof field !== "string") return field;
          const trimmedField = field.trim();
          if (trimmedField.startsWith('"') && trimmedField.endsWith('"')) {
            return trimmedField
              .substring(1, trimmedField.length - 1)
              .replace(/""/g, '"');
          }
          return trimmedField;
        };

        const cleanNumber = (value) => {
          if (
            typeof value !== "string" ||
            value === "" ||
            value.toLowerCase() === "n/a" ||
            value.toLowerCase() === "nan"
          )
            return NaN;
          return parseFloat(value.replace(/[^0-9.-]/g, ""));
        };

        dataRows.forEach((row, rowIndex) => {
          try {
            const values = row
              .split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
              .map(unquoteCsvField);
            const getValue = (key) => {
              const index = findHeaderIndex(key);
              return index !== -1 ? values[index] : undefined;
            };

            const newPlan = {
              status: "Selesai",
              symbol: getValue("symbol"),
              tradeType: getValue("tradeType")?.toUpperCase(),
              balance: cleanNumber(getValue("balance")),
              entryTime: parseDateRobust(getValue("entryTime"))?.toISOString(),
              priceNow: cleanNumber(getValue("priceNow")),
              openPrice: cleanNumber(getValue("openPrice")),
              slPrice: cleanNumber(getValue("slPrice")),
              tpPrice: cleanNumber(getValue("tpPrice")),
              originalTpPrice: cleanNumber(getValue("originalTpPrice")),
              nettSL: cleanNumber(getValue("nettSL")),
              nettTP: cleanNumber(getValue("nettTP")),
              originalNettSL: cleanNumber(getValue("originalNettSL")),
              originalNettTP: cleanNumber(getValue("originalNettTP")),
              note: getValue("note"),
              outcome: getValue("outcome"),
              timestamp: parseDateRobust(getValue("timestamp"))?.toISOString(),
              lotSize: cleanNumber(getValue("lotSize")),
            };

            if (
              !newPlan.symbol ||
              !newPlan.tradeType ||
              isNaN(newPlan.balance) ||
              !newPlan.timestamp
            ) {
              console.warn(
                `Melewatkan baris ${rowIndex + 2}: Data inti tidak valid.`,
                row
              );
              failedCount++;
              return;
            }

            const assetData = getAssetData(newPlan.symbol);
            const pipsDivisor = newPlan.symbol === "XAG/USD" ? 100 : 10;

            const slPoints = cleanNumber(getValue("slPipsPoints"));
            const tpPoints = cleanNumber(getValue("tpPipsPoints"));
            const pendingPoints = cleanNumber(getValue("pendingPipsPoints"));
            const originalTpPoints = cleanNumber(
              getValue("originalTpPipsPoints")
            );

            newPlan.slPips = !isNaN(slPoints) ? slPoints / pipsDivisor : 0;
            newPlan.tpPips = !isNaN(tpPoints) ? tpPoints / pipsDivisor : 0;
            newPlan.pendingPips = !isNaN(pendingPoints)
              ? pendingPoints / pipsDivisor
              : 0;
            newPlan.originalTpPips = !isNaN(originalTpPoints)
              ? originalTpPoints / pipsDivisor
              : 0;

            const rrPipsString = getValue("originalRrPips")?.replace("1:", "");
            newPlan.originalRrPips = !isNaN(parseFloat(rrPipsString))
              ? parseFloat(rrPipsString)
              : NaN;

            newPlan.rrPips =
              newPlan.slPips > 0 ? newPlan.tpPips / newPlan.slPips : 0;

            const parseRrPercentage = (rrString) => {
              let parsed = { sl: 0, tp: 0 };
              if (rrString && rrString.toLowerCase() !== "n/a") {
                const parts = rrString.replace(/["%]/g, "").split(":");
                if (parts.length === 2) {
                  parsed.sl = Math.abs(parseFloat(parts[0].trim()));
                  parsed.tp = parseFloat(parts[1].trim());
                }
              }
              return parsed;
            };

            newPlan.rrPercentage = parseRrPercentage(getValue("rrPercentage"));
            newPlan.originalRrPercentage = parseRrPercentage(
              getValue("originalRrPercentage")
            );

            newPlan.assetData = assetData;
            newPlan.rowId = `imported-${Date.now()}-${rowIndex}`;

            successful.push(newPlan);
          } catch (error) {
            console.warn(`Gagal memproses baris ${rowIndex + 2}:`, error, row);
            failedCount++;
          }
        });

        return { successful, failedCount };
      }

      // ▼▼▼ KODE BARU 2: FUNGSI LOGIKA TIMER DURASI (DIPERBARUI) ▼▼▼
      function startActiveTimers() {
        // 1. Hapus interval lama agar tidak bertumpuk (memory leak)
        if (window.activeTimerInterval) clearInterval(window.activeTimerInterval);

        // 2. Fungsi Update
        const update = () => {
            const timers = document.querySelectorAll('.running-timer');
            const now = Date.now();
            
            // Batas waktu 3 Hari dalam milidetik
            const THREE_DAYS_MS = 3 * 24 * 60 * 60 * 1000; 

            timers.forEach(timer => {
                const entryTimeAttr = timer.getAttribute('data-entry');
                if (!entryTimeAttr) return;

                const entryTime = new Date(entryTimeAttr).getTime();
                const diff = now - entryTime;

                if (diff >= 0) {
                    // --- LOGIKA GANTI WARNA ---
                    if (diff > THREE_DAYS_MS) {
                        // Jika lewat 3 hari: Ubah ke MERAH
                        timer.classList.remove('text-blue-600', 'bg-blue-50');
                        timer.classList.add('text-red-600', 'bg-red-50');
                    } else {
                        // Jika belum 3 hari: Pastikan tetap BIRU
                        timer.classList.remove('text-red-600', 'bg-red-50');
                        timer.classList.add('text-blue-600', 'bg-blue-50');
                    }

                    // Hitung Jam, Menit, Detik
                    const seconds = Math.floor((diff / 1000) % 60);
                    const minutes = Math.floor((diff / (1000 * 60)) % 60);
                    const hours = Math.floor(diff / (1000 * 60 * 60));
                    
                    // Format 00:00:00
                    const formatted = 
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    timer.textContent = formatted;
                }
            });
        };

        // 3. Jalankan segera, lalu ulang setiap 1 detik
        update();
        window.activeTimerInterval = setInterval(update, 1000);
      }
      // ▲▲▲ AKHIR KODE BARU 2 ▲▲▲
      // ▲▲▲ AKHIR KODE BARU 2 ▲▲▲

      // --- Letakkan fungsi ini di dalam blok // --- HELPER FUNCTIONS --- ---
      // --- LETAKKAN FUNGSI BARU INI DI DALAM BLOK HELPER FUNCTIONS ---
      /**
       * FUNGSI BANTUAN BARU: Menjadi satu-satunya sumber kebenaran untuk hasil trade.
       * @param {object} trade - Objek data trading.
       * @returns {{isWin: boolean, isValid: boolean, profitLoss: number}}
       */
      function getTradeResult(trade) {
        const isValid =
          trade &&
          (trade.outcome === "Take Profit" || trade.outcome === "Stop Loss");
        const isWin = isValid && trade.outcome === "Take Profit";
        const profitLoss = isValid
          ? isWin
            ? trade.nettTP || 0
            : trade.nettSL || 0
          : 0;
        return { isWin, isValid, profitLoss };
      }
      /**
       * PERBAIKAN: Fungsi parsing tanggal yang lebih andal untuk menangani berbagai format.
       * @param {string} dateString - String tanggal, misal: "27/09/2025 15:30:00" atau "2025-09-27T08:30:00.000Z".
       * @returns {Date|null}
       */
      function parseDateRobust(dateString) {
        if (!dateString || typeof dateString !== "string") return null;

        // 1. Coba format ISO (paling andal)
        let date = new Date(dateString);
        if (!isNaN(date.getTime())) return date;

        // 2. Coba format DD/MM/YYYY HH:MM:SS atau DD-MM-YYYY HH:MM:SS
        const matchDMY = dateString.match(
          /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})(?:.*?(\d{1,2}):(\d{1,2}):?(\d{1,2})?)?/
        );
        if (matchDMY) {
          const day = parseInt(matchDMY[1], 10);
          const month = parseInt(matchDMY[2], 10) - 1; // Bulan di JS dari 0-11
          const year = parseInt(matchDMY[3], 10);
          const hour = parseInt(matchDMY[4] || "0", 10);
          const min = parseInt(matchDMY[5] || "0", 10);
          const sec = parseInt(matchDMY[6] || "0", 10);
          date = new Date(year, month, day, hour, min, sec);
          if (!isNaN(date.getTime())) return date;
        }

        // 3. Coba format MM/DD/YYYY HH:MM:SS (kurang umum di Indonesia, tapi sebagai fallback)
        const matchMDY = dateString.match(
          /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/
        );
        if (matchMDY) {
          // Asumsi ini adalah MM/DD/YYYY jika parsing DMY gagal
          const month = parseInt(matchMDY[1], 10) - 1;
          const day = parseInt(matchMDY[2], 10);
          const year = parseInt(matchMDY[3], 10);
          date = new Date(year, month, day);
          if (!isNaN(date.getTime())) return date;
        }

        // Gagal mem-parsing
        return null;
      }
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN: Mengimpor data dengan logika anti-duplikasi.
       * Hanya data yang belum ada di tabel (berdasarkan entryTime) yang akan ditambahkan.
       * @param {{successful: Array<Object>, failedCount: number}} parsedResult - Objek hasil dari parseAllPlansFromCSV.
       */
      async function importAllPlans(parsedResult) {
        const newExecutedFromFile = parsedResult.successful;
        const failedCount = parsedResult.failedCount;

        if (newExecutedFromFile.length === 0 && failedCount > 0) {
          showMessageBox(
            "Gagal Impor",
            `Tidak ada data yang berhasil diimpor. ${failedCount} baris data gagal diproses.`,
            false
          );
          return;
        }
        if (newExecutedFromFile.length === 0) {
          showMessageBox(
            "Informasi",
            "Tidak ada data baru untuk diimpor dari file yang dipilih.",
            false
          );
          return;
        }

        // --- LOGIKA ANTI-DUPLIKASI DIMULAI DI SINI ---
        // 1. Buat Set dari semua entryTime yang sudah ada untuk pencarian yang cepat.
        const existingEntryTimes = new Set(
          executedPlansData.map((plan) => plan.entryTime)
        );

        // 2. Filter data dari file, hanya ambil yang entryTime-nya belum ada.
        const trulyNewPlans = newExecutedFromFile.filter(
          (plan) => !existingEntryTimes.has(plan.entryTime)
        );
        const duplicateCount =
          newExecutedFromFile.length - trulyNewPlans.length;
        // --- AKHIR LOGIKA ANTI-DUPLIKASI ---

        if (trulyNewPlans.length === 0) {
          let message = "Tidak ada data baru yang ditambahkan.";
          if (duplicateCount > 0) {
            message += ` ${duplicateCount} data duplikat dilewati.`;
          }
          showMessageBox("Proses Selesai", message, false);
          return;
        }

        // Simpan HANYA data yang benar-benar baru
        if (db && userId !== "anonymous") {
          try {
            const savePromises = trulyNewPlans.map((p) =>
              saveExecutedPlan(userId, p)
            );
            await Promise.all(savePromises);
            // Listener onSnapshot akan secara otomatis memperbarui UI dari database.
          } catch (error) {
            console.error(
              "Gagal menyimpan data yang diunggah ke Firestore:",
              error
            );
            showMessageBox(
              "Gagal Menyimpan",
              "Terjadi kesalahan saat menyimpan data baru ke database.",
              false
            );
            return;
          }
        } else {
          // Untuk pengguna non-database, panggil pembaruan UI secara manual.
          updateAllDataAndRenderUI([], [], trulyNewPlans);
        }

        // Berikan umpan balik yang jelas kepada pengguna
        let successMessage = `Berhasil! ${trulyNewPlans.length} data baru berhasil ditambahkan.`;
        if (duplicateCount > 0) {
          successMessage += ` ${duplicateCount} data duplikat dilewati.`;
        }
        if (failedCount > 0) {
          successMessage += ` ${failedCount} baris data gagal diproses.`;
        }
        showMessageBox("Proses Selesai", successMessage, false);
      }

      // --- GANTI SELURUH FUNGSI calculateSummaryStatistics DAN updateRiskRewardStatistics DENGAN BLOK DI BAWAH INI ---

      function calculateSummaryStatistics() {
        const elements = {
          totalSettledTrades: document.getElementById(
            "totalSettledTradesSummary"
          ),
          probability: document.getElementById("probabilitySummary"),
          totalPips: document.getElementById("totalPipsSummary"),
          avgPercentagePerTrade: document.getElementById(
            "avgPercentagePerTradeSummary"
          ),
          dailyPercentage: document.getElementById("dailyPercentageSummary"),
          monthlyPercentage: document.getElementById(
            "monthlyPercentageSummary"
          ),
          yearlyPercentage: document.getElementById("yearlyPercentageSummary"),
          finalBalance: document.getElementById("finalBalanceSummary"),
          overallPercentage: document.getElementById(
            "overallPercentageSummary"
          ),
          joinTime: document.getElementById("joinTimeSummary"),
          balanceDrawdown: document.getElementById("balanceDrawdownSummary"),
          balanceDrawdownPeriod: document.getElementById(
            "balanceDrawdownSummaryPeriod"
          ),
          overallMaxDrawdownPercentage: document.getElementById(
            "overallMaxDrawdownPercentage"
          ),
          overallMaxDrawdownPercentagePeriod: document.getElementById(
            "overallMaxDrawdownPercentagePeriod"
          ),
        };

        // PERBAIKAN: Selalu filter dan urutkan data sebelum diproses
        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          // Reset semua elemen jika tidak ada data
          Object.values(elements).forEach((el) => {
            if (el) {
              el.textContent = "N/A";
              el.className = el.className.replace(
                /positive-value|negative-value/g,
                ""
              );
            }
          });
          elements.totalSettledTrades.textContent = "0";
          elements.probability.textContent = "0.00%";
          elements.totalPips.textContent = "0";
          elements.avgPercentagePerTrade.textContent = "0.00%";
          elements.dailyPercentage.textContent = "0.00%";
          elements.monthlyPercentage.textContent = "0.00%";
          elements.yearlyPercentage.textContent = "0.00%";
          elements.finalBalance.textContent = formatCurrency(0, "USD");
          elements.overallPercentage.textContent = "0.00%";
          elements.balanceDrawdown.textContent = formatCurrency(0, "USD");
          elements.overallMaxDrawdownPercentage.textContent = "0.00%";
          elements.balanceDrawdownPeriod.textContent = "Periode: N/A";
          elements.overallMaxDrawdownPercentagePeriod.textContent =
            "Periode: N/A";
          return;
        }

        let totalPips = 0,
          totalTakeProfitTrades = 0,
          totalPercentageChange = 0;
        const initialBalance = relevantTrades[0].balance;
        let currentBalance = initialBalance;
        let peakBalance = initialBalance;
        let maxDrawdownAmount = 0;
        let maxDrawdownPercentage = 0;
        let maxDrawdownStartDate = null;
        let maxDrawdownEndDate = null;
        let peakDate = new Date(relevantTrades[0].timestamp);

        const dailyChanges = {},
          monthlyChanges = {},
          yearlyChanges = {};

        relevantTrades.forEach((trade) => {
          const tradeResult = getTradeResult(trade);
          totalPercentageChange +=
            trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0;
          currentBalance += tradeResult.profitLoss;

          if (tradeResult.isWin) {
            totalTakeProfitTrades++;
            totalPips += getVisualPoints(
              trade.tpPips,
              trade.symbol,
              true
            ).forCalc;
          } else {
            totalPips -= getVisualPoints(
              trade.slPips,
              trade.symbol,
              true
            ).forCalc;
          }

          // PERBAIKAN: Logika Drawdown yang lebih akurat
          if (currentBalance > peakBalance) {
            peakBalance = currentBalance;
            peakDate = new Date(trade.timestamp);
          }
          const currentDrawdown = peakBalance - currentBalance;
          if (currentDrawdown > maxDrawdownAmount) {
            maxDrawdownAmount = currentDrawdown;
            maxDrawdownPercentage =
              peakBalance > 0 ? (maxDrawdownAmount / peakBalance) * 100 : 0;
            maxDrawdownStartDate = peakDate;
            maxDrawdownEndDate = new Date(trade.timestamp);
          }

          const tradeDate = new Date(trade.timestamp);
          const dayKey = tradeDate.toISOString().slice(0, 10);
          const monthKey = tradeDate.toISOString().slice(0, 7);
          const yearKey = tradeDate.getFullYear().toString();

          dailyChanges[dayKey] =
            (dailyChanges[dayKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
          monthlyChanges[monthKey] =
            (monthlyChanges[monthKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
          yearlyChanges[yearKey] =
            (yearlyChanges[yearKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
        });

        const totalSettledTrades = relevantTrades.length;
        const probability =
          totalSettledTrades > 0
            ? (totalTakeProfitTrades / totalSettledTrades) * 100
            : 0;
        const overallPercentageChange =
          initialBalance > 0
            ? ((currentBalance - initialBalance) / initialBalance) * 100
            : 0;
        const drawdownDurationMs =
          maxDrawdownStartDate && maxDrawdownEndDate
            ? maxDrawdownEndDate.getTime() - maxDrawdownStartDate.getTime()
            : 0;

        const avgPercentagePerTradeVal =
          totalSettledTrades > 0
            ? totalPercentageChange / totalSettledTrades
            : 0;
        const avgDailyPercentage =
          Object.keys(dailyChanges).length > 0
            ? Object.values(dailyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(dailyChanges).length
            : 0;
        const avgMonthlyPercentage =
          Object.keys(monthlyChanges).length > 0
            ? Object.values(monthlyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(monthlyChanges).length
            : 0;
        const avgYearlyPercentage =
          Object.keys(yearlyChanges).length > 0
            ? Object.values(yearlyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(yearlyChanges).length
            : 0;

        const applyColorClass = (el, val) => {
          el.classList.remove("positive-value", "negative-value");
          el.classList.add(val < 0 ? "negative-value" : "positive-value");
        };

        elements.totalSettledTrades.textContent = totalSettledTrades;
        elements.probability.textContent = `${formatNumber(probability, 2)}%`;
        elements.joinTime.textContent = new Date(
          relevantTrades[0].timestamp
        ).toLocaleDateString("id-ID");

        elements.totalPips.textContent = formatNumber(totalPips, 0);
        applyColorClass(elements.totalPips, totalPips);

        elements.avgPercentagePerTrade.textContent = `${formatNumber(
          avgPercentagePerTradeVal,
          2
        )}%`;
        applyColorClass(
          elements.avgPercentagePerTrade,
          avgPercentagePerTradeVal
        );

        elements.dailyPercentage.textContent = `${formatNumber(
          avgDailyPercentage,
          2
        )}%`;
        applyColorClass(elements.dailyPercentage, avgDailyPercentage);

        elements.monthlyPercentage.textContent = `${formatNumber(
          avgMonthlyPercentage,
          2
        )}%`;
        applyColorClass(elements.monthlyPercentage, avgMonthlyPercentage);

        elements.yearlyPercentage.textContent = `${formatNumber(
          avgYearlyPercentage,
          2
        )}%`;
        applyColorClass(elements.yearlyPercentage, avgYearlyPercentage);

        elements.finalBalance.textContent = formatCurrency(
          currentBalance,
          "USD"
        );
        applyColorClass(elements.finalBalance, currentBalance - initialBalance);

        elements.overallPercentage.textContent = `${formatNumber(
          overallPercentageChange,
          2
        )}%`;
        applyColorClass(elements.overallPercentage, overallPercentageChange);

        elements.balanceDrawdown.textContent = formatCurrency(
          -maxDrawdownAmount,
          "USD"
        );
        elements.balanceDrawdown.classList.add("negative-value");
        elements.balanceDrawdownPeriod.textContent = `Periode: ${formatDuration(
          drawdownDurationMs
        )}`;

        elements.overallMaxDrawdownPercentage.textContent = `-${formatNumber(
          maxDrawdownPercentage,
          2
        )}%`;
        elements.overallMaxDrawdownPercentage.classList.add("negative-value");
        elements.overallMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(
          drawdownDurationMs
        )}`;
      }

      function updateRiskRewardStatistics() {
        const elements = {
          avgRiskReward: document.getElementById("avgRiskReward"),
          avgSignalSettledWeek: document.getElementById("avgSignalSettledWeek"),
          avgSignalSettledMonth: document.getElementById(
            "avgSignalSettledMonth"
          ),
          avgHoldingPeriod: document.getElementById("avgHoldingPeriod"),
          maxHoldingPeriod: document.getElementById("maxHoldingPeriod"),
          avgTpPips: document.getElementById("avgTpPips"),
          maxTpPips: document.getElementById("maxTpPips"),
          avgSlPips: document.getElementById("avgSlPips"),
          maxSlPips: document.getElementById("maxSlPips"),
          consecutiveProfit: document.getElementById("consecutiveProfit"),
          consecutiveProfitPeriod: document.getElementById(
            "consecutiveProfitPeriod"
          ),
          consecutiveLoss: document.getElementById("consecutiveLoss"),
          consecutiveLossPeriod: document.getElementById(
            "consecutiveLossPeriod"
          ),
          averagePips: document.getElementById("averagePips"),
          grossProfit: document.getElementById("grossProfit"),
          grossLoss: document.getElementById("grossLoss"),
          netProfit: document.getElementById("netProfit"),
          maxBalanceDrawdown: document.getElementById("maxBalanceDrawdown"),
          maxBalanceDrawdownPeriod: document.getElementById(
            "maxBalanceDrawdownPeriod"
          ),
          monthlyBalanceDrawdown: document.getElementById(
            "monthlyBalanceDrawdown"
          ),
          monthlyBalanceDrawdownPeriod: document.getElementById(
            "monthlyBalanceDrawdownPeriod"
          ),
          monthlyMaxDrawdownPercentage: document.getElementById(
            "monthlyMaxDrawdownPercentage"
          ),
          monthlyMaxDrawdownPercentagePeriod: document.getElementById(
            "monthlyMaxDrawdownPercentagePeriod"
          ),
        };

        // PERBAIKAN: Selalu filter dan urutkan data
        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          Object.values(elements).forEach((el) => {
            if (el) el.textContent = "N/A";
          });
          elements.avgRiskReward.textContent = "1 : N/A";
          elements.avgSignalSettledWeek.textContent = "0";
          elements.consecutiveProfit.textContent = "0";
          elements.consecutiveLoss.textContent = "0";
          elements.grossProfit.textContent = formatCurrency(0);
          elements.grossLoss.textContent = formatCurrency(0);
          elements.netProfit.textContent = formatCurrency(0);
          elements.consecutiveProfitPeriod.textContent = "Periode: N/A";
          elements.consecutiveLossPeriod.textContent = "Periode: N/A";
          return;
        }

        const applyColorClass = (el, val) => {
          if (!el) return;
          el.classList.remove("positive-value", "negative-value");
          el.classList.add(val < 0 ? "negative-value" : "positive-value");
        };

        let totalTpPips = 0,
          countTpTrades = 0,
          totalSlPipsAbsolute = 0,
          countSlTrades = 0,
          grossProfitVal = 0,
          grossLossVal = 0,
          totalHoldingPeriodMs = 0;
        let currentProfitStreak = 0,
          maxProfitStreak = 0,
          profitStreakEnd = null,
          maxProfitStreakStart = null;
        let currentLossStreak = 0,
          maxLossStreak = 0,
          lossStreakEnd = null,
          maxLossStreakStart = null;
        let maxHoldingPeriodMs = 0,
          maxTpPipsVal = 0,
          maxSlPipsVal = 0;
        const monthlyTradeCounts = {},
          weeklyTradeCounts = {};

        relevantTrades.forEach((trade, index) => {
          const tradeResult = getTradeResult(trade);
          const holdingDuration = trade.entryTime
            ? new Date(trade.timestamp).getTime() -
              new Date(trade.entryTime).getTime()
            : 0;
          totalHoldingPeriodMs += holdingDuration;
          if (holdingDuration > maxHoldingPeriodMs)
            maxHoldingPeriodMs = holdingDuration;

          const tradeDate = new Date(trade.timestamp);
          const monthYear = tradeDate.toISOString().slice(0, 7);
          const weekYear = `${tradeDate.getFullYear()}-W${getWeekNumber(
            tradeDate
          )}`;
          monthlyTradeCounts[monthYear] =
            (monthlyTradeCounts[monthYear] || 0) + 1;
          weeklyTradeCounts[weekYear] = (weeklyTradeCounts[weekYear] || 0) + 1;

          if (tradeResult.isWin) {
            const pips = getVisualPoints(
              trade.tpPips,
              trade.symbol,
              true
            ).forCalc;
            totalTpPips += pips;
            if (pips > maxTpPipsVal) maxTpPipsVal = pips;
            countTpTrades++;
            grossProfitVal += tradeResult.profitLoss;
            currentProfitStreak++;
            currentLossStreak = 0;
            if (currentProfitStreak > maxProfitStreak) {
              maxProfitStreak = currentProfitStreak;
              profitStreakEnd = tradeDate;
              maxProfitStreakStart = new Date(
                relevantTrades[index - maxProfitStreak + 1].timestamp
              );
            }
          } else {
            const pips = getVisualPoints(
              trade.slPips,
              trade.symbol,
              true
            ).forCalc;
            totalSlPipsAbsolute += pips;
            if (pips > maxSlPipsVal) maxSlPipsVal = pips;
            countSlTrades++;
            grossLossVal += tradeResult.profitLoss;
            currentLossStreak++;
            currentProfitStreak = 0;
            if (currentLossStreak > maxLossStreak) {
              maxLossStreak = currentLossStreak;
              lossStreakEnd = tradeDate;
              maxLossStreakStart = new Date(
                relevantTrades[index - maxLossStreak + 1].timestamp
              );
            }
          }
        });

        const totalPips = totalTpPips - totalSlPipsAbsolute;
        const avgTpPipsVal =
          countTpTrades > 0 ? totalTpPips / countTpTrades : 0;
        const avgSlPipsVal =
          countSlTrades > 0 ? totalSlPipsAbsolute / countSlTrades : 0;
        const avgRiskRewardVal =
          avgSlPipsVal > 0 ? avgTpPipsVal / avgSlPipsVal : 0;
        const avgPipsVal =
          relevantTrades.length > 0 ? totalPips / relevantTrades.length : 0;
        const avgHoldingPeriodMsVal =
          relevantTrades.length > 0
            ? totalHoldingPeriodMs / relevantTrades.length
            : 0;
        const avgSignalSettledMonthVal =
          Object.keys(monthlyTradeCounts).length > 0
            ? Object.values(monthlyTradeCounts).reduce((s, c) => s + c, 0) /
              Object.keys(monthlyTradeCounts).length
            : 0;
        const avgSignalSettledWeekVal =
          Object.keys(weeklyTradeCounts).length > 0
            ? Object.values(weeklyTradeCounts).reduce((s, c) => s + c, 0) /
              Object.keys(weeklyTradeCounts).length
            : 0;
        const profitStreakDurationMs =
          maxProfitStreakStart && profitStreakEnd
            ? profitStreakEnd.getTime() - maxProfitStreakStart.getTime()
            : 0;
        const lossStreakDurationMs =
          maxLossStreakStart && lossStreakEnd
            ? lossStreakEnd.getTime() - maxLossStreakStart.getTime()
            : 0;

        // Hitung ulang drawdown maksimal dari statistik ringkasan
        calculateSummaryStatistics(); // Memastikan data drawdown di-update
        const maxDrawdownAmount = parseFloat(
          document
            .getElementById("balanceDrawdownSummary")
            .textContent.replace(/[^0-9.-]+/g, "")
        );
        const balanceDrawdownDuration = document.getElementById(
          "balanceDrawdownSummaryPeriod"
        ).textContent;

        // PERBAIKAN: Hitung drawdown bulanan secara terpisah dan akurat
        const monthlyDrawdowns = {};
        let initialBalance = relevantTrades[0].balance;
        let cumulativeBalance = initialBalance;

        relevantTrades.forEach((trade) => {
          const monthKey = new Date(trade.timestamp).toISOString().slice(0, 7);
          if (!monthlyDrawdowns[monthKey]) {
            const firstTradeOfMonth = relevantTrades.find(
              (t) =>
                new Date(t.timestamp).toISOString().slice(0, 7) === monthKey
            );
            monthlyDrawdowns[monthKey] = {
              peakBalance: firstTradeOfMonth ? firstTradeOfMonth.balance : 0,
              currentBalance: firstTradeOfMonth ? firstTradeOfMonth.balance : 0,
              maxDrawdownAmount: 0,
              maxDrawdownPercentage: 0,
              maxDrawdownStart: null,
              maxDrawdownEnd: null,
              peakDate: firstTradeOfMonth
                ? new Date(firstTradeOfMonth.timestamp)
                : null,
            };
          }
        });

        // Iterasi kedua untuk menghitung drawdown bulanan
        let monthlyBalances = {};
        relevantTrades.forEach((trade) => {
          const tradeResult = getTradeResult(trade);
          const monthKey = new Date(trade.timestamp).toISOString().slice(0, 7);
          if (monthlyBalances[monthKey] === undefined) {
            const prevMonthKey = new Date(
              new Date(trade.timestamp).setMonth(
                new Date(trade.timestamp).getMonth() - 1
              )
            )
              .toISOString()
              .slice(0, 7);
            monthlyBalances[monthKey] =
              monthlyBalances[prevMonthKey] || initialBalance;
          }

          monthlyBalances[monthKey] += tradeResult.profitLoss;

          let monthData = monthlyDrawdowns[monthKey];
          if (monthlyBalances[monthKey] > monthData.peakBalance) {
            monthData.peakBalance = monthlyBalances[monthKey];
            monthData.peakDate = new Date(trade.timestamp);
          }

          const currentDDA = monthData.peakBalance - monthlyBalances[monthKey];
          if (currentDDA > monthData.maxDrawdownAmount) {
            monthData.maxDrawdownAmount = currentDDA;
            monthData.maxDrawdownPercentage =
              monthData.peakBalance > 0
                ? (currentDDA / monthData.peakBalance) * 100
                : 0;
            monthData.maxDrawdownStart = monthData.peakDate;
            monthData.maxDrawdownEnd = new Date(trade.timestamp);
          }
        });

        const overallMonthlyMaxDDA = Math.max(
          0,
          ...Object.values(monthlyDrawdowns).map((m) => m.maxDrawdownAmount)
        );
        const overallMonthlyMaxDDP = Math.max(
          0,
          ...Object.values(monthlyDrawdowns).map((m) => m.maxDrawdownPercentage)
        );
        const maxDDMonthData = Object.values(monthlyDrawdowns).find(
          (m) => m.maxDrawdownAmount === overallMonthlyMaxDDA
        );
        const monthlyDDDurationMs =
          maxDDMonthData &&
          maxDDMonthData.maxDrawdownStart &&
          maxDDMonthData.maxDrawdownEnd
            ? maxDDMonthData.maxDrawdownEnd.getTime() -
              maxDDMonthData.maxDrawdownStart.getTime()
            : 0;

        // Pembaruan UI
        elements.avgRiskReward.textContent = `1 : ${formatNumber(
          avgRiskRewardVal,
          1
        )}`;
        elements.avgSignalSettledWeek.textContent = formatNumber(
          avgSignalSettledWeekVal,
          0
        );
        elements.avgSignalSettledMonth.textContent = formatNumber(
          avgSignalSettledMonthVal,
          0
        );
        elements.avgHoldingPeriod.textContent = formatDuration(
          avgHoldingPeriodMsVal
        );
        elements.maxHoldingPeriod.textContent =
          formatDuration(maxHoldingPeriodMs);
        elements.avgTpPips.textContent = formatNumber(avgTpPipsVal, 0);
        applyColorClass(elements.avgTpPips, avgTpPipsVal);
        elements.maxTpPips.textContent = formatNumber(maxTpPipsVal, 0);
        applyColorClass(elements.maxTpPips, maxTpPipsVal);
        elements.avgSlPips.textContent = formatNumber(-avgSlPipsVal, 0);
        applyColorClass(elements.avgSlPips, -1);
        elements.maxSlPips.textContent = formatNumber(-maxSlPipsVal, 0);
        applyColorClass(elements.maxSlPips, -1);
        elements.averagePips.textContent =
          formatNumber(avgPipsVal, 0) + " Pips";
        applyColorClass(elements.averagePips, avgPipsVal);
        elements.consecutiveProfit.textContent = formatNumber(
          maxProfitStreak,
          0
        );
        applyColorClass(elements.consecutiveProfit, maxProfitStreak);
        elements.consecutiveProfitPeriod.textContent = `Periode: ${formatDuration(
          profitStreakDurationMs
        )}`;
        elements.consecutiveLoss.textContent = formatNumber(maxLossStreak, 0);
        applyColorClass(elements.consecutiveLoss, -1);
        elements.consecutiveLossPeriod.textContent = `Periode: ${formatDuration(
          lossStreakDurationMs
        )}`;
        elements.grossProfit.textContent = formatCurrency(
          grossProfitVal,
          "USD"
        );
        applyColorClass(elements.grossProfit, grossProfitVal);
        elements.grossLoss.textContent = formatCurrency(grossLossVal, "USD");
        applyColorClass(elements.grossLoss, grossLossVal);
        const netProfitVal = grossProfitVal + grossLossVal;
        elements.netProfit.textContent = formatCurrency(netProfitVal, "USD");
        applyColorClass(elements.netProfit, netProfitVal);
        elements.maxBalanceDrawdown.textContent = formatCurrency(
          -Math.abs(maxDrawdownAmount),
          "USD"
        );
        applyColorClass(elements.maxBalanceDrawdown, -1);
        elements.maxBalanceDrawdownPeriod.textContent = balanceDrawdownDuration;
        elements.monthlyBalanceDrawdown.textContent = formatCurrency(
          -overallMonthlyMaxDDA,
          "USD"
        );
        applyColorClass(elements.monthlyBalanceDrawdown, -1);
        elements.monthlyBalanceDrawdownPeriod.textContent = `Periode: ${formatDuration(
          monthlyDDDurationMs
        )}`;
        elements.monthlyMaxDrawdownPercentage.textContent = `-${formatNumber(
          overallMonthlyMaxDDP,
          2
        )}%`;
        applyColorClass(elements.monthlyMaxDrawdownPercentage, -1);
        elements.monthlyMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(
          monthlyDDDurationMs
        )}`;
      }

      // --- GANTI SELURUH FUNGSI initializeAppFromLocalStorage LAMA DENGAN INI ---
      async function initializeAppFromLocalStorage() {
        console.log("Inisialisasi aplikasi dari localStorage...");

        await loadDataFromLocalStorage();
        loadPhotosFromLocalStorage();
        bannerPhotos = JSON.parse(localStorage.getItem("bannerPhotos")) || [];
        loadSimulatorData();
        const hasInputRows = loadInputRowsFromLocalStorage();

        if (!hasInputRows && inputRowsContainer.children.length === 0) {
          addInputRow();
        }

        updateAllDataAndRenderUI();
        checkTradeLimits();
        displayLimitNotification(limitNotificationMessage);

        // ▼▼▼ TAMBAHKAN PEMANGGILAN INI ▼▼▼
        // Cek notifikasi compounding setelah semua data siap
        setTimeout(() => {
            checkAndShowCompoundingNotification();
        }, 1000);
        setTimeout(() => {
            checkAndShowCompoundingNotification();
            initDailyQuizSystem(); // <--- TAMBAHKAN INI
        }, 1000); // Beri jeda 1 detik agar UI stabil dulu
        // ▲▲▲ AKHIR TAMBAHAN ▲▲▲

        console.log("Inisialisasi dari localStorage selesai.");
      }

        
      // --- AKHIR DARI FUNGSI initializeAppFromLocalStorage ---
      // --- AKHIR DARI FUNGSI initializeAppFromLocalStorage ---

      const chartSections = {
        overallSummaryStatisticsSection: {
          render: calculateSummaryStatistics,
          chartInstance: () => null,
          setInstance: () => {},
          canvasId: null,
          loadingId: null,
          errorId: null,
          noDataId: null,
          hasRendered: false,
        },
        riskRewardStatisticsSection: {
          render: updateRiskRewardStatistics,
          chartInstance: () => null,
          setInstance: () => {},
          canvasId: null,
          loadingId: null,
          errorId: null,
          noDataId: null,
          hasRendered: false,
        },
        assetSuccessStatisticsSection: {
          render: fetchAndRenderPieChart,
          chartInstance: () => assetPieChart,
          setInstance: (chart) => (assetPieChart = chart),
          canvasId: "assetSuccessPieChart",
          loadingId: "pieChartLoading",
          errorId: "pieChartError",
          noDataId: "pieChartNoData",
          hasRendered: false,
        },
        dailyLineStatisticsSection: {
          render: fetchAndRenderDailyLineChart,
          chartInstance: () => dailyLineChart,
          setInstance: (chart) => (dailyLineChart = chart),
          canvasId: "dailyLineChart",
          loadingId: "dailyLineChartLoading",
          errorId: "dailyLineChartError",
          noDataId: "dailyLineChartNoData",
          hasRendered: false,
        },
        monthlyBarStatisticsSection: {
          render: fetchAndRenderMonthlyBarChart,
          chartInstance: () => monthlyBarChart,
          setInstance: (chart) => (monthlyBarChart = chart),
          canvasId: "monthlyBarChart",
          loadingId: "monthlyBarChartLoading",
          errorId: "monthlyBarChartError",
          noDataId: "monthlyBarChartNoData",
          hasRendered: false,
        },
        overallPercentageCumulativeStatisticsSection: {
          render: fetchAndRenderOverallPercentageCumulativeChart,
          chartInstance: () => overallPercentageCumulativeChart,
          setInstance: (chart) => (overallPercentageCumulativeChart = chart),
          canvasId: "overallPercentageCumulativeChart",
          loadingId: "overallPercentageCumulativeChartLoading",
          errorId: "overallPercentageCumulativeChartError",
          noDataId: "overallPercentageCumulativeChartNoData",
          hasRendered: false,
        },
        overallBalanceCumulativeStatisticsSection: {
          render: fetchAndRenderOverallBalanceCumulativeChart,
          chartInstance: () => overallBalanceCumulativeChart,
          setInstance: (chart) => (overallBalanceCumulativeChart = chart),
          canvasId: "overallBalanceCumulativeChart",
          loadingId: "overallBalanceCumulativeChartLoading",
          errorId: "overallBalanceCumulativeChartError",
          noDataId: "overallBalanceCumulativeChartNoData",
          hasRendered: false,
        },
        overallPipsCumulativeStatisticsSection: {
          render: fetchAndRenderOverallPipsCumulativeChart,
          chartInstance: () => overallPipsCumulativeChart,
          setInstance: (chart) => (overallPipsCumulativeChart = chart),
          canvasId: "overallPipsCumulativeChart",
          loadingId: "overallPipsCumulativeChartLoading",
          errorId: "overallPipsCumulativeChartError",
          noDataId: "overallPipsCumulativeChartNoData",
          hasRendered: false,
        },
        combinedSummaryBarStatisticsSection: {
          render: fetchAndRenderCombinedBarChart,
          chartInstance: () => combinedBarChart,
          setInstance: (chart) => (combinedBarChart = chart),
          canvasId: "combinedSummaryBarChart",
          loadingId: "combinedSummaryBarChartLoading",
          errorId: "combinedSummaryBarChartError",
          noDataId: "combinedSummaryBarChartNoData",
          hasRendered: false,
        },
        tradeFrequencyStatisticsSection: {
          render: fetchAndRenderTradeFrequencyChart,
          chartInstance: () => tradeFrequencyChart,
          setInstance: (chart) => (tradeFrequencyChart = chart),
          canvasId: "tradeFrequencyChart",
          loadingId: "tradeFrequencyChartLoading",
          errorId: "tradeFrequencyChartError",
          noDataId: "tradeFrequencyChartNoData",
          hasRendered: false,
        },
        balanceFrequencyStatisticsSection: {
          render: fetchAndRenderBalanceFrequencyChart,
          chartInstance: () => balanceFrequencyChart,
          setInstance: (chart) => (balanceFrequencyChart = chart),
          canvasId: "balanceFrequencyChart",
          loadingId: "balanceFrequencyChartLoading",
          errorId: "balanceFrequencyChartError",
          noDataId: "balanceFrequencyChartNoData",
          hasRendered: false,
        },
        percentageFrequencyStatisticsSection: {
          render: fetchAndRenderPercentageFrequencyChart,
          chartInstance: () => percentageFrequencyChart,
          setInstance: (chart) => (percentageFrequencyChart = chart),
          canvasId: "percentageFrequencyChart",
          loadingId: "percentageFrequencyChartLoading",
          errorId: "percentageFrequencyChartError",
          noDataId: "percentageFrequencyChartNoData",
          hasRendered: false,
        },
        pipsFrequencyStatisticsSection: {
          render: fetchAndRenderPipsFrequencyChart,
          chartInstance: () => pipsFrequencyChart,
          setInstance: (chart) => (pipsFrequencyChart = chart),
          canvasId: "pipsFrequencyChart",
          loadingId: "pipsFrequencyChartLoading",
          errorId: "pipsFrequencyChartError",
          noDataId: "pipsFrequencyChartNoData",
          hasRendered: false,
        },
        executionFrequencyStatisticsSection: {
          render: fetchAndRenderExecutionFrequencyChart,
          chartInstance: () => executionFrequencyChart,
          setInstance: (chart) => (executionFrequencyChart = chart),
          canvasId: "executionFrequencyChart",
          loadingId: "executionFrequencyChartLoading",
          errorId: "executionFrequencyChartError",
          noDataId: "executionFrequencyChartNoData",
          hasRendered: false,
        },
        assetExecutionCountStatisticsSection: {
          render: fetchAndRenderAssetExecutionCountChart,
          chartInstance: () => assetExecutionCountChart,
          setInstance: (chart) => (assetExecutionCountChart = chart),
          canvasId: "assetExecutionCountChart",
          loadingId: "assetExecutionCountChartLoading",
          errorId: "assetExecutionCountChartError",
          noDataId: "assetExecutionCountChartNoData",
          hasRendered: false,
        },
        outcomeStatisticsSection: {
          render: fetchAndRenderOutcomeRadarChart,
          chartInstance: () => outcomeRadarChart,
          setInstance: (chart) => (outcomeRadarChart = chart),
          canvasId: "outcomeRadarChart",
          loadingId: "outcomeRadarChartLoading",
          errorId: "outcomeRadarChartError",
          noDataId: "outcomeRadarChartNoData",
          hasRendered: false,
        },
        combinedCumulativeStatisticsSection: {
          render: fetchAndRenderCombinedCumulativeChart,
          chartInstance: () => combinedCumulativeChart,
          setInstance: (chart) => (combinedCumulativeChart = chart),
          canvasId: "combinedCumulativeChart",
          loadingId: "combinedCumulativeChartLoading",
          errorId: "combinedCumulativeChartError",
          noDataId: "combinedCumulativeChartNoData",
          hasRendered: false,
        },
      };

      // --- SCROLL ANIMATION LOGIC ---
      const animateOnScroll = () => {
        const sections = document.querySelectorAll(".scroll-animate-section");

        // Putuskan koneksi observer lama jika ada untuk menghindari duplikasi
        if (scrollObserver) {
          scrollObserver.disconnect();
        }

        scrollObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const sectionId = entry.target.id;
              const chartInfo = chartSections[sectionId];
              if (entry.isIntersecting) {
                entry.target.classList.add("scrolled-into-view");
                if (chartInfo && !chartInfo.hasRendered && chartInfo.canvasId) {
                  chartInfo.render();
                  chartInfo.hasRendered = true;
                }
              } else {
                // Jangan hapus kelas jika tidak ingin animasi berulang saat scroll ke atas
                // entry.target.classList.remove('scrolled-into-view');
                if (
                  chartInfo &&
                  chartInfo.chartInstance &&
                  chartInfo.chartInstance()
                ) {
                  chartInfo.chartInstance().destroy();
                  chartInfo.setInstance(null);
                  chartInfo.hasRendered = false;
                }
              }
            });
          },
          { root: null, rootMargin: "0px", threshold: 0.1 }
        );
        sections.forEach((section) => scrollObserver.observe(section));
      };
      // --- LETAKKAN BLOK KODE BARU YANG SUDAH DIPERBAIKI DI SINI ---

      // --- GANTI SELURUH BLOK LOGIKA INTERAKSI BANNER DENGAN INI ---
      const bannerLabel = document.querySelector('label[for="imageInput16x4"]');
      const imageInput16x4 = document.getElementById("imageInput16x4");

      // Variabel untuk melacak status klik/tahan
      let pressStartTime = 0;
      const DELETE_PHOTO_THRESHOLD = 800; // Tahan > 800ms untuk dianggap 'tahan lama'

      if (bannerLabel && imageInput16x4) {
        const handlePressStart = (e) => {
          if (e.button && e.button !== 0) return; // Abaikan klik kanan
          pressStartTime = Date.now();
        };

        const handlePressEnd = async (e) => {
          if (pressStartTime === 0) return;
          const pressDuration = Date.now() - pressStartTime;
          pressStartTime = 0;

          // Hanya jalankan aksi HAPUS jika ini adalah 'tahan lama'
          if (pressDuration >= DELETE_PHOTO_THRESHOLD) {
            e.preventDefault(); // Mencegah pemicu input file setelah tahan lama

            if (bannerPhotos.length > 0) {
              const confirmed = await showMessageBox(
                "Hapus Foto Banner?",
                `Yakin ingin menghapus foto ${currentBannerPhotoIndex + 1}?`,
                true
              );
              if (confirmed) {
                deleteBannerPhoto(currentBannerPhotoIndex);
                if (
                  currentBannerPhotoIndex >= bannerPhotos.length &&
                  bannerPhotos.length > 0
                ) {
                  currentBannerPhotoIndex = bannerPhotos.length - 1;
                }
                renderBannerGallery();
              }
            }
          }
          // Klik singkat (kurang dari threshold) akan ditangani oleh <label> secara native.
        };

        // Pasang event listener ke <label>
        bannerLabel.addEventListener("mousedown", handlePressStart);
        bannerLabel.addEventListener("mouseup", handlePressEnd);
        bannerLabel.addEventListener("mouseleave", () => {
          pressStartTime = 0;
        });
        bannerLabel.addEventListener("touchstart", handlePressStart, {
          passive: true,
        });
        bannerLabel.addEventListener("touchend", handlePressEnd);

        // Pasang event listener ke input file banner itu sendiri
        imageInput16x4.addEventListener("change", (event) =>
          handleImageUpload(event, "16:4")
        );
      }
      // --- AKHIR BLOK PENGGANTIAN ---
      // --- AKHIR BLOK PENGGANTIAN ---
      // --- AKHIR BLOK PENGGANTIAN ---

      // --- EVENT LISTENERS (REVISED & CONSOLIDATED) ---
      document.addEventListener("DOMContentLoaded", async () => {
        console.log("DOM Content Loaded. Initializing app...");
        
        // ▼▼▼ PERBAIKAN: Panggil fungsi kuis DI SINI agar selalu jalan ▼▼▼
        if (typeof initDailyQuizSystem === 'function') {
            initDailyQuizSystem(); 
        }
        // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

        updateDateTime();
        setInterval(updateDateTime, 1000);

        // ... (kode inisialisasi Firebase/LocalStorage lainnya biarkan saja) ...

        // Initialize Firebase or fallback to localStorage
        if (
          Object.keys(firebaseConfig).length > 0 &&
          typeof __firebase_config !== "undefined" &&
          __firebase_config !== "{}"
        ) {
          console.log("Firebase config found, initializing...");
          app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          storage = getStorage(app);

          onAuthStateChanged(auth, async (user) => {
            if (user) {
              userId = user.uid;
              console.log("Authenticated with Firebase UID:", userId);
              
              // ▼▼▼ PERBAIKAN FOTO: Panggil fungsi yang sekarang sudah 100% lokal ▼▼▼
              await loadProfilePictures(userId); // Panggil versi lokal (parameter uid diabaikan)
              loadBannerPhotos(); // Panggil versi lokal (ini sudah benar)
              // ▲▲▲ AKHIR PERBAIKAN ▲▲▲

              // await loadCalculatedPlans(userId); // (Biarkan jika dikomentari)
              await loadRunningPlans(userId); // Muat data running
              await loadExecutedPlans(userId); // Muat data executed
              // loadBannerPhotos(); // Dihapus dari sini (sudah dipanggil di atas)
            } else {
              try {
                const initialAuthToken =
                  typeof __initial_auth_token !== "undefined"
                    ? __initial_auth_token
                    : null;
                if (initialAuthToken) {
                  await signInWithCustomToken(auth, initialAuthToken);
                } else {
                  await signInAnonymously(auth);
                }
              } catch (error) {
                console.error(
                  "Firebase authentication failed, falling back to localStorage.",
                  error
                );
                await initializeAppFromLocalStorage();
              }
            }
          });
        } else {
          console.log("No Firebase config. Using localStorage.");
          await initializeAppFromLocalStorage();
        }

        // Attach all button event listeners here to ensure functions are in scope
        const addInputRowBtn = document.getElementById("addInputRowBtn");
        if (addInputRowBtn) {
          addInputRowBtn.addEventListener("click", () => {
            if (checkTradeLimits()) {
              addInputRow();
              saveInputRowsToLocalStorage();
              displayLimitNotification("");
            } else {
              displayLimitNotification(limitNotificationMessage);
            }
          });
        }

        // PDF Download Listener
        const downloadPdfBtn = document.getElementById("downloadAllPdfBtn");
        if (downloadPdfBtn) {
          downloadPdfBtn.addEventListener("click", () => {
            downloadAllDataAsPdf(
              `Laporan_Trading_Lengkap_${new Date()
                .toISOString()
                .slice(0, 10)}.pdf`
            );
          });
        }

        // Other event listeners
        animateOnScroll();
        startBannerAutoslide();
        console.log("Application initialization complete.");
      });
      window.exportToPdf = exportToPdf;
    </script>

<script>
      const token = localStorage.getItem("token");
      if (!token) {
        // Tidak ada token, tidak bisa tampilkan info
      } else {
        // ▼▼▼ KODE BARU: Simpan waktu login ▼▼▼
        const loginTime = new Date();
        const loginTimeString = loginTime.toLocaleTimeString("id-ID", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        }).replace(/\./g, ':'); // Format HH:MM:SS
        // ▲▲▲ AKHIR KODE BARU ▲▲▲

        fetch("https://leodra.fiqrianandahakin.my.id/api/auth/me", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })
          .then((res) => {
            if (!res.ok) {
              localStorage.removeItem("token");
            }
            return res.json();
          })
          .then((user) => {
            localStorage.setItem("user", JSON.stringify(user));
            
            const userAccountName = user.email || user.name || "Nama Akun"; 
            
            // 1. Tampilkan di header desktop
            const desktopUserEl = document.getElementById("desktopUserAccount");
            if (desktopUserEl) {
              desktopUserEl.textContent = userAccountName;
            }

            // 2. Tampilkan di menu mobile (pop-up)
            const mobileUserEl = document.getElementById("mobileUserName");
            if (mobileUserEl) {
              mobileUserEl.textContent = userAccountName;
            }

            // ▼▼▼ KODE BARU: Tampilkan waktu login di pop-up ▼▼▼
            const mobileLoginTimeEl = document.getElementById("mobileLoginTime");
            if (mobileLoginTimeEl) {
              mobileLoginTimeEl.textContent = `Login: ${loginTimeString} WIB`;
            }
            // ▲▲▲ AKHIR KODE BARU ▲▲▲
          })
          .catch(() => {
            localStorage.removeItem("token");
          });
      }
    </script>
    <!-- ▼▼▼ INPUT FILE TERSEMBUNYI UNTUK PLAN TRADING ▼▼▼ -->
<input type="file" id="planPhotoInput" accept="image/*" class="hidden">
<!-- ▲▲▲ AKHIR INPUT FILE ▲▲▲ -->
      </body>
</html>